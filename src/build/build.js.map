{"version":3,"sources":["webpack:///build.js","webpack:///./src/js/webviewtestShare.js","webpack:///./src/js/shareInfo.js","webpack:///./lib/hammerjs/hammer.min.js","webpack:///./lib/vue/dist/vue.js","webpack:///./lib/vue-resource/dist/vue-resource.common.js","webpack:///./lib/vue-router/dist/vue-router.min.js","webpack:///./lib/vue-touch/vue-touch.min.js","webpack:///./lib/vuex/dist/vuex.min.js","webpack:///app.vue","webpack:///./src/app.vue?63fe","webpack:///./~/vue-infinite-scroll/vue-infinite-scroll.js","webpack:///./src/app.vue","webpack:///./src/main.js","webpack:///./src/vuex/store.js"],"names":["webpackJsonp","0","module","exports","__webpack_require__","2","say","alert","test","show","u","navigator","userAgent","isAndroid","indexOf","isIOS","match","isHide","window","WebViewJavascriptBridge","callHandler","responseData","console","log","document","addEventListener","hasBuildScript","getElementById","body","removeChild","script","createElement","id","innerHTML","appendChild","5","style","background","share","connectWebViewJavascriptBridge","callback","GetQueryString","name","reg","RegExp","r","location","search","substr","bridge","init","message","responseCallback","data","registerHandler","url","href","repStr","str","replace","title","brief","shareUrl","7","__WEBPACK_AMD_DEFINE_RESULT__","a","b","c","d","e","setTimeout","j","f","Array","isArray","g","forEach","length","call","hasOwnProperty","h","Error","stack","warn","apply","this","arguments","i","prototype","Object","create","constructor","_super","la","k","oa","l","m","q","n","removeEventListener","o","parentNode","p","trim","split","s","slice","t","push","sort","toUpperCase","ma","v","ua","w","ownerDocument","defaultView","parentWindow","x","manager","element","target","options","inputTarget","domHandler","enable","handler","y","inputClass","xa","M","ya","P","wa","R","L","z","pointers","changedPointers","Ea","Ga","Ha","isFirst","isFinal","session","eventType","A","emit","recognize","prevInput","firstInput","D","firstMultiple","center","E","timeStamp","ra","deltaTime","angle","I","distance","H","B","offsetDirection","G","deltaX","deltaY","F","overallVelocityX","overallVelocityY","overallVelocity","qa","scale","K","rotation","J","maxPointers","C","srcEvent","offsetDelta","prevDelta","lastInterval","Da","velocity","velocityX","velocityY","direction","clientX","pa","clientY","Ia","Ja","Ka","La","Ma","Qa","Math","sqrt","atan2","PI","Ra","evEl","Ta","evWin","Ua","pressed","Xa","Ya","store","pointerEvents","N","evTarget","$a","_a","started","O","touches","changedTouches","concat","bb","targetIds","Q","Fa","identifier","filter","touch","mouse","primaryTouch","lastTouches","S","T","splice","cb","U","abs","db","V","set","W","jb","kb","lb","ib","hb","X","fb","CSS","supports","Y","defaults","state","nb","simultaneous","requireFail","Z","sb","qb","pb","ob","$","_","get","aa","ba","pX","pY","ca","da","_timer","_input","ea","fa","ga","pTime","pCenter","count","ha","recognizers","preset","ia","handlers","oldCssProps","input","touchAction","ja","add","recognizeWith","requireFailure","cssProps","ka","createEvent","initEvent","gesture","dispatchEvent","na","round","Date","now","assign","TypeError","sa","keys","ta","va","za","Aa","Ba","Ca","Na","Oa","Pa","destroy","Sa","mousedown","mousemove","mouseup","type","button","which","pointerType","Va","pointerdown","pointermove","pointerup","pointercancel","pointerout","Wa","3","4","MSPointerEvent","PointerEvent","toLowerCase","pointerId","Za","touchstart","touchmove","touchend","touchcancel","ab","sourceCapabilities","firesTouchEvents","eb","gb","mb","compute","actions","update","getTouchAction","join","preventDefaults","prevented","preventDefault","preventSrc","rb","tb","dropRecognizeWith","dropRequireFailure","hasRequireFailures","canRecognizeWith","event","additionalEvent","tryEmit","canEmit","process","reset","attrTest","threshold","directionTest","time","clearTimeout","taps","interval","posThreshold","failTimeout","tapCount","VERSION","domEvents","userSelect","touchSelect","touchCallout","contentZooming","userDrag","tapHighlightColor","ub","vb","stop","stopped","curRecognizer","remove","on","off","INPUT_START","INPUT_MOVE","INPUT_END","INPUT_CANCEL","STATE_POSSIBLE","STATE_BEGAN","STATE_CHANGED","STATE_ENDED","STATE_RECOGNIZED","STATE_CANCELLED","STATE_FAILED","DIRECTION_NONE","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","DIRECTION_ALL","Manager","Input","TouchAction","TouchInput","MouseInput","PointerEventInput","TouchMouseInput","SingleTouchInput","Recognizer","AttrRecognizer","Tap","Pan","Swipe","Pinch","Rotate","Press","each","merge","extend","inherit","bindFn","prefixed","wb","self","Hammer","undefined","8","global","factory","obj","key","val","hasOwn","_isVue","_data","__ob__","convert","dep","notify","vms","vm","_proxy","_digest","del","_unproxy","isLiteral","exp","literalValueRE","isReserved","charCodeAt","_toString","value","toString","toNumber","parsed","Number","isNaN","toBoolean","stripQuotes","camelize","camelizeRE","toUpper","hyphenate","hyphenateRE","classify","classifyRE","bind","fn","ctx","toArray","list","start","ret","to","from","isObject","isPlainObject","OBJECT_STRING","def","enumerable","defineProperty","writable","configurable","_debounce","func","wait","timeout","args","context","timestamp","result","later","last","arr","cancellable","cancelled","cancel","looseEqual","JSON","stringify","Cache","limit","size","head","tail","_keymap","pushFilter","lastFilterIndex","tokens","filterTokenRE","map","processFilterArg","dir","filters","arg","reservedArgRE","dynamic","stripped","parseDirective","hit","cache$1","inSingle","inDouble","curly","square","paren","prev","expression","put","escapeRegex","regexEscapeRE","compileRegex","open","config","delimiters","close","unsafeOpen","unsafeDelimiters","unsafeClose","tagRE","htmlRE","cache","parseText","text","index","html","first","oneTime","lastIndex","exec","tag","tokensToExp","token","formatToken","single","$eval","inlineFilters","filterRE","appendWithTransition","el","applyTransition","beforeWithTransition","before","removeWithTransition","op","transition","__v_trans","hooks","transitionEndEvent","_isCompiled","$parent","action","query","selector","querySelector","inDoc","node","doc","documentElement","parent","nodeType","contains","getAttr","_attr","getAttribute","removeAttribute","getBindAttr","hasBindAttr","hasAttribute","insertBefore","after","nextSibling","prepend","firstChild","replaceChild","useCapture","getClass","classname","className","baseVal","setClass","cls","isIE9","namespaceURI","setAttribute","addClass","classList","cur","removeClass","tar","extractContent","asFragment","child","rawContent","isTemplate","isFragment","content","hasChildNodes","trimNode","createDocumentFragment","isTrimmable","lastChild","tagName","createAnchor","persist","anchor","debug","createComment","createTextNode","__v_anchor","findRef","hasAttributes","attrs","attributes","refRE","mapNodeRange","end","next","removeNodeRange","frag","onRemoved","removed","done","nodes","getOuterHTML","outerHTML","container","cloneNode","checkComponentAttr","hasAttrs","commonTagRE","reservedTagRE","getIsBinding","resolveAsset","is","expectedTag","_componentNameMap","isUnknownElement","mergeData","toVal","fromVal","mergeAssets","parentVal","childVal","res","guardArrayAssets","guardComponents","components","ids","Vue","guardProps","props","assets","asset","mergeOptions","mergeField","strat","strats","defaultStrat","propsData","mixins","mixin","mixinOptions","warnMissing","camelizedId","charAt","Dep","uid$1","subs","withoutConversion","shouldConvert","Observer","augment","hasProto","protoAugment","copyAugment","arrayMethods","arrayKeys","observeArray","walk","src","__proto__","observe","isExtensible","addVm","defineReactive","property","getOwnPropertyDescriptor","getter","setter","childOb","depend","newVal","initMixin","_init","$el","$root","$children","$refs","$els","_watchers","_directives","_uid","uid","_events","_eventsCount","_isFragment","_fragment","_fragmentStart","_fragmentEnd","_isDestroyed","_isReady","_isAttached","_isBeingDestroyed","_vForRemoving","_unlinkFn","_context","_scope","_frag","children","$options","_updateRef","_callHook","_initState","_initEvents","$mount","getPathCharType","ch","code","formatSubPath","path","trimmed","parse","maybeUnescapeQuote","nextChar","mode","IN_SINGLE_QUOTE","IN_DOUBLE_QUOTE","newChar","APPEND","typeMap","BEFORE_PATH","subPathDepth","PUSH","INC_SUB_PATH_DEPTH","PUSH_SUB_PATH","IN_SUB_PATH","pathStateMachine","ERROR","AFTER_PATH","raw","parsePath","pathCache","getPath","parseExpression","setPath","original","warnNonExistent","$set","noop","save","isString","saved","newlineRE","rewrite","allowedKeywordsRE","restoreRE","restore","compileGetter","improperKeywordsRE","saveRE","wsRE","identRE","makeGetterFn","Function","compileSetter","scope","needSet","expressionCache","isSimplePath","pathTestRE","literalValueRE$1","resetBatcherState","queue","userQueue","has","circular","waiting","flushBatcherQueue","_again","runBatcherQueue","devtools","watcher","run","_maxUpdateCount","pushWatcher","user","nextTick","Watcher","expOrFn","isFn","uid$2","active","dirty","lazy","deps","newDeps","depIds","_Set","newDepIds","prevError","twoWay","queued","shallow","traverse","seen","seenObjects","clear","isA","isO","depId","isRealTemplate","stringToFragment","templateString","cacheKey","templateCache","tagMatch","tagRE$1","entityMatch","entityRE","commentMatch","commentRE","wrap","efault","depth","prefix","suffix","nodeToFragment","textContent","clonedNode","querySelectorAll","cloned","hasBrokenTemplate","tempClone","hasTextareaCloneBug","parseTemplate","template","shouldClone","idSelectorCache","Fragment","linker","host","parentFrag","childFrags","inserted","unlink","childNodes","singleBefore","singleRemove","multiBefore","multiRemove","__v_frag","withTransition","method","callHook","attach","shouldCallRemove","beforeRemove","detach","FragmentFactory","cid","cacheId","linkerCache","compile","findPrevFrag","previousSibling","forId","findVmFromFrag","__vue__","range","floor","getTrackByKey","trackByKey","getValue","multi","selected","_value","indexOf$1","keyFilter","codes","charCode","parseInt","keyCodes","keyCode","stopFilter","stopPropagation","preventFilter","selfFilter","currentTarget","normalize","prop","propCache","camel","upper","testEl","prefixes","kebab","camelPrefixes","normalize$1","_key","callActivateHooks","called","total","compileProps","propOptions","attr","names","empty","identRE$1","propBindingModes","ONE_WAY","TWO_WAY","ONE_TIME","optimizedLiteral","settablePathRE","parentPath","lowerCaseName","required","makePropsLinkFn","_props","inlineProps","initProp","$get","_bindDir","propDef","Boolean","processPropValue","rawValue","isSimple","getPropDefaultValue","coerceProp","coerced","assertProp","updateProp","valid","expectedTypes","assertedType","assertType","expectedType","formatType","formatValue","validator","coerce","String","pushJob","job","queue$1","flush","offsetHeight","Transition","enterClass","leaveClass","pendingCssEvent","pendingCssCb","pendingJsCb","justEntered","entered","left","typeCache","TYPE_TRANSITION","TYPE_ANIMATION","isHidden","rect","getBoundingClientRect","width","height","offsetWidth","getClientRects","partial","nodeLinkFn","_asComponent","compileNode","childLinkFn","terminal","isScript","compileNodeList","dirs","linkAndCapture","makeUnlinkFn","originalDirCount","directiveComparator","_bind","descriptor","priority","DEFAULT_PRIORITY","contextDirs","destroying","teardownDirs","_teardown","$remove","compileAndLinkProps","propsLinkFn","propDirs","compileRoot","contextOptions","contextLinkFn","replacerLinkFn","containerAttrs","_containerAttrs","replacerAttrs","_replacerAttrs","compileDirectives","onRE","plural","selfDirs","compileTextNode","compileElement","linkFn","checkTerminalDirectives","checkElementDirectives","checkComponent","_skip","removeText","wholeText","processTextToken","makeTextNodeLinkFn","setTokenType","directives","fragClone","nodeList","linkFns","makeChildLinkFn","childrenLinkFn","makeTerminalNodeLinkFn","component","ref","internalDirectives","modifiers","literal","componentLinkFn","skip","previousElementSibling","matched","dirName","rawName","termDef","modifierRE","dirAttrRE","DEFAULT_TERMINAL_PRIORITY","parseModifiers","pushDir","interpTokens","hasOneTimeToken","hasOneTime","interp","dirDef","some","transitionRE","bindRE","makeNodeLinkFn","transclude","extractAttrs","_content","transcludeTemplate","replacer","mergeAttrs","specialCharRE","resolveSlots","contents","_slotContents","extractFragment","stateMixin","makeComputedGetter","owner","evaluate","newData","_setData","_initProps","_initMeta","_initMethods","_initData","_initComputed","_propsUnlinkFn","dataFn","oldData","removeVm","computed","userDef","methods","metas","_meta","eventsMixin","registerComponentEvents","eventRE","_fromParent","$on","registerCallbacks","hash","register","onAttached","callAttach","onDetached","callDetach","events","watch","_initDOMHooks","hook","$emit","noop$1","Directive","_locked","_bound","_listeners","_host","_vue_directives","lifecycleMixin","_ref","refs","_compile","_initElement","rootLinker","contentLinkFn","ctor","_linkerCachable","rootUnlinkFn","contentUnlinkFn","_destroy","deferCleanup","_cleanup","destroyReady","pendingRemoval","cleanupIfPossible","$destroy","teardown","$off","miscMixin","_applyFilters","oldValue","write","offset","read","_resolveComponent","resolved","requested","pendingCallbacks","cbs","reason","dataAPI","clean","asStatement","$arguments","$delete","$watch","deep","sync","immediate","filterRE$1","$interpolate","$log","domAPI","insert","op1","op2","targetIsDetached","shouldCallHook","append","beforeWithCb","removeWithCb","$nextTick","$appendTo","$prependTo","$before","$after","inDocument","realCb","eventsAPI","modifyListenerCount","hookRE","$once","isSource","shouldPropagate","hasParentCbs","$broadcast","source","$dispatch","lifecycleAPI","ready","$compile","limitBy","filterBy","delimiter","convertArray","item","$value","$key","orderBy","baseCompare","sortKeyIndex","sortKey","sortKeys","order","comparator","firstArg","installGlobalAPI","createClass","elementDirectives","transitions","partials","util","compiler","parsers","directive","extendOptions","Super","isFirstExtend","_Ctor","Sub","_assetTypes","use","plugin","installed","unshift","install","definition","inBrowser","__VUE_DEVTOOLS_GLOBAL_HOOK__","UA","isIE","isIos","iosVersionMatch","iosVersion","hasMutationObserverBug","indexedDB","transitionProp","animationProp","animationEndEvent","isWebkitTrans","ontransitionend","onwebkittransitionend","isWebkitAnim","onanimationend","onwebkitanimationend","nextTickHandler","pending","copies","callbacks","timerFunc","MutationObserver","setImmediate","counter","observer","textNode","characterData","Set","entry","shift","newer","older","returnEntry","freeze","defineProperties","silent","async","warnExpressionErrors","_delimitersChanged","_propBindingModes","formatComponentName","hasConsole","msg","error","HTMLUnknownElement","HTMLElement","optionMergeStrategies","instanceData","defaultData","created","attached","detached","beforeCompile","compiled","beforeDestroy","destroyed","activate","addSub","sub","removeSub","addDep","arrayProto","getOwnPropertyNames","items","debounce","IN_PATH","BEFORE_IDENT","IN_IDENT","ws","ident","[","eof",".","number","'","\"","]","else","allowedKeywords","improperKeywords","beforeGet","preProcess","postProcess","afterGet","forContext","$forContext","alias","_withLock","$index","tmp","current","text$1","legend","tr","col","td","th","option","optgroup","thead","tbody","colgroup","caption","tfoot","defs","symbol","image","circle","ellipse","line","polygon","polyline","placeholder","swap","_watcher","ON","MODEL","BIND","TRANSITION","EL","COMPONENT","PARTIAL","IF","FOR","SLOT","uid$3","vFor","params","inMatch","itMatch","iterator","isOption","diff","updateRef","updateModel","primitive","convertedFromObject","fromObject","trackBy","oldFrags","frags","getCachedFrag","reused","fresh","removalIndex","totalRemoved","deleteCachedFrag","targetPrev","prevEl","currentPrev","insertionIndex","staggerCb","staggerAnchor","move","parentScope","cacheFrag","model","__v_model","forceUpdate","staggerAmount","getStagger","warnDuplicate","trans","stagger","_preProcess","_postProcess","unbind","vIf","invalid","nextElementSibling","elseEl","elseFrag","elseFactory","toggle","display","text$2","isRange","composing","listener","focused","rawListener","hasjQuery","jQuery","afterBind","radio","checked","select","_this","multiple","initValue","selectedIndex","checkbox","getBooleanValue","_trueValue","_falseValue","checkFilters","hasRead","hasWrite","_unbind","esc","tab","enter","space","delete","up","right","down","on$1","acceptStatement","iframeBind","contentWindow","capture","prevent","importantRE","cssText","handleObject","reduce","handleSingle","isImportant","setProperty","xlinkNS","xlinkRE","disallowedInterpAttrRE","attrWithPropsRE","enumeratedAttrRE","modelProps","true-value","false-value","bind$1","attrValue","modelProp","setAttributeNS","cloak","for","if","vClass","cleanup","prevKeys","keepAlive","inlineTemplate","pendingComponentCb","Component","pendingRemovals","pendingRemovalCb","setComponent","invalidatePending","resolveComponent","mountComponent","unbuild","childVM","ComponentName","activateHooks","cached","getCached","newComponent","build","waitingFor","extraOptions","_isRouterView","defer","_inactive","transitionMode","bindingModes","childKey","parentKey","parentWatcher","childWatcher","transDurationProp","animDurationProp","raf","requestAnimationFrame","waitForTransitionStart","p$1","cancelPending","callHookWithCb","enterCancelled","enterNextTick","enterDone","getCssTransitionType","setupCssCb","leave","leaveCancelled","leaveDone","leaveNextTick","hasPending","hidden","css","inlineStyles","computedStyles","getComputedStyle","transDuration","animDuration","onEnd","transition$1","oldId","class","_setupParams","_checkStatement","_update","oldVal","mappedKey","_setupParamWatcher","unwatch","paramWatchers","_paramUnwatchFns","$event","listeners","unwatchFns","slot","fallback","elseBlock","digitsRE","json","indent","capitalize","uppercase","lowercase","currency","_currency","decimals","parseFloat","isFinite","stringified","toFixed","_int","_float","sign","pluralize","delay","version","12","Promise$2","executor","PENDING","deferred","promise","resolve","reject","Promise$1","PromiseObj","Util","isBoolean","isFunction","getPrototypeOf","isFormData","FormData","when","fulfilled","rejected","then","opts","$vm","array","_merge","_assign","root","urlParams","Url","expand","variables","tmpl","expanded","vars","operators","operator","values","variable","getValues","separator","encodeReserved","modifier","isDefined","substring","encodeValue","isKeyOperator","encodeURIComponent","part","encodeURI","transform","transforms","serialize","plain","xdrClient","request","xdr","XDomainRequest","response","respondWith","responseText","status","statusText","abort","getUrl","onload","onerror","ontimeout","onprogress","send","getBody","cors","crossOrigin","SUPPORTS_CORS","client","emulateHTTP","requestUrl","protocol","ORIGIN_URL","emulateJSON","headers","contentType","jsonpClient","jsonp","random","header","Http","common","custom","xhrClient","xhr","XMLHttpRequest","parseHeaders","getAllResponseHeaders","progress","upload","credentials","withCredentials","setRequestHeader","row","Client","reqHandlers","pop","resHandlers","sendRequest","interceptors","Request","ok","Resource","resource","$http","http","Promise","$url","$resource","$promise","RESOLVED","REJECTED","all","iterable","resolver","race","onResolved","onRejected","ie","documentMode","escape","port","hostname","pathname","classCallCheck","instance","Constructor","Response","blob","Blob","CUSTOM_HEADERS","X-Requested-With","COMMON_HEADERS","Accept","JSON_CONTENT_TYPE","Content-Type","post","patch","13","matcher","delegate","routes","decodeURIComponent","decodeURI","string","charSpec","nextStates","specificity","queryParams","regex","isDynamic","eachChar","route","expectBoolean","aborted","callHooks","activateQueue","activated","$loadingRouteData","_routerView","_keepAliveRouterView","childView","router","_rendered","_transitionOnLoad","setCurrent","postActivate","processData","_parent","$router","$route","_children","_defineMeta","_isDynamicLiteral","parentView","_rootView","_currentTransition","elementDirective","activeIds","updateClasses","onRouteUpdate","onClick","exact","prevActiveClass","activeClass","metaKey","ctrlKey","shiftKey","defaultPrevented","go","history","rootRE","stringifyPath","updateActiveMatch","updateHref","activeRE","at","ot","formatPath","_linkActiveClass","it","ht","willAddRoute","addChild","contextEntered","validChars","generate","invalidChars","repeat","rootState","as","segments","handlersFor","hasRoute","generateQueryString","parseQueryString","onChange","base","replaceState","pos","pageXOffset","pageYOffset","pushState","hashbang","tt","currentPath","et","redirect","reverse","runQueue","_onTransitionValidated","_suppress","nt","rt","ut","_recognizer","_notFoundHandler","st","abstract","html5","ct","saveScrollPosition","transitionOnLoad","suppressTransitionError","linkActiveClass","app","_guardRecognizer","_started","_startCb","_currentRoute","_previousTransition","_notFoundRedirect","_beforeEachHooks","_afterEachHooks","_root","_abstract","_hashbang","_history","_historyFallback","_match","_saveScrollPosition","_notFound","_addRoute","_addRedirect","_addAlias","beforeEach","afterEach","_appContainer","_appConstructor","fullPath","subRoutes","_addGuard","_checkGuard","_prevTransition","_postTransition","scrollTo","scrollX","offsetTop","14","hammer","mc","hammerOptions","recognizer","registerCustomEvent","15","vuex","$store","getters","_getterCacheId","_vm","_lifecycleHooks","beforeCreate","Symbol","onInit","_dispatching","onMutation","mutations","modules","middlewares","strict","_rootMutations","_mutations","_modules","dispatch","_setupModuleState","_setupModuleMutations","_setupMiddlewares","_setupMutationCheck","payload","_applyMiddlewares","_middlewares","_needSnapshots","snapshot","_prevSnapshot","Store","16","_interopRequireDefault","__esModule","default","_store","_store2","_webviewtestShare","_webviewtestShare2","_shareInfo","_shareInfo2","showDialog","SSS","hideDialog","ymMoney","ymMoneyAdr","ymMoneyIph","27","42","53","infiniteScroll","throttle","lastExec","timer","execute","getScrollTop","max","scrollTop","getScrollEventTarget","currentNode","overflowY","getVisibleHeight","clientHeight","getElementTop","top","isAttached","doBind","binded","scrollEventTarget","scrollListener","doCheck","disabledExpr","disabled","immediateCheck","distanceExpr","immediateCheckExpr","eventName","force","viewportScrollTop","viewportBottom","shouldTrigger","scrollHeight","elementBottom","bindTryCount","tryBind","54","__vue_script__","__vue_template__","69","VueRouter","VueResource","VueTouch","/home","__WEBPACK_AMD_REQUIRE_ARRAY__","/myshop","/mysign","/goodDetail","/orderDetail","/infoSure","/saveAddr","/playRule","*","isGoodDetail","70","Vuex","userInfo","goodsInfo","address","GETINFO","SETGOODINFO","GETUID","SETADDRESS"],"mappings":"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","file":"build.js","sourcesContent":["webpackJsonp([9,8],{\n\n/***/ 0:\n/*!******************!*\\\n  !*** multi main ***!\n  \\******************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(/*! D:\\myapp\\ymshop\\src\\main.js */69);\n\n\n/***/ },\n\n/***/ 2:\n/*!************************************!*\\\n  !*** ./src/js/webviewtestShare.js ***!\n  \\************************************/\n/***/ function(module, exports) {\n\n\tmodule.exports = {\r\n\t\t say:function(){\r\n\t\t \talert(1)\r\n\t\t },\r\n\t\t test:function(show){\r\n\t\r\n\t          var u = navigator.userAgent;\r\n\t          var isAndroid = u.indexOf('Android') > -1 || u.indexOf('Linux') > -1;\r\n\t          var isIOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/);//ios\r\n\t          //01\r\n\t          var isHide =   show===0;\r\n\t\r\n\t          if (isAndroid) {\r\n\t            if (window.WebViewJavascriptBridge) {\r\n\t              window.WebViewJavascriptBridge.callHandler(\r\n\t                'hideShareBtn',\r\n\t                {'isHide':isHide},\r\n\t                function (responseData) {\r\n\t                 console.log(responseData)\r\n\t\r\n\t                }\r\n\t              )\r\n\t            } else {\r\n\t              document.addEventListener(\r\n\t                'WebViewJavascriptBridgeReady'\r\n\t                , function () {\r\n\t                  window.WebViewJavascriptBridge.callHandler(\r\n\t                     'hideShareBtn',\r\n\t                     {'isHide':isHide},\r\n\t                    function (responseData) {\r\n\t                      console.log(responseData)\r\n\t \r\n\t                    }\r\n\t                  )\r\n\t                },\r\n\t                false\r\n\t              )\r\n\t            }\r\n\t          } else if(isIOS) {\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t                   // script\r\n\t                var hasBuildScript=document.getElementById('IOS_shareBtn')\r\n\t\r\n\t                if (hasBuildScript) {\r\n\t                    document.body.removeChild(hasBuildScript)\r\n\t                    var script = document.createElement('script');\r\n\t                        script.id = 'IOS_shareBtn';\r\n\t                        script.innerHTML='try{window.webkit.messageHandlers.hideShareBtnOC.postMessage({isHide: '+isHide+'});}catch(e){}'\r\n\t\r\n\t                    document.body.appendChild(script)\r\n\t                }else{\r\n\t\r\n\t                   var script = document.createElement('script');\r\n\t                       script.id = 'IOS_shareBtn';\r\n\t                       script.innerHTML='try{window.webkit.messageHandlers.hideShareBtnOC.postMessage({isHide: '+isHide+'});}catch(e){}'\r\n\t\r\n\t                   document.body.appendChild(script)\r\n\t                }\r\n\t\r\n\t           \r\n\t           \r\n\t\r\n\t\r\n\t           \r\n\t\r\n\t          \r\n\t            \r\n\t\r\n\t          } else {\r\n\t\r\n\t\r\n\t\r\n\t          \tconsole.log('pc')\r\n\t          }\r\n\t\r\n\t    }\r\n\t}\n\n/***/ },\n\n/***/ 5:\n/*!*****************************!*\\\n  !*** ./src/js/shareInfo.js ***!\n  \\*****************************/\n/***/ function(module, exports) {\n\n\tmodule.exports = {\r\n\t  say:function(){\r\n\t    \r\n\t    document.body.style.background=\"#000\"\r\n\t  },\r\n\t\tshare:function(){\r\n\t\t\tvar u = navigator.userAgent;\r\n\t        var isAndroid = u.indexOf('Android') > -1 || u.indexOf('Linux') > -1;\r\n\t        var isIOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/);\r\n\t\r\n\t\r\n\t        var GetQueryString = function (name) {\r\n\t        var reg = new RegExp(\"(^|&)\" + name + \"=([^&]*)(&|$)\", \"i\");\r\n\t        var r = window.location.search.substr(1).match(reg);\r\n\t        if (r != null) return (r[2]);\r\n\t        return null;\r\n\t        };\r\n\t\r\n\t        if (isAndroid) {\r\n\t\r\n\t\r\n\t           function connectWebViewJavascriptBridge(callback) {\r\n\t            if (window.WebViewJavascriptBridge) {\r\n\t                callback(WebViewJavascriptBridge)\r\n\t            } else {\r\n\t                document.addEventListener(\r\n\t                    'WebViewJavascriptBridgeReady'\r\n\t                    , function() {\r\n\t                        callback(WebViewJavascriptBridge)\r\n\t                    },\r\n\t                    false\r\n\t                );\r\n\t            }\r\n\t        }\r\n\t\r\n\t        connectWebViewJavascriptBridge(function(bridge) {\r\n\t\r\n\t             bridge.init(function(message, responseCallback) {\r\n\t\r\n\t                responseCallback(data);\r\n\t            });\r\n\t\r\n\t            bridge.registerHandler(\"getShareInfo\", function(data, responseCallback) {\r\n\t                var url = window.location.href \r\n\t                var repStr = GetQueryString('uid')\r\n\t                var str = url.replace(repStr,'')    \r\n\t                var responseData = {\r\n\t                  'title':'',\r\n\t                  'brief':'~',\r\n\t                  'shareUrl':str\r\n\t                };\r\n\t                responseCallback(responseData);\r\n\t            });\r\n\t        })\r\n\t        }else if (isIOS){\r\n\t     \r\n\t            // script\r\n\t            \r\n\t                var url = window.location.href;\r\n\t                var repStr = GetQueryString('uid')\r\n\t                var str = url.replace(repStr,'')    \r\n\t                var responseData = {\r\n\t                  title:'',\r\n\t                  brief:'~',\r\n\t                  shareUrl:str\r\n\t                };\r\n\t\r\n\t            var hasBuildScript=document.getElementById('IOS_shareInfo')\r\n\t\r\n\t\r\n\t\r\n\t                 if (hasBuildScript) {\r\n\t\r\n\t                    document.body.removeChild(hasBuildScript)\r\n\t                    var script = document.createElement('script');\r\n\t                        script.id = 'IOS_shareInfo';\r\n\t                        script.innerHTML='try{window.webkit.messageHandlers.getShareInfoOC.postMessage({title:\"'+responseData.title+'\",brief:\"'+responseData.brief+'\",shareUrl:\"'+responseData.shareUrl+'\"});}catch(e){}'\r\n\t\r\n\t                        document.body.appendChild(script)\r\n\t                    }else{\r\n\t\r\n\t                       var script = document.createElement('script');\r\n\t                           script.id = 'IOS_shareInfo';\r\n\t                           script.innerHTML='try{window.webkit.messageHandlers.getShareInfoOC.postMessage({title:\"'+responseData.title+'\",brief:\"'+responseData.brief+'\",shareUrl:\"'+responseData.shareUrl+'\"});}catch(e){}'\r\n\t\r\n\t                       document.body.appendChild(script)\r\n\t                    }\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t        } else {\r\n\t        \tconsole.log('pc')\r\n\t        }\r\n\t\t}\r\n\t\r\n\t}\n\n/***/ },\n\n/***/ 7:\n/*!************************************!*\\\n  !*** ./lib/hammerjs/hammer.min.js ***!\n  \\************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22\r\n\t * http://hammerjs.github.io/\r\n\t *\r\n\t * Copyright (c) 2016 Jorik Tangelder;\r\n\t * Licensed under the MIT license */\r\n\t!function(a,b,c,d){\"use strict\";function e(a,b,c){return setTimeout(j(a,c),b)}function f(a,b,c){return Array.isArray(a)?(g(a,c[b],c),!0):!1}function g(a,b,c){var e;if(a)if(a.forEach)a.forEach(b,c);else if(a.length!==d)for(e=0;e<a.length;)b.call(c,a[e],e,a),e++;else for(e in a)a.hasOwnProperty(e)&&b.call(c,a[e],e,a)}function h(b,c,d){var e=\"DEPRECATED METHOD: \"+c+\"\\n\"+d+\" AT \\n\";return function(){var c=new Error(\"get-stack-trace\"),d=c&&c.stack?c.stack.replace(/^[^\\(]+?[\\n$]/gm,\"\").replace(/^\\s+at\\s+/gm,\"\").replace(/^Object.<anonymous>\\s*\\(/gm,\"{anonymous}()@\"):\"Unknown Stack Trace\",f=a.console&&(a.console.warn||a.console.log);return f&&f.call(a.console,e,d),b.apply(this,arguments)}}function i(a,b,c){var d,e=b.prototype;d=a.prototype=Object.create(e),d.constructor=a,d._super=e,c&&la(d,c)}function j(a,b){return function(){return a.apply(b,arguments)}}function k(a,b){return typeof a==oa?a.apply(b?b[0]||d:d,b):a}function l(a,b){return a===d?b:a}function m(a,b,c){g(q(b),function(b){a.addEventListener(b,c,!1)})}function n(a,b,c){g(q(b),function(b){a.removeEventListener(b,c,!1)})}function o(a,b){for(;a;){if(a==b)return!0;a=a.parentNode}return!1}function p(a,b){return a.indexOf(b)>-1}function q(a){return a.trim().split(/\\s+/g)}function r(a,b,c){if(a.indexOf&&!c)return a.indexOf(b);for(var d=0;d<a.length;){if(c&&a[d][c]==b||!c&&a[d]===b)return d;d++}return-1}function s(a){return Array.prototype.slice.call(a,0)}function t(a,b,c){for(var d=[],e=[],f=0;f<a.length;){var g=b?a[f][b]:a[f];r(e,g)<0&&d.push(a[f]),e[f]=g,f++}return c&&(d=b?d.sort(function(a,c){return a[b]>c[b]}):d.sort()),d}function u(a,b){for(var c,e,f=b[0].toUpperCase()+b.slice(1),g=0;g<ma.length;){if(c=ma[g],e=c?c+f:b,e in a)return e;g++}return d}function v(){return ua++}function w(b){var c=b.ownerDocument||b;return c.defaultView||c.parentWindow||a}function x(a,b){var c=this;this.manager=a,this.callback=b,this.element=a.element,this.target=a.options.inputTarget,this.domHandler=function(b){k(a.options.enable,[a])&&c.handler(b)},this.init()}function y(a){var b,c=a.options.inputClass;return new(b=c?c:xa?M:ya?P:wa?R:L)(a,z)}function z(a,b,c){var d=c.pointers.length,e=c.changedPointers.length,f=b&Ea&&d-e===0,g=b&(Ga|Ha)&&d-e===0;c.isFirst=!!f,c.isFinal=!!g,f&&(a.session={}),c.eventType=b,A(a,c),a.emit(\"hammer.input\",c),a.recognize(c),a.session.prevInput=c}function A(a,b){var c=a.session,d=b.pointers,e=d.length;c.firstInput||(c.firstInput=D(b)),e>1&&!c.firstMultiple?c.firstMultiple=D(b):1===e&&(c.firstMultiple=!1);var f=c.firstInput,g=c.firstMultiple,h=g?g.center:f.center,i=b.center=E(d);b.timeStamp=ra(),b.deltaTime=b.timeStamp-f.timeStamp,b.angle=I(h,i),b.distance=H(h,i),B(c,b),b.offsetDirection=G(b.deltaX,b.deltaY);var j=F(b.deltaTime,b.deltaX,b.deltaY);b.overallVelocityX=j.x,b.overallVelocityY=j.y,b.overallVelocity=qa(j.x)>qa(j.y)?j.x:j.y,b.scale=g?K(g.pointers,d):1,b.rotation=g?J(g.pointers,d):0,b.maxPointers=c.prevInput?b.pointers.length>c.prevInput.maxPointers?b.pointers.length:c.prevInput.maxPointers:b.pointers.length,C(c,b);var k=a.element;o(b.srcEvent.target,k)&&(k=b.srcEvent.target),b.target=k}function B(a,b){var c=b.center,d=a.offsetDelta||{},e=a.prevDelta||{},f=a.prevInput||{};b.eventType!==Ea&&f.eventType!==Ga||(e=a.prevDelta={x:f.deltaX||0,y:f.deltaY||0},d=a.offsetDelta={x:c.x,y:c.y}),b.deltaX=e.x+(c.x-d.x),b.deltaY=e.y+(c.y-d.y)}function C(a,b){var c,e,f,g,h=a.lastInterval||b,i=b.timeStamp-h.timeStamp;if(b.eventType!=Ha&&(i>Da||h.velocity===d)){var j=b.deltaX-h.deltaX,k=b.deltaY-h.deltaY,l=F(i,j,k);e=l.x,f=l.y,c=qa(l.x)>qa(l.y)?l.x:l.y,g=G(j,k),a.lastInterval=b}else c=h.velocity,e=h.velocityX,f=h.velocityY,g=h.direction;b.velocity=c,b.velocityX=e,b.velocityY=f,b.direction=g}function D(a){for(var b=[],c=0;c<a.pointers.length;)b[c]={clientX:pa(a.pointers[c].clientX),clientY:pa(a.pointers[c].clientY)},c++;return{timeStamp:ra(),pointers:b,center:E(b),deltaX:a.deltaX,deltaY:a.deltaY}}function E(a){var b=a.length;if(1===b)return{x:pa(a[0].clientX),y:pa(a[0].clientY)};for(var c=0,d=0,e=0;b>e;)c+=a[e].clientX,d+=a[e].clientY,e++;return{x:pa(c/b),y:pa(d/b)}}function F(a,b,c){return{x:b/a||0,y:c/a||0}}function G(a,b){return a===b?Ia:qa(a)>=qa(b)?0>a?Ja:Ka:0>b?La:Ma}function H(a,b,c){c||(c=Qa);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return Math.sqrt(d*d+e*e)}function I(a,b,c){c||(c=Qa);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return 180*Math.atan2(e,d)/Math.PI}function J(a,b){return I(b[1],b[0],Ra)+I(a[1],a[0],Ra)}function K(a,b){return H(b[0],b[1],Ra)/H(a[0],a[1],Ra)}function L(){this.evEl=Ta,this.evWin=Ua,this.pressed=!1,x.apply(this,arguments)}function M(){this.evEl=Xa,this.evWin=Ya,x.apply(this,arguments),this.store=this.manager.session.pointerEvents=[]}function N(){this.evTarget=$a,this.evWin=_a,this.started=!1,x.apply(this,arguments)}function O(a,b){var c=s(a.touches),d=s(a.changedTouches);return b&(Ga|Ha)&&(c=t(c.concat(d),\"identifier\",!0)),[c,d]}function P(){this.evTarget=bb,this.targetIds={},x.apply(this,arguments)}function Q(a,b){var c=s(a.touches),d=this.targetIds;if(b&(Ea|Fa)&&1===c.length)return d[c[0].identifier]=!0,[c,c];var e,f,g=s(a.changedTouches),h=[],i=this.target;if(f=c.filter(function(a){return o(a.target,i)}),b===Ea)for(e=0;e<f.length;)d[f[e].identifier]=!0,e++;for(e=0;e<g.length;)d[g[e].identifier]&&h.push(g[e]),b&(Ga|Ha)&&delete d[g[e].identifier],e++;return h.length?[t(f.concat(h),\"identifier\",!0),h]:void 0}function R(){x.apply(this,arguments);var a=j(this.handler,this);this.touch=new P(this.manager,a),this.mouse=new L(this.manager,a),this.primaryTouch=null,this.lastTouches=[]}function S(a,b){a&Ea?(this.primaryTouch=b.changedPointers[0].identifier,T.call(this,b)):a&(Ga|Ha)&&T.call(this,b)}function T(a){var b=a.changedPointers[0];if(b.identifier===this.primaryTouch){var c={x:b.clientX,y:b.clientY};this.lastTouches.push(c);var d=this.lastTouches,e=function(){var a=d.indexOf(c);a>-1&&d.splice(a,1)};setTimeout(e,cb)}}function U(a){for(var b=a.srcEvent.clientX,c=a.srcEvent.clientY,d=0;d<this.lastTouches.length;d++){var e=this.lastTouches[d],f=Math.abs(b-e.x),g=Math.abs(c-e.y);if(db>=f&&db>=g)return!0}return!1}function V(a,b){this.manager=a,this.set(b)}function W(a){if(p(a,jb))return jb;var b=p(a,kb),c=p(a,lb);return b&&c?jb:b||c?b?kb:lb:p(a,ib)?ib:hb}function X(){if(!fb)return!1;var b={},c=a.CSS&&a.CSS.supports;return[\"auto\",\"manipulation\",\"pan-y\",\"pan-x\",\"pan-x pan-y\",\"none\"].forEach(function(d){b[d]=c?a.CSS.supports(\"touch-action\",d):!0}),b}function Y(a){this.options=la({},this.defaults,a||{}),this.id=v(),this.manager=null,this.options.enable=l(this.options.enable,!0),this.state=nb,this.simultaneous={},this.requireFail=[]}function Z(a){return a&sb?\"cancel\":a&qb?\"end\":a&pb?\"move\":a&ob?\"start\":\"\"}function $(a){return a==Ma?\"down\":a==La?\"up\":a==Ja?\"left\":a==Ka?\"right\":\"\"}function _(a,b){var c=b.manager;return c?c.get(a):a}function aa(){Y.apply(this,arguments)}function ba(){aa.apply(this,arguments),this.pX=null,this.pY=null}function ca(){aa.apply(this,arguments)}function da(){Y.apply(this,arguments),this._timer=null,this._input=null}function ea(){aa.apply(this,arguments)}function fa(){aa.apply(this,arguments)}function ga(){Y.apply(this,arguments),this.pTime=!1,this.pCenter=!1,this._timer=null,this._input=null,this.count=0}function ha(a,b){return b=b||{},b.recognizers=l(b.recognizers,ha.defaults.preset),new ia(a,b)}function ia(a,b){this.options=la({},ha.defaults,b||{}),this.options.inputTarget=this.options.inputTarget||a,this.handlers={},this.session={},this.recognizers=[],this.oldCssProps={},this.element=a,this.input=y(this),this.touchAction=new V(this,this.options.touchAction),ja(this,!0),g(this.options.recognizers,function(a){var b=this.add(new a[0](a[1]));a[2]&&b.recognizeWith(a[2]),a[3]&&b.requireFailure(a[3])},this)}function ja(a,b){var c=a.element;if(c.style){var d;g(a.options.cssProps,function(e,f){d=u(c.style,f),b?(a.oldCssProps[d]=c.style[d],c.style[d]=e):c.style[d]=a.oldCssProps[d]||\"\"}),b||(a.oldCssProps={})}}function ka(a,c){var d=b.createEvent(\"Event\");d.initEvent(a,!0,!0),d.gesture=c,c.target.dispatchEvent(d)}var la,ma=[\"\",\"webkit\",\"Moz\",\"MS\",\"ms\",\"o\"],na=b.createElement(\"div\"),oa=\"function\",pa=Math.round,qa=Math.abs,ra=Date.now;la=\"function\"!=typeof Object.assign?function(a){if(a===d||null===a)throw new TypeError(\"Cannot convert undefined or null to object\");for(var b=Object(a),c=1;c<arguments.length;c++){var e=arguments[c];if(e!==d&&null!==e)for(var f in e)e.hasOwnProperty(f)&&(b[f]=e[f])}return b}:Object.assign;var sa=h(function(a,b,c){for(var e=Object.keys(b),f=0;f<e.length;)(!c||c&&a[e[f]]===d)&&(a[e[f]]=b[e[f]]),f++;return a},\"extend\",\"Use `assign`.\"),ta=h(function(a,b){return sa(a,b,!0)},\"merge\",\"Use `assign`.\"),ua=1,va=/mobile|tablet|ip(ad|hone|od)|android/i,wa=\"ontouchstart\"in a,xa=u(a,\"PointerEvent\")!==d,ya=wa&&va.test(navigator.userAgent),za=\"touch\",Aa=\"pen\",Ba=\"mouse\",Ca=\"kinect\",Da=25,Ea=1,Fa=2,Ga=4,Ha=8,Ia=1,Ja=2,Ka=4,La=8,Ma=16,Na=Ja|Ka,Oa=La|Ma,Pa=Na|Oa,Qa=[\"x\",\"y\"],Ra=[\"clientX\",\"clientY\"];x.prototype={handler:function(){},init:function(){this.evEl&&m(this.element,this.evEl,this.domHandler),this.evTarget&&m(this.target,this.evTarget,this.domHandler),this.evWin&&m(w(this.element),this.evWin,this.domHandler)},destroy:function(){this.evEl&&n(this.element,this.evEl,this.domHandler),this.evTarget&&n(this.target,this.evTarget,this.domHandler),this.evWin&&n(w(this.element),this.evWin,this.domHandler)}};var Sa={mousedown:Ea,mousemove:Fa,mouseup:Ga},Ta=\"mousedown\",Ua=\"mousemove mouseup\";i(L,x,{handler:function(a){var b=Sa[a.type];b&Ea&&0===a.button&&(this.pressed=!0),b&Fa&&1!==a.which&&(b=Ga),this.pressed&&(b&Ga&&(this.pressed=!1),this.callback(this.manager,b,{pointers:[a],changedPointers:[a],pointerType:Ba,srcEvent:a}))}});var Va={pointerdown:Ea,pointermove:Fa,pointerup:Ga,pointercancel:Ha,pointerout:Ha},Wa={2:za,3:Aa,4:Ba,5:Ca},Xa=\"pointerdown\",Ya=\"pointermove pointerup pointercancel\";a.MSPointerEvent&&!a.PointerEvent&&(Xa=\"MSPointerDown\",Ya=\"MSPointerMove MSPointerUp MSPointerCancel\"),i(M,x,{handler:function(a){var b=this.store,c=!1,d=a.type.toLowerCase().replace(\"ms\",\"\"),e=Va[d],f=Wa[a.pointerType]||a.pointerType,g=f==za,h=r(b,a.pointerId,\"pointerId\");e&Ea&&(0===a.button||g)?0>h&&(b.push(a),h=b.length-1):e&(Ga|Ha)&&(c=!0),0>h||(b[h]=a,this.callback(this.manager,e,{pointers:b,changedPointers:[a],pointerType:f,srcEvent:a}),c&&b.splice(h,1))}});var Za={touchstart:Ea,touchmove:Fa,touchend:Ga,touchcancel:Ha},$a=\"touchstart\",_a=\"touchstart touchmove touchend touchcancel\";i(N,x,{handler:function(a){var b=Za[a.type];if(b===Ea&&(this.started=!0),this.started){var c=O.call(this,a,b);b&(Ga|Ha)&&c[0].length-c[1].length===0&&(this.started=!1),this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:za,srcEvent:a})}}});var ab={touchstart:Ea,touchmove:Fa,touchend:Ga,touchcancel:Ha},bb=\"touchstart touchmove touchend touchcancel\";i(P,x,{handler:function(a){var b=ab[a.type],c=Q.call(this,a,b);c&&this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:za,srcEvent:a})}});var cb=2500,db=25;i(R,x,{handler:function(a,b,c){var d=c.pointerType==za,e=c.pointerType==Ba;if(!(e&&c.sourceCapabilities&&c.sourceCapabilities.firesTouchEvents)){if(d)S.call(this,b,c);else if(e&&U.call(this,c))return;this.callback(a,b,c)}},destroy:function(){this.touch.destroy(),this.mouse.destroy()}});var eb=u(na.style,\"touchAction\"),fb=eb!==d,gb=\"compute\",hb=\"auto\",ib=\"manipulation\",jb=\"none\",kb=\"pan-x\",lb=\"pan-y\",mb=X();V.prototype={set:function(a){a==gb&&(a=this.compute()),fb&&this.manager.element.style&&mb[a]&&(this.manager.element.style[eb]=a),this.actions=a.toLowerCase().trim()},update:function(){this.set(this.manager.options.touchAction)},compute:function(){var a=[];return g(this.manager.recognizers,function(b){k(b.options.enable,[b])&&(a=a.concat(b.getTouchAction()))}),W(a.join(\" \"))},preventDefaults:function(a){var b=a.srcEvent,c=a.offsetDirection;if(this.manager.session.prevented)return void b.preventDefault();var d=this.actions,e=p(d,jb)&&!mb[jb],f=p(d,lb)&&!mb[lb],g=p(d,kb)&&!mb[kb];if(e){var h=1===a.pointers.length,i=a.distance<2,j=a.deltaTime<250;if(h&&i&&j)return}return g&&f?void 0:e||f&&c&Na||g&&c&Oa?this.preventSrc(b):void 0},preventSrc:function(a){this.manager.session.prevented=!0,a.preventDefault()}};var nb=1,ob=2,pb=4,qb=8,rb=qb,sb=16,tb=32;Y.prototype={defaults:{},set:function(a){return la(this.options,a),this.manager&&this.manager.touchAction.update(),this},recognizeWith:function(a){if(f(a,\"recognizeWith\",this))return this;var b=this.simultaneous;return a=_(a,this),b[a.id]||(b[a.id]=a,a.recognizeWith(this)),this},dropRecognizeWith:function(a){return f(a,\"dropRecognizeWith\",this)?this:(a=_(a,this),delete this.simultaneous[a.id],this)},requireFailure:function(a){if(f(a,\"requireFailure\",this))return this;var b=this.requireFail;return a=_(a,this),-1===r(b,a)&&(b.push(a),a.requireFailure(this)),this},dropRequireFailure:function(a){if(f(a,\"dropRequireFailure\",this))return this;a=_(a,this);var b=r(this.requireFail,a);return b>-1&&this.requireFail.splice(b,1),this},hasRequireFailures:function(){return this.requireFail.length>0},canRecognizeWith:function(a){return!!this.simultaneous[a.id]},emit:function(a){function b(b){c.manager.emit(b,a)}var c=this,d=this.state;qb>d&&b(c.options.event+Z(d)),b(c.options.event),a.additionalEvent&&b(a.additionalEvent),d>=qb&&b(c.options.event+Z(d))},tryEmit:function(a){return this.canEmit()?this.emit(a):void(this.state=tb)},canEmit:function(){for(var a=0;a<this.requireFail.length;){if(!(this.requireFail[a].state&(tb|nb)))return!1;a++}return!0},recognize:function(a){var b=la({},a);return k(this.options.enable,[this,b])?(this.state&(rb|sb|tb)&&(this.state=nb),this.state=this.process(b),void(this.state&(ob|pb|qb|sb)&&this.tryEmit(b))):(this.reset(),void(this.state=tb))},process:function(a){},getTouchAction:function(){},reset:function(){}},i(aa,Y,{defaults:{pointers:1},attrTest:function(a){var b=this.options.pointers;return 0===b||a.pointers.length===b},process:function(a){var b=this.state,c=a.eventType,d=b&(ob|pb),e=this.attrTest(a);return d&&(c&Ha||!e)?b|sb:d||e?c&Ga?b|qb:b&ob?b|pb:ob:tb}}),i(ba,aa,{defaults:{event:\"pan\",threshold:10,pointers:1,direction:Pa},getTouchAction:function(){var a=this.options.direction,b=[];return a&Na&&b.push(lb),a&Oa&&b.push(kb),b},directionTest:function(a){var b=this.options,c=!0,d=a.distance,e=a.direction,f=a.deltaX,g=a.deltaY;return e&b.direction||(b.direction&Na?(e=0===f?Ia:0>f?Ja:Ka,c=f!=this.pX,d=Math.abs(a.deltaX)):(e=0===g?Ia:0>g?La:Ma,c=g!=this.pY,d=Math.abs(a.deltaY))),a.direction=e,c&&d>b.threshold&&e&b.direction},attrTest:function(a){return aa.prototype.attrTest.call(this,a)&&(this.state&ob||!(this.state&ob)&&this.directionTest(a))},emit:function(a){this.pX=a.deltaX,this.pY=a.deltaY;var b=$(a.direction);b&&(a.additionalEvent=this.options.event+b),this._super.emit.call(this,a)}}),i(ca,aa,{defaults:{event:\"pinch\",threshold:0,pointers:2},getTouchAction:function(){return[jb]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.scale-1)>this.options.threshold||this.state&ob)},emit:function(a){if(1!==a.scale){var b=a.scale<1?\"in\":\"out\";a.additionalEvent=this.options.event+b}this._super.emit.call(this,a)}}),i(da,Y,{defaults:{event:\"press\",pointers:1,time:251,threshold:9},getTouchAction:function(){return[hb]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime>b.time;if(this._input=a,!d||!c||a.eventType&(Ga|Ha)&&!f)this.reset();else if(a.eventType&Ea)this.reset(),this._timer=e(function(){this.state=rb,this.tryEmit()},b.time,this);else if(a.eventType&Ga)return rb;return tb},reset:function(){clearTimeout(this._timer)},emit:function(a){this.state===rb&&(a&&a.eventType&Ga?this.manager.emit(this.options.event+\"up\",a):(this._input.timeStamp=ra(),this.manager.emit(this.options.event,this._input)))}}),i(ea,aa,{defaults:{event:\"rotate\",threshold:0,pointers:2},getTouchAction:function(){return[jb]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.rotation)>this.options.threshold||this.state&ob)}}),i(fa,aa,{defaults:{event:\"swipe\",threshold:10,velocity:.3,direction:Na|Oa,pointers:1},getTouchAction:function(){return ba.prototype.getTouchAction.call(this)},attrTest:function(a){var b,c=this.options.direction;return c&(Na|Oa)?b=a.overallVelocity:c&Na?b=a.overallVelocityX:c&Oa&&(b=a.overallVelocityY),this._super.attrTest.call(this,a)&&c&a.offsetDirection&&a.distance>this.options.threshold&&a.maxPointers==this.options.pointers&&qa(b)>this.options.velocity&&a.eventType&Ga},emit:function(a){var b=$(a.offsetDirection);b&&this.manager.emit(this.options.event+b,a),this.manager.emit(this.options.event,a)}}),i(ga,Y,{defaults:{event:\"tap\",pointers:1,taps:1,interval:300,time:250,threshold:9,posThreshold:10},getTouchAction:function(){return[ib]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime<b.time;if(this.reset(),a.eventType&Ea&&0===this.count)return this.failTimeout();if(d&&f&&c){if(a.eventType!=Ga)return this.failTimeout();var g=this.pTime?a.timeStamp-this.pTime<b.interval:!0,h=!this.pCenter||H(this.pCenter,a.center)<b.posThreshold;this.pTime=a.timeStamp,this.pCenter=a.center,h&&g?this.count+=1:this.count=1,this._input=a;var i=this.count%b.taps;if(0===i)return this.hasRequireFailures()?(this._timer=e(function(){this.state=rb,this.tryEmit()},b.interval,this),ob):rb}return tb},failTimeout:function(){return this._timer=e(function(){this.state=tb},this.options.interval,this),tb},reset:function(){clearTimeout(this._timer)},emit:function(){this.state==rb&&(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))}}),ha.VERSION=\"2.0.7\",ha.defaults={domEvents:!1,touchAction:gb,enable:!0,inputTarget:null,inputClass:null,preset:[[ea,{enable:!1}],[ca,{enable:!1},[\"rotate\"]],[fa,{direction:Na}],[ba,{direction:Na},[\"swipe\"]],[ga],[ga,{event:\"doubletap\",taps:2},[\"tap\"]],[da]],cssProps:{userSelect:\"none\",touchSelect:\"none\",touchCallout:\"none\",contentZooming:\"none\",userDrag:\"none\",tapHighlightColor:\"rgba(0,0,0,0)\"}};var ub=1,vb=2;ia.prototype={set:function(a){return la(this.options,a),a.touchAction&&this.touchAction.update(),a.inputTarget&&(this.input.destroy(),this.input.target=a.inputTarget,this.input.init()),this},stop:function(a){this.session.stopped=a?vb:ub},recognize:function(a){var b=this.session;if(!b.stopped){this.touchAction.preventDefaults(a);var c,d=this.recognizers,e=b.curRecognizer;(!e||e&&e.state&rb)&&(e=b.curRecognizer=null);for(var f=0;f<d.length;)c=d[f],b.stopped===vb||e&&c!=e&&!c.canRecognizeWith(e)?c.reset():c.recognize(a),!e&&c.state&(ob|pb|qb)&&(e=b.curRecognizer=c),f++}},get:function(a){if(a instanceof Y)return a;for(var b=this.recognizers,c=0;c<b.length;c++)if(b[c].options.event==a)return b[c];return null},add:function(a){if(f(a,\"add\",this))return this;var b=this.get(a.options.event);return b&&this.remove(b),this.recognizers.push(a),a.manager=this,this.touchAction.update(),a},remove:function(a){if(f(a,\"remove\",this))return this;if(a=this.get(a)){var b=this.recognizers,c=r(b,a);-1!==c&&(b.splice(c,1),this.touchAction.update())}return this},on:function(a,b){if(a!==d&&b!==d){var c=this.handlers;return g(q(a),function(a){c[a]=c[a]||[],c[a].push(b)}),this}},off:function(a,b){if(a!==d){var c=this.handlers;return g(q(a),function(a){b?c[a]&&c[a].splice(r(c[a],b),1):delete c[a]}),this}},emit:function(a,b){this.options.domEvents&&ka(a,b);var c=this.handlers[a]&&this.handlers[a].slice();if(c&&c.length){b.type=a,b.preventDefault=function(){b.srcEvent.preventDefault()};for(var d=0;d<c.length;)c[d](b),d++}},destroy:function(){this.element&&ja(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null}},la(ha,{INPUT_START:Ea,INPUT_MOVE:Fa,INPUT_END:Ga,INPUT_CANCEL:Ha,STATE_POSSIBLE:nb,STATE_BEGAN:ob,STATE_CHANGED:pb,STATE_ENDED:qb,STATE_RECOGNIZED:rb,STATE_CANCELLED:sb,STATE_FAILED:tb,DIRECTION_NONE:Ia,DIRECTION_LEFT:Ja,DIRECTION_RIGHT:Ka,DIRECTION_UP:La,DIRECTION_DOWN:Ma,DIRECTION_HORIZONTAL:Na,DIRECTION_VERTICAL:Oa,DIRECTION_ALL:Pa,Manager:ia,Input:x,TouchAction:V,TouchInput:P,MouseInput:L,PointerEventInput:M,TouchMouseInput:R,SingleTouchInput:N,Recognizer:Y,AttrRecognizer:aa,Tap:ga,Pan:ba,Swipe:fa,Pinch:ca,Rotate:ea,Press:da,on:m,off:n,each:g,merge:ta,extend:sa,assign:la,inherit:i,bindFn:j,prefixed:u});var wb=\"undefined\"!=typeof a?a:\"undefined\"!=typeof self?self:{};wb.Hammer=ha, true?!(__WEBPACK_AMD_DEFINE_RESULT__ = function(){return ha}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):\"undefined\"!=typeof module&&module.exports?module.exports=ha:a[c]=ha}(window,document,\"Hammer\");\r\n\t//# sourceMappingURL=hammer.min.js.map\n\n/***/ },\n\n/***/ 8:\n/*!*****************************!*\\\n  !*** ./lib/vue/dist/vue.js ***!\n  \\*****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/*!\r\n\t * Vue.js v1.0.26\r\n\t * (c) 2016 Evan You\r\n\t * Released under the MIT License.\r\n\t */\r\n\t(function (global, factory) {\r\n\t   true ? module.exports = factory() :\r\n\t  typeof define === 'function' && define.amd ? define(factory) :\r\n\t  (global.Vue = factory());\r\n\t}(this, function () { 'use strict';\r\n\t\r\n\t  function set(obj, key, val) {\r\n\t    if (hasOwn(obj, key)) {\r\n\t      obj[key] = val;\r\n\t      return;\r\n\t    }\r\n\t    if (obj._isVue) {\r\n\t      set(obj._data, key, val);\r\n\t      return;\r\n\t    }\r\n\t    var ob = obj.__ob__;\r\n\t    if (!ob) {\r\n\t      obj[key] = val;\r\n\t      return;\r\n\t    }\r\n\t    ob.convert(key, val);\r\n\t    ob.dep.notify();\r\n\t    if (ob.vms) {\r\n\t      var i = ob.vms.length;\r\n\t      while (i--) {\r\n\t        var vm = ob.vms[i];\r\n\t        vm._proxy(key);\r\n\t        vm._digest();\r\n\t      }\r\n\t    }\r\n\t    return val;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Delete a property and trigger change if necessary.\r\n\t   *\r\n\t   * @param {Object} obj\r\n\t   * @param {String} key\r\n\t   */\r\n\t\r\n\t  function del(obj, key) {\r\n\t    if (!hasOwn(obj, key)) {\r\n\t      return;\r\n\t    }\r\n\t    delete obj[key];\r\n\t    var ob = obj.__ob__;\r\n\t    if (!ob) {\r\n\t      if (obj._isVue) {\r\n\t        delete obj._data[key];\r\n\t        obj._digest();\r\n\t      }\r\n\t      return;\r\n\t    }\r\n\t    ob.dep.notify();\r\n\t    if (ob.vms) {\r\n\t      var i = ob.vms.length;\r\n\t      while (i--) {\r\n\t        var vm = ob.vms[i];\r\n\t        vm._unproxy(key);\r\n\t        vm._digest();\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t\r\n\t  var hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\t  /**\r\n\t   * Check whether the object has the property.\r\n\t   *\r\n\t   * @param {Object} obj\r\n\t   * @param {String} key\r\n\t   * @return {Boolean}\r\n\t   */\r\n\t\r\n\t  function hasOwn(obj, key) {\r\n\t    return hasOwnProperty.call(obj, key);\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Check if an expression is a literal value.\r\n\t   *\r\n\t   * @param {String} exp\r\n\t   * @return {Boolean}\r\n\t   */\r\n\t\r\n\t  var literalValueRE = /^\\s?(true|false|-?[\\d\\.]+|'[^']*'|\"[^\"]*\")\\s?$/;\r\n\t\r\n\t  function isLiteral(exp) {\r\n\t    return literalValueRE.test(exp);\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Check if a string starts with $ or _\r\n\t   *\r\n\t   * @param {String} str\r\n\t   * @return {Boolean}\r\n\t   */\r\n\t\r\n\t  function isReserved(str) {\r\n\t    var c = (str + '').charCodeAt(0);\r\n\t    return c === 0x24 || c === 0x5F;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Guard text output, make sure undefined outputs\r\n\t   * empty string\r\n\t   *\r\n\t   * @param {*} value\r\n\t   * @return {String}\r\n\t   */\r\n\t\r\n\t  function _toString(value) {\r\n\t    return value == null ? '' : value.toString();\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Check and convert possible numeric strings to numbers\r\n\t   * before setting back to data\r\n\t   *\r\n\t   * @param {*} value\r\n\t   * @return {*|Number}\r\n\t   */\r\n\t\r\n\t  function toNumber(value) {\r\n\t    if (typeof value !== 'string') {\r\n\t      return value;\r\n\t    } else {\r\n\t      var parsed = Number(value);\r\n\t      return isNaN(parsed) ? value : parsed;\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Convert string boolean literals into real booleans.\r\n\t   *\r\n\t   * @param {*} value\r\n\t   * @return {*|Boolean}\r\n\t   */\r\n\t\r\n\t  function toBoolean(value) {\r\n\t    return value === 'true' ? true : value === 'false' ? false : value;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Strip quotes from a string\r\n\t   *\r\n\t   * @param {String} str\r\n\t   * @return {String | false}\r\n\t   */\r\n\t\r\n\t  function stripQuotes(str) {\r\n\t    var a = str.charCodeAt(0);\r\n\t    var b = str.charCodeAt(str.length - 1);\r\n\t    return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Camelize a hyphen-delmited string.\r\n\t   *\r\n\t   * @param {String} str\r\n\t   * @return {String}\r\n\t   */\r\n\t\r\n\t  var camelizeRE = /-(\\w)/g;\r\n\t\r\n\t  function camelize(str) {\r\n\t    return str.replace(camelizeRE, toUpper);\r\n\t  }\r\n\t\r\n\t  function toUpper(_, c) {\r\n\t    return c ? c.toUpperCase() : '';\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Hyphenate a camelCase string.\r\n\t   *\r\n\t   * @param {String} str\r\n\t   * @return {String}\r\n\t   */\r\n\t\r\n\t  var hyphenateRE = /([a-z\\d])([A-Z])/g;\r\n\t\r\n\t  function hyphenate(str) {\r\n\t    return str.replace(hyphenateRE, '$1-$2').toLowerCase();\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Converts hyphen/underscore/slash delimitered names into\r\n\t   * camelized classNames.\r\n\t   *\r\n\t   * e.g. my-component => MyComponent\r\n\t   *      some_else    => SomeElse\r\n\t   *      some/comp    => SomeComp\r\n\t   *\r\n\t   * @param {String} str\r\n\t   * @return {String}\r\n\t   */\r\n\t\r\n\t  var classifyRE = /(?:^|[-_\\/])(\\w)/g;\r\n\t\r\n\t  function classify(str) {\r\n\t    return str.replace(classifyRE, toUpper);\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Simple bind, faster than native\r\n\t   *\r\n\t   * @param {Function} fn\r\n\t   * @param {Object} ctx\r\n\t   * @return {Function}\r\n\t   */\r\n\t\r\n\t  function bind(fn, ctx) {\r\n\t    return function (a) {\r\n\t      var l = arguments.length;\r\n\t      return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\r\n\t    };\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Convert an Array-like object to a real Array.\r\n\t   *\r\n\t   * @param {Array-like} list\r\n\t   * @param {Number} [start] - start index\r\n\t   * @return {Array}\r\n\t   */\r\n\t\r\n\t  function toArray(list, start) {\r\n\t    start = start || 0;\r\n\t    var i = list.length - start;\r\n\t    var ret = new Array(i);\r\n\t    while (i--) {\r\n\t      ret[i] = list[i + start];\r\n\t    }\r\n\t    return ret;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Mix properties into target object.\r\n\t   *\r\n\t   * @param {Object} to\r\n\t   * @param {Object} from\r\n\t   */\r\n\t\r\n\t  function extend(to, from) {\r\n\t    var keys = Object.keys(from);\r\n\t    var i = keys.length;\r\n\t    while (i--) {\r\n\t      to[keys[i]] = from[keys[i]];\r\n\t    }\r\n\t    return to;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Quick object check - this is primarily used to tell\r\n\t   * Objects from primitive values when we know the value\r\n\t   * is a JSON-compliant type.\r\n\t   *\r\n\t   * @param {*} obj\r\n\t   * @return {Boolean}\r\n\t   */\r\n\t\r\n\t  function isObject(obj) {\r\n\t    return obj !== null && typeof obj === 'object';\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Strict object type check. Only returns true\r\n\t   * for plain JavaScript objects.\r\n\t   *\r\n\t   * @param {*} obj\r\n\t   * @return {Boolean}\r\n\t   */\r\n\t\r\n\t  var toString = Object.prototype.toString;\r\n\t  var OBJECT_STRING = '[object Object]';\r\n\t\r\n\t  function isPlainObject(obj) {\r\n\t    return toString.call(obj) === OBJECT_STRING;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Array type check.\r\n\t   *\r\n\t   * @param {*} obj\r\n\t   * @return {Boolean}\r\n\t   */\r\n\t\r\n\t  var isArray = Array.isArray;\r\n\t\r\n\t  /**\r\n\t   * Define a property.\r\n\t   *\r\n\t   * @param {Object} obj\r\n\t   * @param {String} key\r\n\t   * @param {*} val\r\n\t   * @param {Boolean} [enumerable]\r\n\t   */\r\n\t\r\n\t  function def(obj, key, val, enumerable) {\r\n\t    Object.defineProperty(obj, key, {\r\n\t      value: val,\r\n\t      enumerable: !!enumerable,\r\n\t      writable: true,\r\n\t      configurable: true\r\n\t    });\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Debounce a function so it only gets called after the\r\n\t   * input stops arriving after the given wait period.\r\n\t   *\r\n\t   * @param {Function} func\r\n\t   * @param {Number} wait\r\n\t   * @return {Function} - the debounced function\r\n\t   */\r\n\t\r\n\t  function _debounce(func, wait) {\r\n\t    var timeout, args, context, timestamp, result;\r\n\t    var later = function later() {\r\n\t      var last = Date.now() - timestamp;\r\n\t      if (last < wait && last >= 0) {\r\n\t        timeout = setTimeout(later, wait - last);\r\n\t      } else {\r\n\t        timeout = null;\r\n\t        result = func.apply(context, args);\r\n\t        if (!timeout) context = args = null;\r\n\t      }\r\n\t    };\r\n\t    return function () {\r\n\t      context = this;\r\n\t      args = arguments;\r\n\t      timestamp = Date.now();\r\n\t      if (!timeout) {\r\n\t        timeout = setTimeout(later, wait);\r\n\t      }\r\n\t      return result;\r\n\t    };\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Manual indexOf because it's slightly faster than\r\n\t   * native.\r\n\t   *\r\n\t   * @param {Array} arr\r\n\t   * @param {*} obj\r\n\t   */\r\n\t\r\n\t  function indexOf(arr, obj) {\r\n\t    var i = arr.length;\r\n\t    while (i--) {\r\n\t      if (arr[i] === obj) return i;\r\n\t    }\r\n\t    return -1;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Make a cancellable version of an async callback.\r\n\t   *\r\n\t   * @param {Function} fn\r\n\t   * @return {Function}\r\n\t   */\r\n\t\r\n\t  function cancellable(fn) {\r\n\t    var cb = function cb() {\r\n\t      if (!cb.cancelled) {\r\n\t        return fn.apply(this, arguments);\r\n\t      }\r\n\t    };\r\n\t    cb.cancel = function () {\r\n\t      cb.cancelled = true;\r\n\t    };\r\n\t    return cb;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Check if two values are loosely equal - that is,\r\n\t   * if they are plain objects, do they have the same shape?\r\n\t   *\r\n\t   * @param {*} a\r\n\t   * @param {*} b\r\n\t   * @return {Boolean}\r\n\t   */\r\n\t\r\n\t  function looseEqual(a, b) {\r\n\t    /* eslint-disable eqeqeq */\r\n\t    return a == b || (isObject(a) && isObject(b) ? JSON.stringify(a) === JSON.stringify(b) : false);\r\n\t    /* eslint-enable eqeqeq */\r\n\t  }\r\n\t\r\n\t  var hasProto = ('__proto__' in {});\r\n\t\r\n\t  // Browser environment sniffing\r\n\t  var inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';\r\n\t\r\n\t  // detect devtools\r\n\t  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\r\n\t\r\n\t  // UA sniffing for working around browser-specific quirks\r\n\t  var UA = inBrowser && window.navigator.userAgent.toLowerCase();\r\n\t  var isIE = UA && UA.indexOf('trident') > 0;\r\n\t  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;\r\n\t  var isAndroid = UA && UA.indexOf('android') > 0;\r\n\t  var isIos = UA && /(iphone|ipad|ipod|ios)/i.test(UA);\r\n\t  var iosVersionMatch = isIos && UA.match(/os ([\\d_]+)/);\r\n\t  var iosVersion = iosVersionMatch && iosVersionMatch[1].split('_');\r\n\t\r\n\t  // detecting iOS UIWebView by indexedDB\r\n\t  var hasMutationObserverBug = iosVersion && Number(iosVersion[0]) >= 9 && Number(iosVersion[1]) >= 3 && !window.indexedDB;\r\n\t\r\n\t  var transitionProp = undefined;\r\n\t  var transitionEndEvent = undefined;\r\n\t  var animationProp = undefined;\r\n\t  var animationEndEvent = undefined;\r\n\t\r\n\t  // Transition property/event sniffing\r\n\t  if (inBrowser && !isIE9) {\r\n\t    var isWebkitTrans = window.ontransitionend === undefined && window.onwebkittransitionend !== undefined;\r\n\t    var isWebkitAnim = window.onanimationend === undefined && window.onwebkitanimationend !== undefined;\r\n\t    transitionProp = isWebkitTrans ? 'WebkitTransition' : 'transition';\r\n\t    transitionEndEvent = isWebkitTrans ? 'webkitTransitionEnd' : 'transitionend';\r\n\t    animationProp = isWebkitAnim ? 'WebkitAnimation' : 'animation';\r\n\t    animationEndEvent = isWebkitAnim ? 'webkitAnimationEnd' : 'animationend';\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Defer a task to execute it asynchronously. Ideally this\r\n\t   * should be executed as a microtask, so we leverage\r\n\t   * MutationObserver if it's available, and fallback to\r\n\t   * setTimeout(0).\r\n\t   *\r\n\t   * @param {Function} cb\r\n\t   * @param {Object} ctx\r\n\t   */\r\n\t\r\n\t  var nextTick = (function () {\r\n\t    var callbacks = [];\r\n\t    var pending = false;\r\n\t    var timerFunc;\r\n\t    function nextTickHandler() {\r\n\t      pending = false;\r\n\t      var copies = callbacks.slice(0);\r\n\t      callbacks = [];\r\n\t      for (var i = 0; i < copies.length; i++) {\r\n\t        copies[i]();\r\n\t      }\r\n\t    }\r\n\t\r\n\t    /* istanbul ignore if */\r\n\t    if (typeof MutationObserver !== 'undefined' && !hasMutationObserverBug) {\r\n\t      var counter = 1;\r\n\t      var observer = new MutationObserver(nextTickHandler);\r\n\t      var textNode = document.createTextNode(counter);\r\n\t      observer.observe(textNode, {\r\n\t        characterData: true\r\n\t      });\r\n\t      timerFunc = function () {\r\n\t        counter = (counter + 1) % 2;\r\n\t        textNode.data = counter;\r\n\t      };\r\n\t    } else {\r\n\t      // webpack attempts to inject a shim for setImmediate\r\n\t      // if it is used as a global, so we have to work around that to\r\n\t      // avoid bundling unnecessary code.\r\n\t      var context = inBrowser ? window : typeof global !== 'undefined' ? global : {};\r\n\t      timerFunc = context.setImmediate || setTimeout;\r\n\t    }\r\n\t    return function (cb, ctx) {\r\n\t      var func = ctx ? function () {\r\n\t        cb.call(ctx);\r\n\t      } : cb;\r\n\t      callbacks.push(func);\r\n\t      if (pending) return;\r\n\t      pending = true;\r\n\t      timerFunc(nextTickHandler, 0);\r\n\t    };\r\n\t  })();\r\n\t\r\n\t  var _Set = undefined;\r\n\t  /* istanbul ignore if */\r\n\t  if (typeof Set !== 'undefined' && Set.toString().match(/native code/)) {\r\n\t    // use native Set when available.\r\n\t    _Set = Set;\r\n\t  } else {\r\n\t    // a non-standard Set polyfill that only works with primitive keys.\r\n\t    _Set = function () {\r\n\t      this.set = Object.create(null);\r\n\t    };\r\n\t    _Set.prototype.has = function (key) {\r\n\t      return this.set[key] !== undefined;\r\n\t    };\r\n\t    _Set.prototype.add = function (key) {\r\n\t      this.set[key] = 1;\r\n\t    };\r\n\t    _Set.prototype.clear = function () {\r\n\t      this.set = Object.create(null);\r\n\t    };\r\n\t  }\r\n\t\r\n\t  function Cache(limit) {\r\n\t    this.size = 0;\r\n\t    this.limit = limit;\r\n\t    this.head = this.tail = undefined;\r\n\t    this._keymap = Object.create(null);\r\n\t  }\r\n\t\r\n\t  var p = Cache.prototype;\r\n\t\r\n\t  /**\r\n\t   * Put <value> into the cache associated with <key>.\r\n\t   * Returns the entry which was removed to make room for\r\n\t   * the new entry. Otherwise undefined is returned.\r\n\t   * (i.e. if there was enough room already).\r\n\t   *\r\n\t   * @param {String} key\r\n\t   * @param {*} value\r\n\t   * @return {Entry|undefined}\r\n\t   */\r\n\t\r\n\t  p.put = function (key, value) {\r\n\t    var removed;\r\n\t\r\n\t    var entry = this.get(key, true);\r\n\t    if (!entry) {\r\n\t      if (this.size === this.limit) {\r\n\t        removed = this.shift();\r\n\t      }\r\n\t      entry = {\r\n\t        key: key\r\n\t      };\r\n\t      this._keymap[key] = entry;\r\n\t      if (this.tail) {\r\n\t        this.tail.newer = entry;\r\n\t        entry.older = this.tail;\r\n\t      } else {\r\n\t        this.head = entry;\r\n\t      }\r\n\t      this.tail = entry;\r\n\t      this.size++;\r\n\t    }\r\n\t    entry.value = value;\r\n\t\r\n\t    return removed;\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Purge the least recently used (oldest) entry from the\r\n\t   * cache. Returns the removed entry or undefined if the\r\n\t   * cache was empty.\r\n\t   */\r\n\t\r\n\t  p.shift = function () {\r\n\t    var entry = this.head;\r\n\t    if (entry) {\r\n\t      this.head = this.head.newer;\r\n\t      this.head.older = undefined;\r\n\t      entry.newer = entry.older = undefined;\r\n\t      this._keymap[entry.key] = undefined;\r\n\t      this.size--;\r\n\t    }\r\n\t    return entry;\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Get and register recent use of <key>. Returns the value\r\n\t   * associated with <key> or undefined if not in cache.\r\n\t   *\r\n\t   * @param {String} key\r\n\t   * @param {Boolean} returnEntry\r\n\t   * @return {Entry|*}\r\n\t   */\r\n\t\r\n\t  p.get = function (key, returnEntry) {\r\n\t    var entry = this._keymap[key];\r\n\t    if (entry === undefined) return;\r\n\t    if (entry === this.tail) {\r\n\t      return returnEntry ? entry : entry.value;\r\n\t    }\r\n\t    // HEAD--------------TAIL\r\n\t    //   <.older   .newer>\r\n\t    //  <--- add direction --\r\n\t    //   A  B  C  <D>  E\r\n\t    if (entry.newer) {\r\n\t      if (entry === this.head) {\r\n\t        this.head = entry.newer;\r\n\t      }\r\n\t      entry.newer.older = entry.older; // C <-- E.\r\n\t    }\r\n\t    if (entry.older) {\r\n\t      entry.older.newer = entry.newer; // C. --> E\r\n\t    }\r\n\t    entry.newer = undefined; // D --x\r\n\t    entry.older = this.tail; // D. --> E\r\n\t    if (this.tail) {\r\n\t      this.tail.newer = entry; // E. <-- D\r\n\t    }\r\n\t    this.tail = entry;\r\n\t    return returnEntry ? entry : entry.value;\r\n\t  };\r\n\t\r\n\t  var cache$1 = new Cache(1000);\r\n\t  var filterTokenRE = /[^\\s'\"]+|'[^']*'|\"[^\"]*\"/g;\r\n\t  var reservedArgRE = /^in$|^-?\\d+/;\r\n\t\r\n\t  /**\r\n\t   * Parser state\r\n\t   */\r\n\t\r\n\t  var str;\r\n\t  var dir;\r\n\t  var c;\r\n\t  var prev;\r\n\t  var i;\r\n\t  var l;\r\n\t  var lastFilterIndex;\r\n\t  var inSingle;\r\n\t  var inDouble;\r\n\t  var curly;\r\n\t  var square;\r\n\t  var paren;\r\n\t  /**\r\n\t   * Push a filter to the current directive object\r\n\t   */\r\n\t\r\n\t  function pushFilter() {\r\n\t    var exp = str.slice(lastFilterIndex, i).trim();\r\n\t    var filter;\r\n\t    if (exp) {\r\n\t      filter = {};\r\n\t      var tokens = exp.match(filterTokenRE);\r\n\t      filter.name = tokens[0];\r\n\t      if (tokens.length > 1) {\r\n\t        filter.args = tokens.slice(1).map(processFilterArg);\r\n\t      }\r\n\t    }\r\n\t    if (filter) {\r\n\t      (dir.filters = dir.filters || []).push(filter);\r\n\t    }\r\n\t    lastFilterIndex = i + 1;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Check if an argument is dynamic and strip quotes.\r\n\t   *\r\n\t   * @param {String} arg\r\n\t   * @return {Object}\r\n\t   */\r\n\t\r\n\t  function processFilterArg(arg) {\r\n\t    if (reservedArgRE.test(arg)) {\r\n\t      return {\r\n\t        value: toNumber(arg),\r\n\t        dynamic: false\r\n\t      };\r\n\t    } else {\r\n\t      var stripped = stripQuotes(arg);\r\n\t      var dynamic = stripped === arg;\r\n\t      return {\r\n\t        value: dynamic ? arg : stripped,\r\n\t        dynamic: dynamic\r\n\t      };\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Parse a directive value and extract the expression\r\n\t   * and its filters into a descriptor.\r\n\t   *\r\n\t   * Example:\r\n\t   *\r\n\t   * \"a + 1 | uppercase\" will yield:\r\n\t   * {\r\n\t   *   expression: 'a + 1',\r\n\t   *   filters: [\r\n\t   *     { name: 'uppercase', args: null }\r\n\t   *   ]\r\n\t   * }\r\n\t   *\r\n\t   * @param {String} s\r\n\t   * @return {Object}\r\n\t   */\r\n\t\r\n\t  function parseDirective(s) {\r\n\t    var hit = cache$1.get(s);\r\n\t    if (hit) {\r\n\t      return hit;\r\n\t    }\r\n\t\r\n\t    // reset parser state\r\n\t    str = s;\r\n\t    inSingle = inDouble = false;\r\n\t    curly = square = paren = 0;\r\n\t    lastFilterIndex = 0;\r\n\t    dir = {};\r\n\t\r\n\t    for (i = 0, l = str.length; i < l; i++) {\r\n\t      prev = c;\r\n\t      c = str.charCodeAt(i);\r\n\t      if (inSingle) {\r\n\t        // check single quote\r\n\t        if (c === 0x27 && prev !== 0x5C) inSingle = !inSingle;\r\n\t      } else if (inDouble) {\r\n\t        // check double quote\r\n\t        if (c === 0x22 && prev !== 0x5C) inDouble = !inDouble;\r\n\t      } else if (c === 0x7C && // pipe\r\n\t      str.charCodeAt(i + 1) !== 0x7C && str.charCodeAt(i - 1) !== 0x7C) {\r\n\t        if (dir.expression == null) {\r\n\t          // first filter, end of expression\r\n\t          lastFilterIndex = i + 1;\r\n\t          dir.expression = str.slice(0, i).trim();\r\n\t        } else {\r\n\t          // already has filter\r\n\t          pushFilter();\r\n\t        }\r\n\t      } else {\r\n\t        switch (c) {\r\n\t          case 0x22:\r\n\t            inDouble = true;break; // \"\r\n\t          case 0x27:\r\n\t            inSingle = true;break; // '\r\n\t          case 0x28:\r\n\t            paren++;break; // (\r\n\t          case 0x29:\r\n\t            paren--;break; // )\r\n\t          case 0x5B:\r\n\t            square++;break; // [\r\n\t          case 0x5D:\r\n\t            square--;break; // ]\r\n\t          case 0x7B:\r\n\t            curly++;break; // {\r\n\t          case 0x7D:\r\n\t            curly--;break; // }\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t\r\n\t    if (dir.expression == null) {\r\n\t      dir.expression = str.slice(0, i).trim();\r\n\t    } else if (lastFilterIndex !== 0) {\r\n\t      pushFilter();\r\n\t    }\r\n\t\r\n\t    cache$1.put(s, dir);\r\n\t    return dir;\r\n\t  }\r\n\t\r\n\tvar directive = Object.freeze({\r\n\t    parseDirective: parseDirective\r\n\t  });\r\n\t\r\n\t  var regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\r\n\t  var cache = undefined;\r\n\t  var tagRE = undefined;\r\n\t  var htmlRE = undefined;\r\n\t  /**\r\n\t   * Escape a string so it can be used in a RegExp\r\n\t   * constructor.\r\n\t   *\r\n\t   * @param {String} str\r\n\t   */\r\n\t\r\n\t  function escapeRegex(str) {\r\n\t    return str.replace(regexEscapeRE, '\\\\$&');\r\n\t  }\r\n\t\r\n\t  function compileRegex() {\r\n\t    var open = escapeRegex(config.delimiters[0]);\r\n\t    var close = escapeRegex(config.delimiters[1]);\r\n\t    var unsafeOpen = escapeRegex(config.unsafeDelimiters[0]);\r\n\t    var unsafeClose = escapeRegex(config.unsafeDelimiters[1]);\r\n\t    tagRE = new RegExp(unsafeOpen + '((?:.|\\\\n)+?)' + unsafeClose + '|' + open + '((?:.|\\\\n)+?)' + close, 'g');\r\n\t    htmlRE = new RegExp('^' + unsafeOpen + '((?:.|\\\\n)+?)' + unsafeClose + '$');\r\n\t    // reset cache\r\n\t    cache = new Cache(1000);\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Parse a template text string into an array of tokens.\r\n\t   *\r\n\t   * @param {String} text\r\n\t   * @return {Array<Object> | null}\r\n\t   *               - {String} type\r\n\t   *               - {String} value\r\n\t   *               - {Boolean} [html]\r\n\t   *               - {Boolean} [oneTime]\r\n\t   */\r\n\t\r\n\t  function parseText(text) {\r\n\t    if (!cache) {\r\n\t      compileRegex();\r\n\t    }\r\n\t    var hit = cache.get(text);\r\n\t    if (hit) {\r\n\t      return hit;\r\n\t    }\r\n\t    if (!tagRE.test(text)) {\r\n\t      return null;\r\n\t    }\r\n\t    var tokens = [];\r\n\t    var lastIndex = tagRE.lastIndex = 0;\r\n\t    var match, index, html, value, first, oneTime;\r\n\t    /* eslint-disable no-cond-assign */\r\n\t    while (match = tagRE.exec(text)) {\r\n\t      /* eslint-enable no-cond-assign */\r\n\t      index = match.index;\r\n\t      // push text token\r\n\t      if (index > lastIndex) {\r\n\t        tokens.push({\r\n\t          value: text.slice(lastIndex, index)\r\n\t        });\r\n\t      }\r\n\t      // tag token\r\n\t      html = htmlRE.test(match[0]);\r\n\t      value = html ? match[1] : match[2];\r\n\t      first = value.charCodeAt(0);\r\n\t      oneTime = first === 42; // *\r\n\t      value = oneTime ? value.slice(1) : value;\r\n\t      tokens.push({\r\n\t        tag: true,\r\n\t        value: value.trim(),\r\n\t        html: html,\r\n\t        oneTime: oneTime\r\n\t      });\r\n\t      lastIndex = index + match[0].length;\r\n\t    }\r\n\t    if (lastIndex < text.length) {\r\n\t      tokens.push({\r\n\t        value: text.slice(lastIndex)\r\n\t      });\r\n\t    }\r\n\t    cache.put(text, tokens);\r\n\t    return tokens;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Format a list of tokens into an expression.\r\n\t   * e.g. tokens parsed from 'a {{b}} c' can be serialized\r\n\t   * into one single expression as '\"a \" + b + \" c\"'.\r\n\t   *\r\n\t   * @param {Array} tokens\r\n\t   * @param {Vue} [vm]\r\n\t   * @return {String}\r\n\t   */\r\n\t\r\n\t  function tokensToExp(tokens, vm) {\r\n\t    if (tokens.length > 1) {\r\n\t      return tokens.map(function (token) {\r\n\t        return formatToken(token, vm);\r\n\t      }).join('+');\r\n\t    } else {\r\n\t      return formatToken(tokens[0], vm, true);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Format a single token.\r\n\t   *\r\n\t   * @param {Object} token\r\n\t   * @param {Vue} [vm]\r\n\t   * @param {Boolean} [single]\r\n\t   * @return {String}\r\n\t   */\r\n\t\r\n\t  function formatToken(token, vm, single) {\r\n\t    return token.tag ? token.oneTime && vm ? '\"' + vm.$eval(token.value) + '\"' : inlineFilters(token.value, single) : '\"' + token.value + '\"';\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * For an attribute with multiple interpolation tags,\r\n\t   * e.g. attr=\"some-{{thing | filter}}\", in order to combine\r\n\t   * the whole thing into a single watchable expression, we\r\n\t   * have to inline those filters. This function does exactly\r\n\t   * that. This is a bit hacky but it avoids heavy changes\r\n\t   * to directive parser and watcher mechanism.\r\n\t   *\r\n\t   * @param {String} exp\r\n\t   * @param {Boolean} single\r\n\t   * @return {String}\r\n\t   */\r\n\t\r\n\t  var filterRE = /[^|]\\|[^|]/;\r\n\t  function inlineFilters(exp, single) {\r\n\t    if (!filterRE.test(exp)) {\r\n\t      return single ? exp : '(' + exp + ')';\r\n\t    } else {\r\n\t      var dir = parseDirective(exp);\r\n\t      if (!dir.filters) {\r\n\t        return '(' + exp + ')';\r\n\t      } else {\r\n\t        return 'this._applyFilters(' + dir.expression + // value\r\n\t        ',null,' + // oldValue (null for read)\r\n\t        JSON.stringify(dir.filters) + // filter descriptors\r\n\t        ',false)'; // write?\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t\r\n\tvar text = Object.freeze({\r\n\t    compileRegex: compileRegex,\r\n\t    parseText: parseText,\r\n\t    tokensToExp: tokensToExp\r\n\t  });\r\n\t\r\n\t  var delimiters = ['{{', '}}'];\r\n\t  var unsafeDelimiters = ['{{{', '}}}'];\r\n\t\r\n\t  var config = Object.defineProperties({\r\n\t\r\n\t    /**\r\n\t     * Whether to print debug messages.\r\n\t     * Also enables stack trace for warnings.\r\n\t     *\r\n\t     * @type {Boolean}\r\n\t     */\r\n\t\r\n\t    debug: false,\r\n\t\r\n\t    /**\r\n\t     * Whether to suppress warnings.\r\n\t     *\r\n\t     * @type {Boolean}\r\n\t     */\r\n\t\r\n\t    silent: false,\r\n\t\r\n\t    /**\r\n\t     * Whether to use async rendering.\r\n\t     */\r\n\t\r\n\t    async: true,\r\n\t\r\n\t    /**\r\n\t     * Whether to warn against errors caught when evaluating\r\n\t     * expressions.\r\n\t     */\r\n\t\r\n\t    warnExpressionErrors: true,\r\n\t\r\n\t    /**\r\n\t     * Whether to allow devtools inspection.\r\n\t     * Disabled by default in production builds.\r\n\t     */\r\n\t\r\n\t    devtools: 'development' !== 'production',\r\n\t\r\n\t    /**\r\n\t     * Internal flag to indicate the delimiters have been\r\n\t     * changed.\r\n\t     *\r\n\t     * @type {Boolean}\r\n\t     */\r\n\t\r\n\t    _delimitersChanged: true,\r\n\t\r\n\t    /**\r\n\t     * List of asset types that a component can own.\r\n\t     *\r\n\t     * @type {Array}\r\n\t     */\r\n\t\r\n\t    _assetTypes: ['component', 'directive', 'elementDirective', 'filter', 'transition', 'partial'],\r\n\t\r\n\t    /**\r\n\t     * prop binding modes\r\n\t     */\r\n\t\r\n\t    _propBindingModes: {\r\n\t      ONE_WAY: 0,\r\n\t      TWO_WAY: 1,\r\n\t      ONE_TIME: 2\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Max circular updates allowed in a batcher flush cycle.\r\n\t     */\r\n\t\r\n\t    _maxUpdateCount: 100\r\n\t\r\n\t  }, {\r\n\t    delimiters: { /**\r\n\t                   * Interpolation delimiters. Changing these would trigger\r\n\t                   * the text parser to re-compile the regular expressions.\r\n\t                   *\r\n\t                   * @type {Array<String>}\r\n\t                   */\r\n\t\r\n\t      get: function get() {\r\n\t        return delimiters;\r\n\t      },\r\n\t      set: function set(val) {\r\n\t        delimiters = val;\r\n\t        compileRegex();\r\n\t      },\r\n\t      configurable: true,\r\n\t      enumerable: true\r\n\t    },\r\n\t    unsafeDelimiters: {\r\n\t      get: function get() {\r\n\t        return unsafeDelimiters;\r\n\t      },\r\n\t      set: function set(val) {\r\n\t        unsafeDelimiters = val;\r\n\t        compileRegex();\r\n\t      },\r\n\t      configurable: true,\r\n\t      enumerable: true\r\n\t    }\r\n\t  });\r\n\t\r\n\t  var warn = undefined;\r\n\t  var formatComponentName = undefined;\r\n\t\r\n\t  if (true) {\r\n\t    (function () {\r\n\t      var hasConsole = typeof console !== 'undefined';\r\n\t\r\n\t      warn = function (msg, vm) {\r\n\t        if (hasConsole && !config.silent) {\r\n\t          console.error('[Vue warn]: ' + msg + (vm ? formatComponentName(vm) : ''));\r\n\t        }\r\n\t      };\r\n\t\r\n\t      formatComponentName = function (vm) {\r\n\t        var name = vm._isVue ? vm.$options.name : vm.name;\r\n\t        return name ? ' (found in component: <' + hyphenate(name) + '>)' : '';\r\n\t      };\r\n\t    })();\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Append with transition.\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @param {Element} target\r\n\t   * @param {Vue} vm\r\n\t   * @param {Function} [cb]\r\n\t   */\r\n\t\r\n\t  function appendWithTransition(el, target, vm, cb) {\r\n\t    applyTransition(el, 1, function () {\r\n\t      target.appendChild(el);\r\n\t    }, vm, cb);\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * InsertBefore with transition.\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @param {Element} target\r\n\t   * @param {Vue} vm\r\n\t   * @param {Function} [cb]\r\n\t   */\r\n\t\r\n\t  function beforeWithTransition(el, target, vm, cb) {\r\n\t    applyTransition(el, 1, function () {\r\n\t      before(el, target);\r\n\t    }, vm, cb);\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Remove with transition.\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @param {Vue} vm\r\n\t   * @param {Function} [cb]\r\n\t   */\r\n\t\r\n\t  function removeWithTransition(el, vm, cb) {\r\n\t    applyTransition(el, -1, function () {\r\n\t      remove(el);\r\n\t    }, vm, cb);\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Apply transitions with an operation callback.\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @param {Number} direction\r\n\t   *                  1: enter\r\n\t   *                 -1: leave\r\n\t   * @param {Function} op - the actual DOM operation\r\n\t   * @param {Vue} vm\r\n\t   * @param {Function} [cb]\r\n\t   */\r\n\t\r\n\t  function applyTransition(el, direction, op, vm, cb) {\r\n\t    var transition = el.__v_trans;\r\n\t    if (!transition ||\r\n\t    // skip if there are no js hooks and CSS transition is\r\n\t    // not supported\r\n\t    !transition.hooks && !transitionEndEvent ||\r\n\t    // skip transitions for initial compile\r\n\t    !vm._isCompiled ||\r\n\t    // if the vm is being manipulated by a parent directive\r\n\t    // during the parent's compilation phase, skip the\r\n\t    // animation.\r\n\t    vm.$parent && !vm.$parent._isCompiled) {\r\n\t      op();\r\n\t      if (cb) cb();\r\n\t      return;\r\n\t    }\r\n\t    var action = direction > 0 ? 'enter' : 'leave';\r\n\t    transition[action](op, cb);\r\n\t  }\r\n\t\r\n\tvar transition = Object.freeze({\r\n\t    appendWithTransition: appendWithTransition,\r\n\t    beforeWithTransition: beforeWithTransition,\r\n\t    removeWithTransition: removeWithTransition,\r\n\t    applyTransition: applyTransition\r\n\t  });\r\n\t\r\n\t  /**\r\n\t   * Query an element selector if it's not an element already.\r\n\t   *\r\n\t   * @param {String|Element} el\r\n\t   * @return {Element}\r\n\t   */\r\n\t\r\n\t  function query(el) {\r\n\t    if (typeof el === 'string') {\r\n\t      var selector = el;\r\n\t      el = document.querySelector(el);\r\n\t      if (!el) {\r\n\t        'development' !== 'production' && warn('Cannot find element: ' + selector);\r\n\t      }\r\n\t    }\r\n\t    return el;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Check if a node is in the document.\r\n\t   * Note: document.documentElement.contains should work here\r\n\t   * but always returns false for comment nodes in phantomjs,\r\n\t   * making unit tests difficult. This is fixed by doing the\r\n\t   * contains() check on the node's parentNode instead of\r\n\t   * the node itself.\r\n\t   *\r\n\t   * @param {Node} node\r\n\t   * @return {Boolean}\r\n\t   */\r\n\t\r\n\t  function inDoc(node) {\r\n\t    if (!node) return false;\r\n\t    var doc = node.ownerDocument.documentElement;\r\n\t    var parent = node.parentNode;\r\n\t    return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Get and remove an attribute from a node.\r\n\t   *\r\n\t   * @param {Node} node\r\n\t   * @param {String} _attr\r\n\t   */\r\n\t\r\n\t  function getAttr(node, _attr) {\r\n\t    var val = node.getAttribute(_attr);\r\n\t    if (val !== null) {\r\n\t      node.removeAttribute(_attr);\r\n\t    }\r\n\t    return val;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Get an attribute with colon or v-bind: prefix.\r\n\t   *\r\n\t   * @param {Node} node\r\n\t   * @param {String} name\r\n\t   * @return {String|null}\r\n\t   */\r\n\t\r\n\t  function getBindAttr(node, name) {\r\n\t    var val = getAttr(node, ':' + name);\r\n\t    if (val === null) {\r\n\t      val = getAttr(node, 'v-bind:' + name);\r\n\t    }\r\n\t    return val;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Check the presence of a bind attribute.\r\n\t   *\r\n\t   * @param {Node} node\r\n\t   * @param {String} name\r\n\t   * @return {Boolean}\r\n\t   */\r\n\t\r\n\t  function hasBindAttr(node, name) {\r\n\t    return node.hasAttribute(name) || node.hasAttribute(':' + name) || node.hasAttribute('v-bind:' + name);\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Insert el before target\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @param {Element} target\r\n\t   */\r\n\t\r\n\t  function before(el, target) {\r\n\t    target.parentNode.insertBefore(el, target);\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Insert el after target\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @param {Element} target\r\n\t   */\r\n\t\r\n\t  function after(el, target) {\r\n\t    if (target.nextSibling) {\r\n\t      before(el, target.nextSibling);\r\n\t    } else {\r\n\t      target.parentNode.appendChild(el);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Remove el from DOM\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   */\r\n\t\r\n\t  function remove(el) {\r\n\t    el.parentNode.removeChild(el);\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Prepend el to target\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @param {Element} target\r\n\t   */\r\n\t\r\n\t  function prepend(el, target) {\r\n\t    if (target.firstChild) {\r\n\t      before(el, target.firstChild);\r\n\t    } else {\r\n\t      target.appendChild(el);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Replace target with el\r\n\t   *\r\n\t   * @param {Element} target\r\n\t   * @param {Element} el\r\n\t   */\r\n\t\r\n\t  function replace(target, el) {\r\n\t    var parent = target.parentNode;\r\n\t    if (parent) {\r\n\t      parent.replaceChild(el, target);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Add event listener shorthand.\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @param {String} event\r\n\t   * @param {Function} cb\r\n\t   * @param {Boolean} [useCapture]\r\n\t   */\r\n\t\r\n\t  function on(el, event, cb, useCapture) {\r\n\t    el.addEventListener(event, cb, useCapture);\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Remove event listener shorthand.\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @param {String} event\r\n\t   * @param {Function} cb\r\n\t   */\r\n\t\r\n\t  function off(el, event, cb) {\r\n\t    el.removeEventListener(event, cb);\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * For IE9 compat: when both class and :class are present\r\n\t   * getAttribute('class') returns wrong value...\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @return {String}\r\n\t   */\r\n\t\r\n\t  function getClass(el) {\r\n\t    var classname = el.className;\r\n\t    if (typeof classname === 'object') {\r\n\t      classname = classname.baseVal || '';\r\n\t    }\r\n\t    return classname;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * In IE9, setAttribute('class') will result in empty class\r\n\t   * if the element also has the :class attribute; However in\r\n\t   * PhantomJS, setting `className` does not work on SVG elements...\r\n\t   * So we have to do a conditional check here.\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @param {String} cls\r\n\t   */\r\n\t\r\n\t  function setClass(el, cls) {\r\n\t    /* istanbul ignore if */\r\n\t    if (isIE9 && !/svg$/.test(el.namespaceURI)) {\r\n\t      el.className = cls;\r\n\t    } else {\r\n\t      el.setAttribute('class', cls);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Add class with compatibility for IE & SVG\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @param {String} cls\r\n\t   */\r\n\t\r\n\t  function addClass(el, cls) {\r\n\t    if (el.classList) {\r\n\t      el.classList.add(cls);\r\n\t    } else {\r\n\t      var cur = ' ' + getClass(el) + ' ';\r\n\t      if (cur.indexOf(' ' + cls + ' ') < 0) {\r\n\t        setClass(el, (cur + cls).trim());\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Remove class with compatibility for IE & SVG\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @param {String} cls\r\n\t   */\r\n\t\r\n\t  function removeClass(el, cls) {\r\n\t    if (el.classList) {\r\n\t      el.classList.remove(cls);\r\n\t    } else {\r\n\t      var cur = ' ' + getClass(el) + ' ';\r\n\t      var tar = ' ' + cls + ' ';\r\n\t      while (cur.indexOf(tar) >= 0) {\r\n\t        cur = cur.replace(tar, ' ');\r\n\t      }\r\n\t      setClass(el, cur.trim());\r\n\t    }\r\n\t    if (!el.className) {\r\n\t      el.removeAttribute('class');\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Extract raw content inside an element into a temporary\r\n\t   * container div\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @param {Boolean} asFragment\r\n\t   * @return {Element|DocumentFragment}\r\n\t   */\r\n\t\r\n\t  function extractContent(el, asFragment) {\r\n\t    var child;\r\n\t    var rawContent;\r\n\t    /* istanbul ignore if */\r\n\t    if (isTemplate(el) && isFragment(el.content)) {\r\n\t      el = el.content;\r\n\t    }\r\n\t    if (el.hasChildNodes()) {\r\n\t      trimNode(el);\r\n\t      rawContent = asFragment ? document.createDocumentFragment() : document.createElement('div');\r\n\t      /* eslint-disable no-cond-assign */\r\n\t      while (child = el.firstChild) {\r\n\t        /* eslint-enable no-cond-assign */\r\n\t        rawContent.appendChild(child);\r\n\t      }\r\n\t    }\r\n\t    return rawContent;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Trim possible empty head/tail text and comment\r\n\t   * nodes inside a parent.\r\n\t   *\r\n\t   * @param {Node} node\r\n\t   */\r\n\t\r\n\t  function trimNode(node) {\r\n\t    var child;\r\n\t    /* eslint-disable no-sequences */\r\n\t    while ((child = node.firstChild, isTrimmable(child))) {\r\n\t      node.removeChild(child);\r\n\t    }\r\n\t    while ((child = node.lastChild, isTrimmable(child))) {\r\n\t      node.removeChild(child);\r\n\t    }\r\n\t    /* eslint-enable no-sequences */\r\n\t  }\r\n\t\r\n\t  function isTrimmable(node) {\r\n\t    return node && (node.nodeType === 3 && !node.data.trim() || node.nodeType === 8);\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Check if an element is a template tag.\r\n\t   * Note if the template appears inside an SVG its tagName\r\n\t   * will be in lowercase.\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   */\r\n\t\r\n\t  function isTemplate(el) {\r\n\t    return el.tagName && el.tagName.toLowerCase() === 'template';\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Create an \"anchor\" for performing dom insertion/removals.\r\n\t   * This is used in a number of scenarios:\r\n\t   * - fragment instance\r\n\t   * - v-html\r\n\t   * - v-if\r\n\t   * - v-for\r\n\t   * - component\r\n\t   *\r\n\t   * @param {String} content\r\n\t   * @param {Boolean} persist - IE trashes empty textNodes on\r\n\t   *                            cloneNode(true), so in certain\r\n\t   *                            cases the anchor needs to be\r\n\t   *                            non-empty to be persisted in\r\n\t   *                            templates.\r\n\t   * @return {Comment|Text}\r\n\t   */\r\n\t\r\n\t  function createAnchor(content, persist) {\r\n\t    var anchor = config.debug ? document.createComment(content) : document.createTextNode(persist ? ' ' : '');\r\n\t    anchor.__v_anchor = true;\r\n\t    return anchor;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Find a component ref attribute that starts with $.\r\n\t   *\r\n\t   * @param {Element} node\r\n\t   * @return {String|undefined}\r\n\t   */\r\n\t\r\n\t  var refRE = /^v-ref:/;\r\n\t\r\n\t  function findRef(node) {\r\n\t    if (node.hasAttributes()) {\r\n\t      var attrs = node.attributes;\r\n\t      for (var i = 0, l = attrs.length; i < l; i++) {\r\n\t        var name = attrs[i].name;\r\n\t        if (refRE.test(name)) {\r\n\t          return camelize(name.replace(refRE, ''));\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Map a function to a range of nodes .\r\n\t   *\r\n\t   * @param {Node} node\r\n\t   * @param {Node} end\r\n\t   * @param {Function} op\r\n\t   */\r\n\t\r\n\t  function mapNodeRange(node, end, op) {\r\n\t    var next;\r\n\t    while (node !== end) {\r\n\t      next = node.nextSibling;\r\n\t      op(node);\r\n\t      node = next;\r\n\t    }\r\n\t    op(end);\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Remove a range of nodes with transition, store\r\n\t   * the nodes in a fragment with correct ordering,\r\n\t   * and call callback when done.\r\n\t   *\r\n\t   * @param {Node} start\r\n\t   * @param {Node} end\r\n\t   * @param {Vue} vm\r\n\t   * @param {DocumentFragment} frag\r\n\t   * @param {Function} cb\r\n\t   */\r\n\t\r\n\t  function removeNodeRange(start, end, vm, frag, cb) {\r\n\t    var done = false;\r\n\t    var removed = 0;\r\n\t    var nodes = [];\r\n\t    mapNodeRange(start, end, function (node) {\r\n\t      if (node === end) done = true;\r\n\t      nodes.push(node);\r\n\t      removeWithTransition(node, vm, onRemoved);\r\n\t    });\r\n\t    function onRemoved() {\r\n\t      removed++;\r\n\t      if (done && removed >= nodes.length) {\r\n\t        for (var i = 0; i < nodes.length; i++) {\r\n\t          frag.appendChild(nodes[i]);\r\n\t        }\r\n\t        cb && cb();\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Check if a node is a DocumentFragment.\r\n\t   *\r\n\t   * @param {Node} node\r\n\t   * @return {Boolean}\r\n\t   */\r\n\t\r\n\t  function isFragment(node) {\r\n\t    return node && node.nodeType === 11;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Get outerHTML of elements, taking care\r\n\t   * of SVG elements in IE as well.\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @return {String}\r\n\t   */\r\n\t\r\n\t  function getOuterHTML(el) {\r\n\t    if (el.outerHTML) {\r\n\t      return el.outerHTML;\r\n\t    } else {\r\n\t      var container = document.createElement('div');\r\n\t      container.appendChild(el.cloneNode(true));\r\n\t      return container.innerHTML;\r\n\t    }\r\n\t  }\r\n\t\r\n\t  var commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i;\r\n\t  var reservedTagRE = /^(slot|partial|component)$/i;\r\n\t\r\n\t  var isUnknownElement = undefined;\r\n\t  if (true) {\r\n\t    isUnknownElement = function (el, tag) {\r\n\t      if (tag.indexOf('-') > -1) {\r\n\t        // http://stackoverflow.com/a/28210364/1070244\r\n\t        return el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\r\n\t      } else {\r\n\t        return (/HTMLUnknownElement/.test(el.toString()) &&\r\n\t          // Chrome returns unknown for several HTML5 elements.\r\n\t          // https://code.google.com/p/chromium/issues/detail?id=540526\r\n\t          // Firefox returns unknown for some \"Interactive elements.\"\r\n\t          !/^(data|time|rtc|rb|details|dialog|summary)$/.test(tag)\r\n\t        );\r\n\t      }\r\n\t    };\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Check if an element is a component, if yes return its\r\n\t   * component id.\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @param {Object} options\r\n\t   * @return {Object|undefined}\r\n\t   */\r\n\t\r\n\t  function checkComponentAttr(el, options) {\r\n\t    var tag = el.tagName.toLowerCase();\r\n\t    var hasAttrs = el.hasAttributes();\r\n\t    if (!commonTagRE.test(tag) && !reservedTagRE.test(tag)) {\r\n\t      if (resolveAsset(options, 'components', tag)) {\r\n\t        return { id: tag };\r\n\t      } else {\r\n\t        var is = hasAttrs && getIsBinding(el, options);\r\n\t        if (is) {\r\n\t          return is;\r\n\t        } else if (true) {\r\n\t          var expectedTag = options._componentNameMap && options._componentNameMap[tag];\r\n\t          if (expectedTag) {\r\n\t            warn('Unknown custom element: <' + tag + '> - ' + 'did you mean <' + expectedTag + '>? ' + 'HTML is case-insensitive, remember to use kebab-case in templates.');\r\n\t          } else if (isUnknownElement(el, tag)) {\r\n\t            warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.');\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t    } else if (hasAttrs) {\r\n\t      return getIsBinding(el, options);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Get \"is\" binding from an element.\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @param {Object} options\r\n\t   * @return {Object|undefined}\r\n\t   */\r\n\t\r\n\t  function getIsBinding(el, options) {\r\n\t    // dynamic syntax\r\n\t    var exp = el.getAttribute('is');\r\n\t    if (exp != null) {\r\n\t      if (resolveAsset(options, 'components', exp)) {\r\n\t        el.removeAttribute('is');\r\n\t        return { id: exp };\r\n\t      }\r\n\t    } else {\r\n\t      exp = getBindAttr(el, 'is');\r\n\t      if (exp != null) {\r\n\t        return { id: exp, dynamic: true };\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Option overwriting strategies are functions that handle\r\n\t   * how to merge a parent option value and a child option\r\n\t   * value into the final value.\r\n\t   *\r\n\t   * All strategy functions follow the same signature:\r\n\t   *\r\n\t   * @param {*} parentVal\r\n\t   * @param {*} childVal\r\n\t   * @param {Vue} [vm]\r\n\t   */\r\n\t\r\n\t  var strats = config.optionMergeStrategies = Object.create(null);\r\n\t\r\n\t  /**\r\n\t   * Helper that recursively merges two data objects together.\r\n\t   */\r\n\t\r\n\t  function mergeData(to, from) {\r\n\t    var key, toVal, fromVal;\r\n\t    for (key in from) {\r\n\t      toVal = to[key];\r\n\t      fromVal = from[key];\r\n\t      if (!hasOwn(to, key)) {\r\n\t        set(to, key, fromVal);\r\n\t      } else if (isObject(toVal) && isObject(fromVal)) {\r\n\t        mergeData(toVal, fromVal);\r\n\t      }\r\n\t    }\r\n\t    return to;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Data\r\n\t   */\r\n\t\r\n\t  strats.data = function (parentVal, childVal, vm) {\r\n\t    if (!vm) {\r\n\t      // in a Vue.extend merge, both should be functions\r\n\t      if (!childVal) {\r\n\t        return parentVal;\r\n\t      }\r\n\t      if (typeof childVal !== 'function') {\r\n\t        'development' !== 'production' && warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\r\n\t        return parentVal;\r\n\t      }\r\n\t      if (!parentVal) {\r\n\t        return childVal;\r\n\t      }\r\n\t      // when parentVal & childVal are both present,\r\n\t      // we need to return a function that returns the\r\n\t      // merged result of both functions... no need to\r\n\t      // check if parentVal is a function here because\r\n\t      // it has to be a function to pass previous merges.\r\n\t      return function mergedDataFn() {\r\n\t        return mergeData(childVal.call(this), parentVal.call(this));\r\n\t      };\r\n\t    } else if (parentVal || childVal) {\r\n\t      return function mergedInstanceDataFn() {\r\n\t        // instance merge\r\n\t        var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;\r\n\t        var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;\r\n\t        if (instanceData) {\r\n\t          return mergeData(instanceData, defaultData);\r\n\t        } else {\r\n\t          return defaultData;\r\n\t        }\r\n\t      };\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * El\r\n\t   */\r\n\t\r\n\t  strats.el = function (parentVal, childVal, vm) {\r\n\t    if (!vm && childVal && typeof childVal !== 'function') {\r\n\t      'development' !== 'production' && warn('The \"el\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\r\n\t      return;\r\n\t    }\r\n\t    var ret = childVal || parentVal;\r\n\t    // invoke the element factory if this is instance merge\r\n\t    return vm && typeof ret === 'function' ? ret.call(vm) : ret;\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Hooks and param attributes are merged as arrays.\r\n\t   */\r\n\t\r\n\t  strats.init = strats.created = strats.ready = strats.attached = strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy = strats.destroyed = strats.activate = function (parentVal, childVal) {\r\n\t    return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Assets\r\n\t   *\r\n\t   * When a vm is present (instance creation), we need to do\r\n\t   * a three-way merge between constructor options, instance\r\n\t   * options and parent options.\r\n\t   */\r\n\t\r\n\t  function mergeAssets(parentVal, childVal) {\r\n\t    var res = Object.create(parentVal || null);\r\n\t    return childVal ? extend(res, guardArrayAssets(childVal)) : res;\r\n\t  }\r\n\t\r\n\t  config._assetTypes.forEach(function (type) {\r\n\t    strats[type + 's'] = mergeAssets;\r\n\t  });\r\n\t\r\n\t  /**\r\n\t   * Events & Watchers.\r\n\t   *\r\n\t   * Events & watchers hashes should not overwrite one\r\n\t   * another, so we merge them as arrays.\r\n\t   */\r\n\t\r\n\t  strats.watch = strats.events = function (parentVal, childVal) {\r\n\t    if (!childVal) return parentVal;\r\n\t    if (!parentVal) return childVal;\r\n\t    var ret = {};\r\n\t    extend(ret, parentVal);\r\n\t    for (var key in childVal) {\r\n\t      var parent = ret[key];\r\n\t      var child = childVal[key];\r\n\t      if (parent && !isArray(parent)) {\r\n\t        parent = [parent];\r\n\t      }\r\n\t      ret[key] = parent ? parent.concat(child) : [child];\r\n\t    }\r\n\t    return ret;\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Other object hashes.\r\n\t   */\r\n\t\r\n\t  strats.props = strats.methods = strats.computed = function (parentVal, childVal) {\r\n\t    if (!childVal) return parentVal;\r\n\t    if (!parentVal) return childVal;\r\n\t    var ret = Object.create(null);\r\n\t    extend(ret, parentVal);\r\n\t    extend(ret, childVal);\r\n\t    return ret;\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Default strategy.\r\n\t   */\r\n\t\r\n\t  var defaultStrat = function defaultStrat(parentVal, childVal) {\r\n\t    return childVal === undefined ? parentVal : childVal;\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Make sure component options get converted to actual\r\n\t   * constructors.\r\n\t   *\r\n\t   * @param {Object} options\r\n\t   */\r\n\t\r\n\t  function guardComponents(options) {\r\n\t    if (options.components) {\r\n\t      var components = options.components = guardArrayAssets(options.components);\r\n\t      var ids = Object.keys(components);\r\n\t      var def;\r\n\t      if (true) {\r\n\t        var map = options._componentNameMap = {};\r\n\t      }\r\n\t      for (var i = 0, l = ids.length; i < l; i++) {\r\n\t        var key = ids[i];\r\n\t        if (commonTagRE.test(key) || reservedTagRE.test(key)) {\r\n\t          'development' !== 'production' && warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);\r\n\t          continue;\r\n\t        }\r\n\t        // record a all lowercase <-> kebab-case mapping for\r\n\t        // possible custom element case error warning\r\n\t        if (true) {\r\n\t          map[key.replace(/-/g, '').toLowerCase()] = hyphenate(key);\r\n\t        }\r\n\t        def = components[key];\r\n\t        if (isPlainObject(def)) {\r\n\t          components[key] = Vue.extend(def);\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Ensure all props option syntax are normalized into the\r\n\t   * Object-based format.\r\n\t   *\r\n\t   * @param {Object} options\r\n\t   */\r\n\t\r\n\t  function guardProps(options) {\r\n\t    var props = options.props;\r\n\t    var i, val;\r\n\t    if (isArray(props)) {\r\n\t      options.props = {};\r\n\t      i = props.length;\r\n\t      while (i--) {\r\n\t        val = props[i];\r\n\t        if (typeof val === 'string') {\r\n\t          options.props[val] = null;\r\n\t        } else if (val.name) {\r\n\t          options.props[val.name] = val;\r\n\t        }\r\n\t      }\r\n\t    } else if (isPlainObject(props)) {\r\n\t      var keys = Object.keys(props);\r\n\t      i = keys.length;\r\n\t      while (i--) {\r\n\t        val = props[keys[i]];\r\n\t        if (typeof val === 'function') {\r\n\t          props[keys[i]] = { type: val };\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Guard an Array-format assets option and converted it\r\n\t   * into the key-value Object format.\r\n\t   *\r\n\t   * @param {Object|Array} assets\r\n\t   * @return {Object}\r\n\t   */\r\n\t\r\n\t  function guardArrayAssets(assets) {\r\n\t    if (isArray(assets)) {\r\n\t      var res = {};\r\n\t      var i = assets.length;\r\n\t      var asset;\r\n\t      while (i--) {\r\n\t        asset = assets[i];\r\n\t        var id = typeof asset === 'function' ? asset.options && asset.options.name || asset.id : asset.name || asset.id;\r\n\t        if (!id) {\r\n\t          'development' !== 'production' && warn('Array-syntax assets must provide a \"name\" or \"id\" field.');\r\n\t        } else {\r\n\t          res[id] = asset;\r\n\t        }\r\n\t      }\r\n\t      return res;\r\n\t    }\r\n\t    return assets;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Merge two option objects into a new one.\r\n\t   * Core utility used in both instantiation and inheritance.\r\n\t   *\r\n\t   * @param {Object} parent\r\n\t   * @param {Object} child\r\n\t   * @param {Vue} [vm] - if vm is present, indicates this is\r\n\t   *                     an instantiation merge.\r\n\t   */\r\n\t\r\n\t  function mergeOptions(parent, child, vm) {\r\n\t    guardComponents(child);\r\n\t    guardProps(child);\r\n\t    if (true) {\r\n\t      if (child.propsData && !vm) {\r\n\t        warn('propsData can only be used as an instantiation option.');\r\n\t      }\r\n\t    }\r\n\t    var options = {};\r\n\t    var key;\r\n\t    if (child['extends']) {\r\n\t      parent = typeof child['extends'] === 'function' ? mergeOptions(parent, child['extends'].options, vm) : mergeOptions(parent, child['extends'], vm);\r\n\t    }\r\n\t    if (child.mixins) {\r\n\t      for (var i = 0, l = child.mixins.length; i < l; i++) {\r\n\t        var mixin = child.mixins[i];\r\n\t        var mixinOptions = mixin.prototype instanceof Vue ? mixin.options : mixin;\r\n\t        parent = mergeOptions(parent, mixinOptions, vm);\r\n\t      }\r\n\t    }\r\n\t    for (key in parent) {\r\n\t      mergeField(key);\r\n\t    }\r\n\t    for (key in child) {\r\n\t      if (!hasOwn(parent, key)) {\r\n\t        mergeField(key);\r\n\t      }\r\n\t    }\r\n\t    function mergeField(key) {\r\n\t      var strat = strats[key] || defaultStrat;\r\n\t      options[key] = strat(parent[key], child[key], vm, key);\r\n\t    }\r\n\t    return options;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Resolve an asset.\r\n\t   * This function is used because child instances need access\r\n\t   * to assets defined in its ancestor chain.\r\n\t   *\r\n\t   * @param {Object} options\r\n\t   * @param {String} type\r\n\t   * @param {String} id\r\n\t   * @param {Boolean} warnMissing\r\n\t   * @return {Object|Function}\r\n\t   */\r\n\t\r\n\t  function resolveAsset(options, type, id, warnMissing) {\r\n\t    /* istanbul ignore if */\r\n\t    if (typeof id !== 'string') {\r\n\t      return;\r\n\t    }\r\n\t    var assets = options[type];\r\n\t    var camelizedId;\r\n\t    var res = assets[id] ||\r\n\t    // camelCase ID\r\n\t    assets[camelizedId = camelize(id)] ||\r\n\t    // Pascal Case ID\r\n\t    assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)];\r\n\t    if ('development' !== 'production' && warnMissing && !res) {\r\n\t      warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\r\n\t    }\r\n\t    return res;\r\n\t  }\r\n\t\r\n\t  var uid$1 = 0;\r\n\t\r\n\t  /**\r\n\t   * A dep is an observable that can have multiple\r\n\t   * directives subscribing to it.\r\n\t   *\r\n\t   * @constructor\r\n\t   */\r\n\t  function Dep() {\r\n\t    this.id = uid$1++;\r\n\t    this.subs = [];\r\n\t  }\r\n\t\r\n\t  // the current target watcher being evaluated.\r\n\t  // this is globally unique because there could be only one\r\n\t  // watcher being evaluated at any time.\r\n\t  Dep.target = null;\r\n\t\r\n\t  /**\r\n\t   * Add a directive subscriber.\r\n\t   *\r\n\t   * @param {Directive} sub\r\n\t   */\r\n\t\r\n\t  Dep.prototype.addSub = function (sub) {\r\n\t    this.subs.push(sub);\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Remove a directive subscriber.\r\n\t   *\r\n\t   * @param {Directive} sub\r\n\t   */\r\n\t\r\n\t  Dep.prototype.removeSub = function (sub) {\r\n\t    this.subs.$remove(sub);\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Add self as a dependency to the target watcher.\r\n\t   */\r\n\t\r\n\t  Dep.prototype.depend = function () {\r\n\t    Dep.target.addDep(this);\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Notify all subscribers of a new value.\r\n\t   */\r\n\t\r\n\t  Dep.prototype.notify = function () {\r\n\t    // stablize the subscriber list first\r\n\t    var subs = toArray(this.subs);\r\n\t    for (var i = 0, l = subs.length; i < l; i++) {\r\n\t      subs[i].update();\r\n\t    }\r\n\t  };\r\n\t\r\n\t  var arrayProto = Array.prototype;\r\n\t  var arrayMethods = Object.create(arrayProto)\r\n\t\r\n\t  /**\r\n\t   * Intercept mutating methods and emit events\r\n\t   */\r\n\t\r\n\t  ;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {\r\n\t    // cache original method\r\n\t    var original = arrayProto[method];\r\n\t    def(arrayMethods, method, function mutator() {\r\n\t      // avoid leaking arguments:\r\n\t      // http://jsperf.com/closure-with-arguments\r\n\t      var i = arguments.length;\r\n\t      var args = new Array(i);\r\n\t      while (i--) {\r\n\t        args[i] = arguments[i];\r\n\t      }\r\n\t      var result = original.apply(this, args);\r\n\t      var ob = this.__ob__;\r\n\t      var inserted;\r\n\t      switch (method) {\r\n\t        case 'push':\r\n\t          inserted = args;\r\n\t          break;\r\n\t        case 'unshift':\r\n\t          inserted = args;\r\n\t          break;\r\n\t        case 'splice':\r\n\t          inserted = args.slice(2);\r\n\t          break;\r\n\t      }\r\n\t      if (inserted) ob.observeArray(inserted);\r\n\t      // notify change\r\n\t      ob.dep.notify();\r\n\t      return result;\r\n\t    });\r\n\t  });\r\n\t\r\n\t  /**\r\n\t   * Swap the element at the given index with a new value\r\n\t   * and emits corresponding event.\r\n\t   *\r\n\t   * @param {Number} index\r\n\t   * @param {*} val\r\n\t   * @return {*} - replaced element\r\n\t   */\r\n\t\r\n\t  def(arrayProto, '$set', function $set(index, val) {\r\n\t    if (index >= this.length) {\r\n\t      this.length = Number(index) + 1;\r\n\t    }\r\n\t    return this.splice(index, 1, val)[0];\r\n\t  });\r\n\t\r\n\t  /**\r\n\t   * Convenience method to remove the element at given index or target element reference.\r\n\t   *\r\n\t   * @param {*} item\r\n\t   */\r\n\t\r\n\t  def(arrayProto, '$remove', function $remove(item) {\r\n\t    /* istanbul ignore if */\r\n\t    if (!this.length) return;\r\n\t    var index = indexOf(this, item);\r\n\t    if (index > -1) {\r\n\t      return this.splice(index, 1);\r\n\t    }\r\n\t  });\r\n\t\r\n\t  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);\r\n\t\r\n\t  /**\r\n\t   * By default, when a reactive property is set, the new value is\r\n\t   * also converted to become reactive. However in certain cases, e.g.\r\n\t   * v-for scope alias and props, we don't want to force conversion\r\n\t   * because the value may be a nested value under a frozen data structure.\r\n\t   *\r\n\t   * So whenever we want to set a reactive property without forcing\r\n\t   * conversion on the new value, we wrap that call inside this function.\r\n\t   */\r\n\t\r\n\t  var shouldConvert = true;\r\n\t\r\n\t  function withoutConversion(fn) {\r\n\t    shouldConvert = false;\r\n\t    fn();\r\n\t    shouldConvert = true;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Observer class that are attached to each observed\r\n\t   * object. Once attached, the observer converts target\r\n\t   * object's property keys into getter/setters that\r\n\t   * collect dependencies and dispatches updates.\r\n\t   *\r\n\t   * @param {Array|Object} value\r\n\t   * @constructor\r\n\t   */\r\n\t\r\n\t  function Observer(value) {\r\n\t    this.value = value;\r\n\t    this.dep = new Dep();\r\n\t    def(value, '__ob__', this);\r\n\t    if (isArray(value)) {\r\n\t      var augment = hasProto ? protoAugment : copyAugment;\r\n\t      augment(value, arrayMethods, arrayKeys);\r\n\t      this.observeArray(value);\r\n\t    } else {\r\n\t      this.walk(value);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  // Instance methods\r\n\t\r\n\t  /**\r\n\t   * Walk through each property and convert them into\r\n\t   * getter/setters. This method should only be called when\r\n\t   * value type is Object.\r\n\t   *\r\n\t   * @param {Object} obj\r\n\t   */\r\n\t\r\n\t  Observer.prototype.walk = function (obj) {\r\n\t    var keys = Object.keys(obj);\r\n\t    for (var i = 0, l = keys.length; i < l; i++) {\r\n\t      this.convert(keys[i], obj[keys[i]]);\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Observe a list of Array items.\r\n\t   *\r\n\t   * @param {Array} items\r\n\t   */\r\n\t\r\n\t  Observer.prototype.observeArray = function (items) {\r\n\t    for (var i = 0, l = items.length; i < l; i++) {\r\n\t      observe(items[i]);\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Convert a property into getter/setter so we can emit\r\n\t   * the events when the property is accessed/changed.\r\n\t   *\r\n\t   * @param {String} key\r\n\t   * @param {*} val\r\n\t   */\r\n\t\r\n\t  Observer.prototype.convert = function (key, val) {\r\n\t    defineReactive(this.value, key, val);\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Add an owner vm, so that when $set/$delete mutations\r\n\t   * happen we can notify owner vms to proxy the keys and\r\n\t   * digest the watchers. This is only called when the object\r\n\t   * is observed as an instance's root $data.\r\n\t   *\r\n\t   * @param {Vue} vm\r\n\t   */\r\n\t\r\n\t  Observer.prototype.addVm = function (vm) {\r\n\t    (this.vms || (this.vms = [])).push(vm);\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Remove an owner vm. This is called when the object is\r\n\t   * swapped out as an instance's $data object.\r\n\t   *\r\n\t   * @param {Vue} vm\r\n\t   */\r\n\t\r\n\t  Observer.prototype.removeVm = function (vm) {\r\n\t    this.vms.$remove(vm);\r\n\t  };\r\n\t\r\n\t  // helpers\r\n\t\r\n\t  /**\r\n\t   * Augment an target Object or Array by intercepting\r\n\t   * the prototype chain using __proto__\r\n\t   *\r\n\t   * @param {Object|Array} target\r\n\t   * @param {Object} src\r\n\t   */\r\n\t\r\n\t  function protoAugment(target, src) {\r\n\t    /* eslint-disable no-proto */\r\n\t    target.__proto__ = src;\r\n\t    /* eslint-enable no-proto */\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Augment an target Object or Array by defining\r\n\t   * hidden properties.\r\n\t   *\r\n\t   * @param {Object|Array} target\r\n\t   * @param {Object} proto\r\n\t   */\r\n\t\r\n\t  function copyAugment(target, src, keys) {\r\n\t    for (var i = 0, l = keys.length; i < l; i++) {\r\n\t      var key = keys[i];\r\n\t      def(target, key, src[key]);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Attempt to create an observer instance for a value,\r\n\t   * returns the new observer if successfully observed,\r\n\t   * or the existing observer if the value already has one.\r\n\t   *\r\n\t   * @param {*} value\r\n\t   * @param {Vue} [vm]\r\n\t   * @return {Observer|undefined}\r\n\t   * @static\r\n\t   */\r\n\t\r\n\t  function observe(value, vm) {\r\n\t    if (!value || typeof value !== 'object') {\r\n\t      return;\r\n\t    }\r\n\t    var ob;\r\n\t    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\r\n\t      ob = value.__ob__;\r\n\t    } else if (shouldConvert && (isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\r\n\t      ob = new Observer(value);\r\n\t    }\r\n\t    if (ob && vm) {\r\n\t      ob.addVm(vm);\r\n\t    }\r\n\t    return ob;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Define a reactive property on an Object.\r\n\t   *\r\n\t   * @param {Object} obj\r\n\t   * @param {String} key\r\n\t   * @param {*} val\r\n\t   */\r\n\t\r\n\t  function defineReactive(obj, key, val) {\r\n\t    var dep = new Dep();\r\n\t\r\n\t    var property = Object.getOwnPropertyDescriptor(obj, key);\r\n\t    if (property && property.configurable === false) {\r\n\t      return;\r\n\t    }\r\n\t\r\n\t    // cater for pre-defined getter/setters\r\n\t    var getter = property && property.get;\r\n\t    var setter = property && property.set;\r\n\t\r\n\t    var childOb = observe(val);\r\n\t    Object.defineProperty(obj, key, {\r\n\t      enumerable: true,\r\n\t      configurable: true,\r\n\t      get: function reactiveGetter() {\r\n\t        var value = getter ? getter.call(obj) : val;\r\n\t        if (Dep.target) {\r\n\t          dep.depend();\r\n\t          if (childOb) {\r\n\t            childOb.dep.depend();\r\n\t          }\r\n\t          if (isArray(value)) {\r\n\t            for (var e, i = 0, l = value.length; i < l; i++) {\r\n\t              e = value[i];\r\n\t              e && e.__ob__ && e.__ob__.dep.depend();\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t        return value;\r\n\t      },\r\n\t      set: function reactiveSetter(newVal) {\r\n\t        var value = getter ? getter.call(obj) : val;\r\n\t        if (newVal === value) {\r\n\t          return;\r\n\t        }\r\n\t        if (setter) {\r\n\t          setter.call(obj, newVal);\r\n\t        } else {\r\n\t          val = newVal;\r\n\t        }\r\n\t        childOb = observe(newVal);\r\n\t        dep.notify();\r\n\t      }\r\n\t    });\r\n\t  }\r\n\t\r\n\t\r\n\t\r\n\t  var util = Object.freeze({\r\n\t  \tdefineReactive: defineReactive,\r\n\t  \tset: set,\r\n\t  \tdel: del,\r\n\t  \thasOwn: hasOwn,\r\n\t  \tisLiteral: isLiteral,\r\n\t  \tisReserved: isReserved,\r\n\t  \t_toString: _toString,\r\n\t  \ttoNumber: toNumber,\r\n\t  \ttoBoolean: toBoolean,\r\n\t  \tstripQuotes: stripQuotes,\r\n\t  \tcamelize: camelize,\r\n\t  \thyphenate: hyphenate,\r\n\t  \tclassify: classify,\r\n\t  \tbind: bind,\r\n\t  \ttoArray: toArray,\r\n\t  \textend: extend,\r\n\t  \tisObject: isObject,\r\n\t  \tisPlainObject: isPlainObject,\r\n\t  \tdef: def,\r\n\t  \tdebounce: _debounce,\r\n\t  \tindexOf: indexOf,\r\n\t  \tcancellable: cancellable,\r\n\t  \tlooseEqual: looseEqual,\r\n\t  \tisArray: isArray,\r\n\t  \thasProto: hasProto,\r\n\t  \tinBrowser: inBrowser,\r\n\t  \tdevtools: devtools,\r\n\t  \tisIE: isIE,\r\n\t  \tisIE9: isIE9,\r\n\t  \tisAndroid: isAndroid,\r\n\t  \tisIos: isIos,\r\n\t  \tiosVersionMatch: iosVersionMatch,\r\n\t  \tiosVersion: iosVersion,\r\n\t  \thasMutationObserverBug: hasMutationObserverBug,\r\n\t  \tget transitionProp () { return transitionProp; },\r\n\t  \tget transitionEndEvent () { return transitionEndEvent; },\r\n\t  \tget animationProp () { return animationProp; },\r\n\t  \tget animationEndEvent () { return animationEndEvent; },\r\n\t  \tnextTick: nextTick,\r\n\t  \tget _Set () { return _Set; },\r\n\t  \tquery: query,\r\n\t  \tinDoc: inDoc,\r\n\t  \tgetAttr: getAttr,\r\n\t  \tgetBindAttr: getBindAttr,\r\n\t  \thasBindAttr: hasBindAttr,\r\n\t  \tbefore: before,\r\n\t  \tafter: after,\r\n\t  \tremove: remove,\r\n\t  \tprepend: prepend,\r\n\t  \treplace: replace,\r\n\t  \ton: on,\r\n\t  \toff: off,\r\n\t  \tsetClass: setClass,\r\n\t  \taddClass: addClass,\r\n\t  \tremoveClass: removeClass,\r\n\t  \textractContent: extractContent,\r\n\t  \ttrimNode: trimNode,\r\n\t  \tisTemplate: isTemplate,\r\n\t  \tcreateAnchor: createAnchor,\r\n\t  \tfindRef: findRef,\r\n\t  \tmapNodeRange: mapNodeRange,\r\n\t  \tremoveNodeRange: removeNodeRange,\r\n\t  \tisFragment: isFragment,\r\n\t  \tgetOuterHTML: getOuterHTML,\r\n\t  \tmergeOptions: mergeOptions,\r\n\t  \tresolveAsset: resolveAsset,\r\n\t  \tcheckComponentAttr: checkComponentAttr,\r\n\t  \tcommonTagRE: commonTagRE,\r\n\t  \treservedTagRE: reservedTagRE,\r\n\t  \tget warn () { return warn; }\r\n\t  });\r\n\t\r\n\t  var uid = 0;\r\n\t\r\n\t  function initMixin (Vue) {\r\n\t    /**\r\n\t     * The main init sequence. This is called for every\r\n\t     * instance, including ones that are created from extended\r\n\t     * constructors.\r\n\t     *\r\n\t     * @param {Object} options - this options object should be\r\n\t     *                           the result of merging class\r\n\t     *                           options and the options passed\r\n\t     *                           in to the constructor.\r\n\t     */\r\n\t\r\n\t    Vue.prototype._init = function (options) {\r\n\t      options = options || {};\r\n\t\r\n\t      this.$el = null;\r\n\t      this.$parent = options.parent;\r\n\t      this.$root = this.$parent ? this.$parent.$root : this;\r\n\t      this.$children = [];\r\n\t      this.$refs = {}; // child vm references\r\n\t      this.$els = {}; // element references\r\n\t      this._watchers = []; // all watchers as an array\r\n\t      this._directives = []; // all directives\r\n\t\r\n\t      // a uid\r\n\t      this._uid = uid++;\r\n\t\r\n\t      // a flag to avoid this being observed\r\n\t      this._isVue = true;\r\n\t\r\n\t      // events bookkeeping\r\n\t      this._events = {}; // registered callbacks\r\n\t      this._eventsCount = {}; // for $broadcast optimization\r\n\t\r\n\t      // fragment instance properties\r\n\t      this._isFragment = false;\r\n\t      this._fragment = // @type {DocumentFragment}\r\n\t      this._fragmentStart = // @type {Text|Comment}\r\n\t      this._fragmentEnd = null; // @type {Text|Comment}\r\n\t\r\n\t      // lifecycle state\r\n\t      this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = this._vForRemoving = false;\r\n\t      this._unlinkFn = null;\r\n\t\r\n\t      // context:\r\n\t      // if this is a transcluded component, context\r\n\t      // will be the common parent vm of this instance\r\n\t      // and its host.\r\n\t      this._context = options._context || this.$parent;\r\n\t\r\n\t      // scope:\r\n\t      // if this is inside an inline v-for, the scope\r\n\t      // will be the intermediate scope created for this\r\n\t      // repeat fragment. this is used for linking props\r\n\t      // and container directives.\r\n\t      this._scope = options._scope;\r\n\t\r\n\t      // fragment:\r\n\t      // if this instance is compiled inside a Fragment, it\r\n\t      // needs to reigster itself as a child of that fragment\r\n\t      // for attach/detach to work properly.\r\n\t      this._frag = options._frag;\r\n\t      if (this._frag) {\r\n\t        this._frag.children.push(this);\r\n\t      }\r\n\t\r\n\t      // push self into parent / transclusion host\r\n\t      if (this.$parent) {\r\n\t        this.$parent.$children.push(this);\r\n\t      }\r\n\t\r\n\t      // merge options.\r\n\t      options = this.$options = mergeOptions(this.constructor.options, options, this);\r\n\t\r\n\t      // set ref\r\n\t      this._updateRef();\r\n\t\r\n\t      // initialize data as empty object.\r\n\t      // it will be filled up in _initData().\r\n\t      this._data = {};\r\n\t\r\n\t      // call init hook\r\n\t      this._callHook('init');\r\n\t\r\n\t      // initialize data observation and scope inheritance.\r\n\t      this._initState();\r\n\t\r\n\t      // setup event system and option events.\r\n\t      this._initEvents();\r\n\t\r\n\t      // call created hook\r\n\t      this._callHook('created');\r\n\t\r\n\t      // if `el` option is passed, start compilation.\r\n\t      if (options.el) {\r\n\t        this.$mount(options.el);\r\n\t      }\r\n\t    };\r\n\t  }\r\n\t\r\n\t  var pathCache = new Cache(1000);\r\n\t\r\n\t  // actions\r\n\t  var APPEND = 0;\r\n\t  var PUSH = 1;\r\n\t  var INC_SUB_PATH_DEPTH = 2;\r\n\t  var PUSH_SUB_PATH = 3;\r\n\t\r\n\t  // states\r\n\t  var BEFORE_PATH = 0;\r\n\t  var IN_PATH = 1;\r\n\t  var BEFORE_IDENT = 2;\r\n\t  var IN_IDENT = 3;\r\n\t  var IN_SUB_PATH = 4;\r\n\t  var IN_SINGLE_QUOTE = 5;\r\n\t  var IN_DOUBLE_QUOTE = 6;\r\n\t  var AFTER_PATH = 7;\r\n\t  var ERROR = 8;\r\n\t\r\n\t  var pathStateMachine = [];\r\n\t\r\n\t  pathStateMachine[BEFORE_PATH] = {\r\n\t    'ws': [BEFORE_PATH],\r\n\t    'ident': [IN_IDENT, APPEND],\r\n\t    '[': [IN_SUB_PATH],\r\n\t    'eof': [AFTER_PATH]\r\n\t  };\r\n\t\r\n\t  pathStateMachine[IN_PATH] = {\r\n\t    'ws': [IN_PATH],\r\n\t    '.': [BEFORE_IDENT],\r\n\t    '[': [IN_SUB_PATH],\r\n\t    'eof': [AFTER_PATH]\r\n\t  };\r\n\t\r\n\t  pathStateMachine[BEFORE_IDENT] = {\r\n\t    'ws': [BEFORE_IDENT],\r\n\t    'ident': [IN_IDENT, APPEND]\r\n\t  };\r\n\t\r\n\t  pathStateMachine[IN_IDENT] = {\r\n\t    'ident': [IN_IDENT, APPEND],\r\n\t    '0': [IN_IDENT, APPEND],\r\n\t    'number': [IN_IDENT, APPEND],\r\n\t    'ws': [IN_PATH, PUSH],\r\n\t    '.': [BEFORE_IDENT, PUSH],\r\n\t    '[': [IN_SUB_PATH, PUSH],\r\n\t    'eof': [AFTER_PATH, PUSH]\r\n\t  };\r\n\t\r\n\t  pathStateMachine[IN_SUB_PATH] = {\r\n\t    \"'\": [IN_SINGLE_QUOTE, APPEND],\r\n\t    '\"': [IN_DOUBLE_QUOTE, APPEND],\r\n\t    '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],\r\n\t    ']': [IN_PATH, PUSH_SUB_PATH],\r\n\t    'eof': ERROR,\r\n\t    'else': [IN_SUB_PATH, APPEND]\r\n\t  };\r\n\t\r\n\t  pathStateMachine[IN_SINGLE_QUOTE] = {\r\n\t    \"'\": [IN_SUB_PATH, APPEND],\r\n\t    'eof': ERROR,\r\n\t    'else': [IN_SINGLE_QUOTE, APPEND]\r\n\t  };\r\n\t\r\n\t  pathStateMachine[IN_DOUBLE_QUOTE] = {\r\n\t    '\"': [IN_SUB_PATH, APPEND],\r\n\t    'eof': ERROR,\r\n\t    'else': [IN_DOUBLE_QUOTE, APPEND]\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Determine the type of a character in a keypath.\r\n\t   *\r\n\t   * @param {Char} ch\r\n\t   * @return {String} type\r\n\t   */\r\n\t\r\n\t  function getPathCharType(ch) {\r\n\t    if (ch === undefined) {\r\n\t      return 'eof';\r\n\t    }\r\n\t\r\n\t    var code = ch.charCodeAt(0);\r\n\t\r\n\t    switch (code) {\r\n\t      case 0x5B: // [\r\n\t      case 0x5D: // ]\r\n\t      case 0x2E: // .\r\n\t      case 0x22: // \"\r\n\t      case 0x27: // '\r\n\t      case 0x30:\r\n\t        // 0\r\n\t        return ch;\r\n\t\r\n\t      case 0x5F: // _\r\n\t      case 0x24:\r\n\t        // $\r\n\t        return 'ident';\r\n\t\r\n\t      case 0x20: // Space\r\n\t      case 0x09: // Tab\r\n\t      case 0x0A: // Newline\r\n\t      case 0x0D: // Return\r\n\t      case 0xA0: // No-break space\r\n\t      case 0xFEFF: // Byte Order Mark\r\n\t      case 0x2028: // Line Separator\r\n\t      case 0x2029:\r\n\t        // Paragraph Separator\r\n\t        return 'ws';\r\n\t    }\r\n\t\r\n\t    // a-z, A-Z\r\n\t    if (code >= 0x61 && code <= 0x7A || code >= 0x41 && code <= 0x5A) {\r\n\t      return 'ident';\r\n\t    }\r\n\t\r\n\t    // 1-9\r\n\t    if (code >= 0x31 && code <= 0x39) {\r\n\t      return 'number';\r\n\t    }\r\n\t\r\n\t    return 'else';\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Format a subPath, return its plain form if it is\r\n\t   * a literal string or number. Otherwise prepend the\r\n\t   * dynamic indicator (*).\r\n\t   *\r\n\t   * @param {String} path\r\n\t   * @return {String}\r\n\t   */\r\n\t\r\n\t  function formatSubPath(path) {\r\n\t    var trimmed = path.trim();\r\n\t    // invalid leading 0\r\n\t    if (path.charAt(0) === '0' && isNaN(path)) {\r\n\t      return false;\r\n\t    }\r\n\t    return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Parse a string path into an array of segments\r\n\t   *\r\n\t   * @param {String} path\r\n\t   * @return {Array|undefined}\r\n\t   */\r\n\t\r\n\t  function parse(path) {\r\n\t    var keys = [];\r\n\t    var index = -1;\r\n\t    var mode = BEFORE_PATH;\r\n\t    var subPathDepth = 0;\r\n\t    var c, newChar, key, type, transition, action, typeMap;\r\n\t\r\n\t    var actions = [];\r\n\t\r\n\t    actions[PUSH] = function () {\r\n\t      if (key !== undefined) {\r\n\t        keys.push(key);\r\n\t        key = undefined;\r\n\t      }\r\n\t    };\r\n\t\r\n\t    actions[APPEND] = function () {\r\n\t      if (key === undefined) {\r\n\t        key = newChar;\r\n\t      } else {\r\n\t        key += newChar;\r\n\t      }\r\n\t    };\r\n\t\r\n\t    actions[INC_SUB_PATH_DEPTH] = function () {\r\n\t      actions[APPEND]();\r\n\t      subPathDepth++;\r\n\t    };\r\n\t\r\n\t    actions[PUSH_SUB_PATH] = function () {\r\n\t      if (subPathDepth > 0) {\r\n\t        subPathDepth--;\r\n\t        mode = IN_SUB_PATH;\r\n\t        actions[APPEND]();\r\n\t      } else {\r\n\t        subPathDepth = 0;\r\n\t        key = formatSubPath(key);\r\n\t        if (key === false) {\r\n\t          return false;\r\n\t        } else {\r\n\t          actions[PUSH]();\r\n\t        }\r\n\t      }\r\n\t    };\r\n\t\r\n\t    function maybeUnescapeQuote() {\r\n\t      var nextChar = path[index + 1];\r\n\t      if (mode === IN_SINGLE_QUOTE && nextChar === \"'\" || mode === IN_DOUBLE_QUOTE && nextChar === '\"') {\r\n\t        index++;\r\n\t        newChar = '\\\\' + nextChar;\r\n\t        actions[APPEND]();\r\n\t        return true;\r\n\t      }\r\n\t    }\r\n\t\r\n\t    while (mode != null) {\r\n\t      index++;\r\n\t      c = path[index];\r\n\t\r\n\t      if (c === '\\\\' && maybeUnescapeQuote()) {\r\n\t        continue;\r\n\t      }\r\n\t\r\n\t      type = getPathCharType(c);\r\n\t      typeMap = pathStateMachine[mode];\r\n\t      transition = typeMap[type] || typeMap['else'] || ERROR;\r\n\t\r\n\t      if (transition === ERROR) {\r\n\t        return; // parse error\r\n\t      }\r\n\t\r\n\t      mode = transition[0];\r\n\t      action = actions[transition[1]];\r\n\t      if (action) {\r\n\t        newChar = transition[2];\r\n\t        newChar = newChar === undefined ? c : newChar;\r\n\t        if (action() === false) {\r\n\t          return;\r\n\t        }\r\n\t      }\r\n\t\r\n\t      if (mode === AFTER_PATH) {\r\n\t        keys.raw = path;\r\n\t        return keys;\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * External parse that check for a cache hit first\r\n\t   *\r\n\t   * @param {String} path\r\n\t   * @return {Array|undefined}\r\n\t   */\r\n\t\r\n\t  function parsePath(path) {\r\n\t    var hit = pathCache.get(path);\r\n\t    if (!hit) {\r\n\t      hit = parse(path);\r\n\t      if (hit) {\r\n\t        pathCache.put(path, hit);\r\n\t      }\r\n\t    }\r\n\t    return hit;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Get from an object from a path string\r\n\t   *\r\n\t   * @param {Object} obj\r\n\t   * @param {String} path\r\n\t   */\r\n\t\r\n\t  function getPath(obj, path) {\r\n\t    return parseExpression(path).get(obj);\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Warn against setting non-existent root path on a vm.\r\n\t   */\r\n\t\r\n\t  var warnNonExistent;\r\n\t  if (true) {\r\n\t    warnNonExistent = function (path, vm) {\r\n\t      warn('You are setting a non-existent path \"' + path.raw + '\" ' + 'on a vm instance. Consider pre-initializing the property ' + 'with the \"data\" option for more reliable reactivity ' + 'and better performance.', vm);\r\n\t    };\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Set on an object from a path\r\n\t   *\r\n\t   * @param {Object} obj\r\n\t   * @param {String | Array} path\r\n\t   * @param {*} val\r\n\t   */\r\n\t\r\n\t  function setPath(obj, path, val) {\r\n\t    var original = obj;\r\n\t    if (typeof path === 'string') {\r\n\t      path = parse(path);\r\n\t    }\r\n\t    if (!path || !isObject(obj)) {\r\n\t      return false;\r\n\t    }\r\n\t    var last, key;\r\n\t    for (var i = 0, l = path.length; i < l; i++) {\r\n\t      last = obj;\r\n\t      key = path[i];\r\n\t      if (key.charAt(0) === '*') {\r\n\t        key = parseExpression(key.slice(1)).get.call(original, original);\r\n\t      }\r\n\t      if (i < l - 1) {\r\n\t        obj = obj[key];\r\n\t        if (!isObject(obj)) {\r\n\t          obj = {};\r\n\t          if ('development' !== 'production' && last._isVue) {\r\n\t            warnNonExistent(path, last);\r\n\t          }\r\n\t          set(last, key, obj);\r\n\t        }\r\n\t      } else {\r\n\t        if (isArray(obj)) {\r\n\t          obj.$set(key, val);\r\n\t        } else if (key in obj) {\r\n\t          obj[key] = val;\r\n\t        } else {\r\n\t          if ('development' !== 'production' && obj._isVue) {\r\n\t            warnNonExistent(path, obj);\r\n\t          }\r\n\t          set(obj, key, val);\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t    return true;\r\n\t  }\r\n\t\r\n\tvar path = Object.freeze({\r\n\t    parsePath: parsePath,\r\n\t    getPath: getPath,\r\n\t    setPath: setPath\r\n\t  });\r\n\t\r\n\t  var expressionCache = new Cache(1000);\r\n\t\r\n\t  var allowedKeywords = 'Math,Date,this,true,false,null,undefined,Infinity,NaN,' + 'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' + 'encodeURIComponent,parseInt,parseFloat';\r\n\t  var allowedKeywordsRE = new RegExp('^(' + allowedKeywords.replace(/,/g, '\\\\b|') + '\\\\b)');\r\n\t\r\n\t  // keywords that don't make sense inside expressions\r\n\t  var improperKeywords = 'break,case,class,catch,const,continue,debugger,default,' + 'delete,do,else,export,extends,finally,for,function,if,' + 'import,in,instanceof,let,return,super,switch,throw,try,' + 'var,while,with,yield,enum,await,implements,package,' + 'protected,static,interface,private,public';\r\n\t  var improperKeywordsRE = new RegExp('^(' + improperKeywords.replace(/,/g, '\\\\b|') + '\\\\b)');\r\n\t\r\n\t  var wsRE = /\\s/g;\r\n\t  var newlineRE = /\\n/g;\r\n\t  var saveRE = /[\\{,]\\s*[\\w\\$_]+\\s*:|('(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`)|new |typeof |void /g;\r\n\t  var restoreRE = /\"(\\d+)\"/g;\r\n\t  var pathTestRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?'\\]|\\[\".*?\"\\]|\\[\\d+\\]|\\[[A-Za-z_$][\\w$]*\\])*$/;\r\n\t  var identRE = /[^\\w$\\.](?:[A-Za-z_$][\\w$]*)/g;\r\n\t  var literalValueRE$1 = /^(?:true|false|null|undefined|Infinity|NaN)$/;\r\n\t\r\n\t  function noop() {}\r\n\t\r\n\t  /**\r\n\t   * Save / Rewrite / Restore\r\n\t   *\r\n\t   * When rewriting paths found in an expression, it is\r\n\t   * possible for the same letter sequences to be found in\r\n\t   * strings and Object literal property keys. Therefore we\r\n\t   * remove and store these parts in a temporary array, and\r\n\t   * restore them after the path rewrite.\r\n\t   */\r\n\t\r\n\t  var saved = [];\r\n\t\r\n\t  /**\r\n\t   * Save replacer\r\n\t   *\r\n\t   * The save regex can match two possible cases:\r\n\t   * 1. An opening object literal\r\n\t   * 2. A string\r\n\t   * If matched as a plain string, we need to escape its\r\n\t   * newlines, since the string needs to be preserved when\r\n\t   * generating the function body.\r\n\t   *\r\n\t   * @param {String} str\r\n\t   * @param {String} isString - str if matched as a string\r\n\t   * @return {String} - placeholder with index\r\n\t   */\r\n\t\r\n\t  function save(str, isString) {\r\n\t    var i = saved.length;\r\n\t    saved[i] = isString ? str.replace(newlineRE, '\\\\n') : str;\r\n\t    return '\"' + i + '\"';\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Path rewrite replacer\r\n\t   *\r\n\t   * @param {String} raw\r\n\t   * @return {String}\r\n\t   */\r\n\t\r\n\t  function rewrite(raw) {\r\n\t    var c = raw.charAt(0);\r\n\t    var path = raw.slice(1);\r\n\t    if (allowedKeywordsRE.test(path)) {\r\n\t      return raw;\r\n\t    } else {\r\n\t      path = path.indexOf('\"') > -1 ? path.replace(restoreRE, restore) : path;\r\n\t      return c + 'scope.' + path;\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Restore replacer\r\n\t   *\r\n\t   * @param {String} str\r\n\t   * @param {String} i - matched save index\r\n\t   * @return {String}\r\n\t   */\r\n\t\r\n\t  function restore(str, i) {\r\n\t    return saved[i];\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Rewrite an expression, prefixing all path accessors with\r\n\t   * `scope.` and generate getter/setter functions.\r\n\t   *\r\n\t   * @param {String} exp\r\n\t   * @return {Function}\r\n\t   */\r\n\t\r\n\t  function compileGetter(exp) {\r\n\t    if (improperKeywordsRE.test(exp)) {\r\n\t      'development' !== 'production' && warn('Avoid using reserved keywords in expression: ' + exp);\r\n\t    }\r\n\t    // reset state\r\n\t    saved.length = 0;\r\n\t    // save strings and object literal keys\r\n\t    var body = exp.replace(saveRE, save).replace(wsRE, '');\r\n\t    // rewrite all paths\r\n\t    // pad 1 space here because the regex matches 1 extra char\r\n\t    body = (' ' + body).replace(identRE, rewrite).replace(restoreRE, restore);\r\n\t    return makeGetterFn(body);\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Build a getter function. Requires eval.\r\n\t   *\r\n\t   * We isolate the try/catch so it doesn't affect the\r\n\t   * optimization of the parse function when it is not called.\r\n\t   *\r\n\t   * @param {String} body\r\n\t   * @return {Function|undefined}\r\n\t   */\r\n\t\r\n\t  function makeGetterFn(body) {\r\n\t    try {\r\n\t      /* eslint-disable no-new-func */\r\n\t      return new Function('scope', 'return ' + body + ';');\r\n\t      /* eslint-enable no-new-func */\r\n\t    } catch (e) {\r\n\t      if (true) {\r\n\t        /* istanbul ignore if */\r\n\t        if (e.toString().match(/unsafe-eval|CSP/)) {\r\n\t          warn('It seems you are using the default build of Vue.js in an environment ' + 'with Content Security Policy that prohibits unsafe-eval. ' + 'Use the CSP-compliant build instead: ' + 'http://vuejs.org/guide/installation.html#CSP-compliant-build');\r\n\t        } else {\r\n\t          warn('Invalid expression. ' + 'Generated function body: ' + body);\r\n\t        }\r\n\t      }\r\n\t      return noop;\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Compile a setter function for the expression.\r\n\t   *\r\n\t   * @param {String} exp\r\n\t   * @return {Function|undefined}\r\n\t   */\r\n\t\r\n\t  function compileSetter(exp) {\r\n\t    var path = parsePath(exp);\r\n\t    if (path) {\r\n\t      return function (scope, val) {\r\n\t        setPath(scope, path, val);\r\n\t      };\r\n\t    } else {\r\n\t      'development' !== 'production' && warn('Invalid setter expression: ' + exp);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Parse an expression into re-written getter/setters.\r\n\t   *\r\n\t   * @param {String} exp\r\n\t   * @param {Boolean} needSet\r\n\t   * @return {Function}\r\n\t   */\r\n\t\r\n\t  function parseExpression(exp, needSet) {\r\n\t    exp = exp.trim();\r\n\t    // try cache\r\n\t    var hit = expressionCache.get(exp);\r\n\t    if (hit) {\r\n\t      if (needSet && !hit.set) {\r\n\t        hit.set = compileSetter(hit.exp);\r\n\t      }\r\n\t      return hit;\r\n\t    }\r\n\t    var res = { exp: exp };\r\n\t    res.get = isSimplePath(exp) && exp.indexOf('[') < 0\r\n\t    // optimized super simple getter\r\n\t    ? makeGetterFn('scope.' + exp)\r\n\t    // dynamic getter\r\n\t    : compileGetter(exp);\r\n\t    if (needSet) {\r\n\t      res.set = compileSetter(exp);\r\n\t    }\r\n\t    expressionCache.put(exp, res);\r\n\t    return res;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Check if an expression is a simple path.\r\n\t   *\r\n\t   * @param {String} exp\r\n\t   * @return {Boolean}\r\n\t   */\r\n\t\r\n\t  function isSimplePath(exp) {\r\n\t    return pathTestRE.test(exp) &&\r\n\t    // don't treat literal values as paths\r\n\t    !literalValueRE$1.test(exp) &&\r\n\t    // Math constants e.g. Math.PI, Math.E etc.\r\n\t    exp.slice(0, 5) !== 'Math.';\r\n\t  }\r\n\t\r\n\tvar expression = Object.freeze({\r\n\t    parseExpression: parseExpression,\r\n\t    isSimplePath: isSimplePath\r\n\t  });\r\n\t\r\n\t  // we have two separate queues: one for directive updates\r\n\t  // and one for user watcher registered via $watch().\r\n\t  // we want to guarantee directive updates to be called\r\n\t  // before user watchers so that when user watchers are\r\n\t  // triggered, the DOM would have already been in updated\r\n\t  // state.\r\n\t\r\n\t  var queue = [];\r\n\t  var userQueue = [];\r\n\t  var has = {};\r\n\t  var circular = {};\r\n\t  var waiting = false;\r\n\t\r\n\t  /**\r\n\t   * Reset the batcher's state.\r\n\t   */\r\n\t\r\n\t  function resetBatcherState() {\r\n\t    queue.length = 0;\r\n\t    userQueue.length = 0;\r\n\t    has = {};\r\n\t    circular = {};\r\n\t    waiting = false;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Flush both queues and run the watchers.\r\n\t   */\r\n\t\r\n\t  function flushBatcherQueue() {\r\n\t    var _again = true;\r\n\t\r\n\t    _function: while (_again) {\r\n\t      _again = false;\r\n\t\r\n\t      runBatcherQueue(queue);\r\n\t      runBatcherQueue(userQueue);\r\n\t      // user watchers triggered more watchers,\r\n\t      // keep flushing until it depletes\r\n\t      if (queue.length) {\r\n\t        _again = true;\r\n\t        continue _function;\r\n\t      }\r\n\t      // dev tool hook\r\n\t      /* istanbul ignore if */\r\n\t      if (devtools && config.devtools) {\r\n\t        devtools.emit('flush');\r\n\t      }\r\n\t      resetBatcherState();\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Run the watchers in a single queue.\r\n\t   *\r\n\t   * @param {Array} queue\r\n\t   */\r\n\t\r\n\t  function runBatcherQueue(queue) {\r\n\t    // do not cache length because more watchers might be pushed\r\n\t    // as we run existing watchers\r\n\t    for (var i = 0; i < queue.length; i++) {\r\n\t      var watcher = queue[i];\r\n\t      var id = watcher.id;\r\n\t      has[id] = null;\r\n\t      watcher.run();\r\n\t      // in dev build, check and stop circular updates.\r\n\t      if ('development' !== 'production' && has[id] != null) {\r\n\t        circular[id] = (circular[id] || 0) + 1;\r\n\t        if (circular[id] > config._maxUpdateCount) {\r\n\t          warn('You may have an infinite update loop for watcher ' + 'with expression \"' + watcher.expression + '\"', watcher.vm);\r\n\t          break;\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t    queue.length = 0;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Push a watcher into the watcher queue.\r\n\t   * Jobs with duplicate IDs will be skipped unless it's\r\n\t   * pushed when the queue is being flushed.\r\n\t   *\r\n\t   * @param {Watcher} watcher\r\n\t   *   properties:\r\n\t   *   - {Number} id\r\n\t   *   - {Function} run\r\n\t   */\r\n\t\r\n\t  function pushWatcher(watcher) {\r\n\t    var id = watcher.id;\r\n\t    if (has[id] == null) {\r\n\t      // push watcher into appropriate queue\r\n\t      var q = watcher.user ? userQueue : queue;\r\n\t      has[id] = q.length;\r\n\t      q.push(watcher);\r\n\t      // queue the flush\r\n\t      if (!waiting) {\r\n\t        waiting = true;\r\n\t        nextTick(flushBatcherQueue);\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t\r\n\t  var uid$2 = 0;\r\n\t\r\n\t  /**\r\n\t   * A watcher parses an expression, collects dependencies,\r\n\t   * and fires callback when the expression value changes.\r\n\t   * This is used for both the $watch() api and directives.\r\n\t   *\r\n\t   * @param {Vue} vm\r\n\t   * @param {String|Function} expOrFn\r\n\t   * @param {Function} cb\r\n\t   * @param {Object} options\r\n\t   *                 - {Array} filters\r\n\t   *                 - {Boolean} twoWay\r\n\t   *                 - {Boolean} deep\r\n\t   *                 - {Boolean} user\r\n\t   *                 - {Boolean} sync\r\n\t   *                 - {Boolean} lazy\r\n\t   *                 - {Function} [preProcess]\r\n\t   *                 - {Function} [postProcess]\r\n\t   * @constructor\r\n\t   */\r\n\t  function Watcher(vm, expOrFn, cb, options) {\r\n\t    // mix in options\r\n\t    if (options) {\r\n\t      extend(this, options);\r\n\t    }\r\n\t    var isFn = typeof expOrFn === 'function';\r\n\t    this.vm = vm;\r\n\t    vm._watchers.push(this);\r\n\t    this.expression = expOrFn;\r\n\t    this.cb = cb;\r\n\t    this.id = ++uid$2; // uid for batching\r\n\t    this.active = true;\r\n\t    this.dirty = this.lazy; // for lazy watchers\r\n\t    this.deps = [];\r\n\t    this.newDeps = [];\r\n\t    this.depIds = new _Set();\r\n\t    this.newDepIds = new _Set();\r\n\t    this.prevError = null; // for async error stacks\r\n\t    // parse expression for getter/setter\r\n\t    if (isFn) {\r\n\t      this.getter = expOrFn;\r\n\t      this.setter = undefined;\r\n\t    } else {\r\n\t      var res = parseExpression(expOrFn, this.twoWay);\r\n\t      this.getter = res.get;\r\n\t      this.setter = res.set;\r\n\t    }\r\n\t    this.value = this.lazy ? undefined : this.get();\r\n\t    // state for avoiding false triggers for deep and Array\r\n\t    // watchers during vm._digest()\r\n\t    this.queued = this.shallow = false;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Evaluate the getter, and re-collect dependencies.\r\n\t   */\r\n\t\r\n\t  Watcher.prototype.get = function () {\r\n\t    this.beforeGet();\r\n\t    var scope = this.scope || this.vm;\r\n\t    var value;\r\n\t    try {\r\n\t      value = this.getter.call(scope, scope);\r\n\t    } catch (e) {\r\n\t      if ('development' !== 'production' && config.warnExpressionErrors) {\r\n\t        warn('Error when evaluating expression ' + '\"' + this.expression + '\": ' + e.toString(), this.vm);\r\n\t      }\r\n\t    }\r\n\t    // \"touch\" every property so they are all tracked as\r\n\t    // dependencies for deep watching\r\n\t    if (this.deep) {\r\n\t      traverse(value);\r\n\t    }\r\n\t    if (this.preProcess) {\r\n\t      value = this.preProcess(value);\r\n\t    }\r\n\t    if (this.filters) {\r\n\t      value = scope._applyFilters(value, null, this.filters, false);\r\n\t    }\r\n\t    if (this.postProcess) {\r\n\t      value = this.postProcess(value);\r\n\t    }\r\n\t    this.afterGet();\r\n\t    return value;\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Set the corresponding value with the setter.\r\n\t   *\r\n\t   * @param {*} value\r\n\t   */\r\n\t\r\n\t  Watcher.prototype.set = function (value) {\r\n\t    var scope = this.scope || this.vm;\r\n\t    if (this.filters) {\r\n\t      value = scope._applyFilters(value, this.value, this.filters, true);\r\n\t    }\r\n\t    try {\r\n\t      this.setter.call(scope, scope, value);\r\n\t    } catch (e) {\r\n\t      if ('development' !== 'production' && config.warnExpressionErrors) {\r\n\t        warn('Error when evaluating setter ' + '\"' + this.expression + '\": ' + e.toString(), this.vm);\r\n\t      }\r\n\t    }\r\n\t    // two-way sync for v-for alias\r\n\t    var forContext = scope.$forContext;\r\n\t    if (forContext && forContext.alias === this.expression) {\r\n\t      if (forContext.filters) {\r\n\t        'development' !== 'production' && warn('It seems you are using two-way binding on ' + 'a v-for alias (' + this.expression + '), and the ' + 'v-for has filters. This will not work properly. ' + 'Either remove the filters or use an array of ' + 'objects and bind to object properties instead.', this.vm);\r\n\t        return;\r\n\t      }\r\n\t      forContext._withLock(function () {\r\n\t        if (scope.$key) {\r\n\t          // original is an object\r\n\t          forContext.rawValue[scope.$key] = value;\r\n\t        } else {\r\n\t          forContext.rawValue.$set(scope.$index, value);\r\n\t        }\r\n\t      });\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Prepare for dependency collection.\r\n\t   */\r\n\t\r\n\t  Watcher.prototype.beforeGet = function () {\r\n\t    Dep.target = this;\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Add a dependency to this directive.\r\n\t   *\r\n\t   * @param {Dep} dep\r\n\t   */\r\n\t\r\n\t  Watcher.prototype.addDep = function (dep) {\r\n\t    var id = dep.id;\r\n\t    if (!this.newDepIds.has(id)) {\r\n\t      this.newDepIds.add(id);\r\n\t      this.newDeps.push(dep);\r\n\t      if (!this.depIds.has(id)) {\r\n\t        dep.addSub(this);\r\n\t      }\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Clean up for dependency collection.\r\n\t   */\r\n\t\r\n\t  Watcher.prototype.afterGet = function () {\r\n\t    Dep.target = null;\r\n\t    var i = this.deps.length;\r\n\t    while (i--) {\r\n\t      var dep = this.deps[i];\r\n\t      if (!this.newDepIds.has(dep.id)) {\r\n\t        dep.removeSub(this);\r\n\t      }\r\n\t    }\r\n\t    var tmp = this.depIds;\r\n\t    this.depIds = this.newDepIds;\r\n\t    this.newDepIds = tmp;\r\n\t    this.newDepIds.clear();\r\n\t    tmp = this.deps;\r\n\t    this.deps = this.newDeps;\r\n\t    this.newDeps = tmp;\r\n\t    this.newDeps.length = 0;\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Subscriber interface.\r\n\t   * Will be called when a dependency changes.\r\n\t   *\r\n\t   * @param {Boolean} shallow\r\n\t   */\r\n\t\r\n\t  Watcher.prototype.update = function (shallow) {\r\n\t    if (this.lazy) {\r\n\t      this.dirty = true;\r\n\t    } else if (this.sync || !config.async) {\r\n\t      this.run();\r\n\t    } else {\r\n\t      // if queued, only overwrite shallow with non-shallow,\r\n\t      // but not the other way around.\r\n\t      this.shallow = this.queued ? shallow ? this.shallow : false : !!shallow;\r\n\t      this.queued = true;\r\n\t      // record before-push error stack in debug mode\r\n\t      /* istanbul ignore if */\r\n\t      if ('development' !== 'production' && config.debug) {\r\n\t        this.prevError = new Error('[vue] async stack trace');\r\n\t      }\r\n\t      pushWatcher(this);\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Batcher job interface.\r\n\t   * Will be called by the batcher.\r\n\t   */\r\n\t\r\n\t  Watcher.prototype.run = function () {\r\n\t    if (this.active) {\r\n\t      var value = this.get();\r\n\t      if (value !== this.value ||\r\n\t      // Deep watchers and watchers on Object/Arrays should fire even\r\n\t      // when the value is the same, because the value may\r\n\t      // have mutated; but only do so if this is a\r\n\t      // non-shallow update (caused by a vm digest).\r\n\t      (isObject(value) || this.deep) && !this.shallow) {\r\n\t        // set new value\r\n\t        var oldValue = this.value;\r\n\t        this.value = value;\r\n\t        // in debug + async mode, when a watcher callbacks\r\n\t        // throws, we also throw the saved before-push error\r\n\t        // so the full cross-tick stack trace is available.\r\n\t        var prevError = this.prevError;\r\n\t        /* istanbul ignore if */\r\n\t        if ('development' !== 'production' && config.debug && prevError) {\r\n\t          this.prevError = null;\r\n\t          try {\r\n\t            this.cb.call(this.vm, value, oldValue);\r\n\t          } catch (e) {\r\n\t            nextTick(function () {\r\n\t              throw prevError;\r\n\t            }, 0);\r\n\t            throw e;\r\n\t          }\r\n\t        } else {\r\n\t          this.cb.call(this.vm, value, oldValue);\r\n\t        }\r\n\t      }\r\n\t      this.queued = this.shallow = false;\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Evaluate the value of the watcher.\r\n\t   * This only gets called for lazy watchers.\r\n\t   */\r\n\t\r\n\t  Watcher.prototype.evaluate = function () {\r\n\t    // avoid overwriting another watcher that is being\r\n\t    // collected.\r\n\t    var current = Dep.target;\r\n\t    this.value = this.get();\r\n\t    this.dirty = false;\r\n\t    Dep.target = current;\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Depend on all deps collected by this watcher.\r\n\t   */\r\n\t\r\n\t  Watcher.prototype.depend = function () {\r\n\t    var i = this.deps.length;\r\n\t    while (i--) {\r\n\t      this.deps[i].depend();\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Remove self from all dependencies' subcriber list.\r\n\t   */\r\n\t\r\n\t  Watcher.prototype.teardown = function () {\r\n\t    if (this.active) {\r\n\t      // remove self from vm's watcher list\r\n\t      // this is a somewhat expensive operation so we skip it\r\n\t      // if the vm is being destroyed or is performing a v-for\r\n\t      // re-render (the watcher list is then filtered by v-for).\r\n\t      if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {\r\n\t        this.vm._watchers.$remove(this);\r\n\t      }\r\n\t      var i = this.deps.length;\r\n\t      while (i--) {\r\n\t        this.deps[i].removeSub(this);\r\n\t      }\r\n\t      this.active = false;\r\n\t      this.vm = this.cb = this.value = null;\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Recrusively traverse an object to evoke all converted\r\n\t   * getters, so that every nested property inside the object\r\n\t   * is collected as a \"deep\" dependency.\r\n\t   *\r\n\t   * @param {*} val\r\n\t   */\r\n\t\r\n\t  var seenObjects = new _Set();\r\n\t  function traverse(val, seen) {\r\n\t    var i = undefined,\r\n\t        keys = undefined;\r\n\t    if (!seen) {\r\n\t      seen = seenObjects;\r\n\t      seen.clear();\r\n\t    }\r\n\t    var isA = isArray(val);\r\n\t    var isO = isObject(val);\r\n\t    if ((isA || isO) && Object.isExtensible(val)) {\r\n\t      if (val.__ob__) {\r\n\t        var depId = val.__ob__.dep.id;\r\n\t        if (seen.has(depId)) {\r\n\t          return;\r\n\t        } else {\r\n\t          seen.add(depId);\r\n\t        }\r\n\t      }\r\n\t      if (isA) {\r\n\t        i = val.length;\r\n\t        while (i--) traverse(val[i], seen);\r\n\t      } else if (isO) {\r\n\t        keys = Object.keys(val);\r\n\t        i = keys.length;\r\n\t        while (i--) traverse(val[keys[i]], seen);\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t\r\n\t  var text$1 = {\r\n\t\r\n\t    bind: function bind() {\r\n\t      this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';\r\n\t    },\r\n\t\r\n\t    update: function update(value) {\r\n\t      this.el[this.attr] = _toString(value);\r\n\t    }\r\n\t  };\r\n\t\r\n\t  var templateCache = new Cache(1000);\r\n\t  var idSelectorCache = new Cache(1000);\r\n\t\r\n\t  var map = {\r\n\t    efault: [0, '', ''],\r\n\t    legend: [1, '<fieldset>', '</fieldset>'],\r\n\t    tr: [2, '<table><tbody>', '</tbody></table>'],\r\n\t    col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>']\r\n\t  };\r\n\t\r\n\t  map.td = map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];\r\n\t\r\n\t  map.option = map.optgroup = [1, '<select multiple=\"multiple\">', '</select>'];\r\n\t\r\n\t  map.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, '<table>', '</table>'];\r\n\t\r\n\t  map.g = map.defs = map.symbol = map.use = map.image = map.text = map.circle = map.ellipse = map.line = map.path = map.polygon = map.polyline = map.rect = [1, '<svg ' + 'xmlns=\"http://www.w3.org/2000/svg\" ' + 'xmlns:xlink=\"http://www.w3.org/1999/xlink\" ' + 'xmlns:ev=\"http://www.w3.org/2001/xml-events\"' + 'version=\"1.1\">', '</svg>'];\r\n\t\r\n\t  /**\r\n\t   * Check if a node is a supported template node with a\r\n\t   * DocumentFragment content.\r\n\t   *\r\n\t   * @param {Node} node\r\n\t   * @return {Boolean}\r\n\t   */\r\n\t\r\n\t  function isRealTemplate(node) {\r\n\t    return isTemplate(node) && isFragment(node.content);\r\n\t  }\r\n\t\r\n\t  var tagRE$1 = /<([\\w:-]+)/;\r\n\t  var entityRE = /&#?\\w+?;/;\r\n\t  var commentRE = /<!--/;\r\n\t\r\n\t  /**\r\n\t   * Convert a string template to a DocumentFragment.\r\n\t   * Determines correct wrapping by tag types. Wrapping\r\n\t   * strategy found in jQuery & component/domify.\r\n\t   *\r\n\t   * @param {String} templateString\r\n\t   * @param {Boolean} raw\r\n\t   * @return {DocumentFragment}\r\n\t   */\r\n\t\r\n\t  function stringToFragment(templateString, raw) {\r\n\t    // try a cache hit first\r\n\t    var cacheKey = raw ? templateString : templateString.trim();\r\n\t    var hit = templateCache.get(cacheKey);\r\n\t    if (hit) {\r\n\t      return hit;\r\n\t    }\r\n\t\r\n\t    var frag = document.createDocumentFragment();\r\n\t    var tagMatch = templateString.match(tagRE$1);\r\n\t    var entityMatch = entityRE.test(templateString);\r\n\t    var commentMatch = commentRE.test(templateString);\r\n\t\r\n\t    if (!tagMatch && !entityMatch && !commentMatch) {\r\n\t      // text only, return a single text node.\r\n\t      frag.appendChild(document.createTextNode(templateString));\r\n\t    } else {\r\n\t      var tag = tagMatch && tagMatch[1];\r\n\t      var wrap = map[tag] || map.efault;\r\n\t      var depth = wrap[0];\r\n\t      var prefix = wrap[1];\r\n\t      var suffix = wrap[2];\r\n\t      var node = document.createElement('div');\r\n\t\r\n\t      node.innerHTML = prefix + templateString + suffix;\r\n\t      while (depth--) {\r\n\t        node = node.lastChild;\r\n\t      }\r\n\t\r\n\t      var child;\r\n\t      /* eslint-disable no-cond-assign */\r\n\t      while (child = node.firstChild) {\r\n\t        /* eslint-enable no-cond-assign */\r\n\t        frag.appendChild(child);\r\n\t      }\r\n\t    }\r\n\t    if (!raw) {\r\n\t      trimNode(frag);\r\n\t    }\r\n\t    templateCache.put(cacheKey, frag);\r\n\t    return frag;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Convert a template node to a DocumentFragment.\r\n\t   *\r\n\t   * @param {Node} node\r\n\t   * @return {DocumentFragment}\r\n\t   */\r\n\t\r\n\t  function nodeToFragment(node) {\r\n\t    // if its a template tag and the browser supports it,\r\n\t    // its content is already a document fragment. However, iOS Safari has\r\n\t    // bug when using directly cloned template content with touch\r\n\t    // events and can cause crashes when the nodes are removed from DOM, so we\r\n\t    // have to treat template elements as string templates. (#2805)\r\n\t    /* istanbul ignore if */\r\n\t    if (isRealTemplate(node)) {\r\n\t      return stringToFragment(node.innerHTML);\r\n\t    }\r\n\t    // script template\r\n\t    if (node.tagName === 'SCRIPT') {\r\n\t      return stringToFragment(node.textContent);\r\n\t    }\r\n\t    // normal node, clone it to avoid mutating the original\r\n\t    var clonedNode = cloneNode(node);\r\n\t    var frag = document.createDocumentFragment();\r\n\t    var child;\r\n\t    /* eslint-disable no-cond-assign */\r\n\t    while (child = clonedNode.firstChild) {\r\n\t      /* eslint-enable no-cond-assign */\r\n\t      frag.appendChild(child);\r\n\t    }\r\n\t    trimNode(frag);\r\n\t    return frag;\r\n\t  }\r\n\t\r\n\t  // Test for the presence of the Safari template cloning bug\r\n\t  // https://bugs.webkit.org/showug.cgi?id=137755\r\n\t  var hasBrokenTemplate = (function () {\r\n\t    /* istanbul ignore else */\r\n\t    if (inBrowser) {\r\n\t      var a = document.createElement('div');\r\n\t      a.innerHTML = '<template>1</template>';\r\n\t      return !a.cloneNode(true).firstChild.innerHTML;\r\n\t    } else {\r\n\t      return false;\r\n\t    }\r\n\t  })();\r\n\t\r\n\t  // Test for IE10/11 textarea placeholder clone bug\r\n\t  var hasTextareaCloneBug = (function () {\r\n\t    /* istanbul ignore else */\r\n\t    if (inBrowser) {\r\n\t      var t = document.createElement('textarea');\r\n\t      t.placeholder = 't';\r\n\t      return t.cloneNode(true).value === 't';\r\n\t    } else {\r\n\t      return false;\r\n\t    }\r\n\t  })();\r\n\t\r\n\t  /**\r\n\t   * 1. Deal with Safari cloning nested <template> bug by\r\n\t   *    manually cloning all template instances.\r\n\t   * 2. Deal with IE10/11 textarea placeholder bug by setting\r\n\t   *    the correct value after cloning.\r\n\t   *\r\n\t   * @param {Element|DocumentFragment} node\r\n\t   * @return {Element|DocumentFragment}\r\n\t   */\r\n\t\r\n\t  function cloneNode(node) {\r\n\t    /* istanbul ignore if */\r\n\t    if (!node.querySelectorAll) {\r\n\t      return node.cloneNode();\r\n\t    }\r\n\t    var res = node.cloneNode(true);\r\n\t    var i, original, cloned;\r\n\t    /* istanbul ignore if */\r\n\t    if (hasBrokenTemplate) {\r\n\t      var tempClone = res;\r\n\t      if (isRealTemplate(node)) {\r\n\t        node = node.content;\r\n\t        tempClone = res.content;\r\n\t      }\r\n\t      original = node.querySelectorAll('template');\r\n\t      if (original.length) {\r\n\t        cloned = tempClone.querySelectorAll('template');\r\n\t        i = cloned.length;\r\n\t        while (i--) {\r\n\t          cloned[i].parentNode.replaceChild(cloneNode(original[i]), cloned[i]);\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t    /* istanbul ignore if */\r\n\t    if (hasTextareaCloneBug) {\r\n\t      if (node.tagName === 'TEXTAREA') {\r\n\t        res.value = node.value;\r\n\t      } else {\r\n\t        original = node.querySelectorAll('textarea');\r\n\t        if (original.length) {\r\n\t          cloned = res.querySelectorAll('textarea');\r\n\t          i = cloned.length;\r\n\t          while (i--) {\r\n\t            cloned[i].value = original[i].value;\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t    return res;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Process the template option and normalizes it into a\r\n\t   * a DocumentFragment that can be used as a partial or a\r\n\t   * instance template.\r\n\t   *\r\n\t   * @param {*} template\r\n\t   *        Possible values include:\r\n\t   *        - DocumentFragment object\r\n\t   *        - Node object of type Template\r\n\t   *        - id selector: '#some-template-id'\r\n\t   *        - template string: '<div><span>{{msg}}</span></div>'\r\n\t   * @param {Boolean} shouldClone\r\n\t   * @param {Boolean} raw\r\n\t   *        inline HTML interpolation. Do not check for id\r\n\t   *        selector and keep whitespace in the string.\r\n\t   * @return {DocumentFragment|undefined}\r\n\t   */\r\n\t\r\n\t  function parseTemplate(template, shouldClone, raw) {\r\n\t    var node, frag;\r\n\t\r\n\t    // if the template is already a document fragment,\r\n\t    // do nothing\r\n\t    if (isFragment(template)) {\r\n\t      trimNode(template);\r\n\t      return shouldClone ? cloneNode(template) : template;\r\n\t    }\r\n\t\r\n\t    if (typeof template === 'string') {\r\n\t      // id selector\r\n\t      if (!raw && template.charAt(0) === '#') {\r\n\t        // id selector can be cached too\r\n\t        frag = idSelectorCache.get(template);\r\n\t        if (!frag) {\r\n\t          node = document.getElementById(template.slice(1));\r\n\t          if (node) {\r\n\t            frag = nodeToFragment(node);\r\n\t            // save selector to cache\r\n\t            idSelectorCache.put(template, frag);\r\n\t          }\r\n\t        }\r\n\t      } else {\r\n\t        // normal string template\r\n\t        frag = stringToFragment(template, raw);\r\n\t      }\r\n\t    } else if (template.nodeType) {\r\n\t      // a direct node\r\n\t      frag = nodeToFragment(template);\r\n\t    }\r\n\t\r\n\t    return frag && shouldClone ? cloneNode(frag) : frag;\r\n\t  }\r\n\t\r\n\tvar template = Object.freeze({\r\n\t    cloneNode: cloneNode,\r\n\t    parseTemplate: parseTemplate\r\n\t  });\r\n\t\r\n\t  var html = {\r\n\t\r\n\t    bind: function bind() {\r\n\t      // a comment node means this is a binding for\r\n\t      // {{{ inline unescaped html }}}\r\n\t      if (this.el.nodeType === 8) {\r\n\t        // hold nodes\r\n\t        this.nodes = [];\r\n\t        // replace the placeholder with proper anchor\r\n\t        this.anchor = createAnchor('v-html');\r\n\t        replace(this.el, this.anchor);\r\n\t      }\r\n\t    },\r\n\t\r\n\t    update: function update(value) {\r\n\t      value = _toString(value);\r\n\t      if (this.nodes) {\r\n\t        this.swap(value);\r\n\t      } else {\r\n\t        this.el.innerHTML = value;\r\n\t      }\r\n\t    },\r\n\t\r\n\t    swap: function swap(value) {\r\n\t      // remove old nodes\r\n\t      var i = this.nodes.length;\r\n\t      while (i--) {\r\n\t        remove(this.nodes[i]);\r\n\t      }\r\n\t      // convert new value to a fragment\r\n\t      // do not attempt to retrieve from id selector\r\n\t      var frag = parseTemplate(value, true, true);\r\n\t      // save a reference to these nodes so we can remove later\r\n\t      this.nodes = toArray(frag.childNodes);\r\n\t      before(frag, this.anchor);\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Abstraction for a partially-compiled fragment.\r\n\t   * Can optionally compile content with a child scope.\r\n\t   *\r\n\t   * @param {Function} linker\r\n\t   * @param {Vue} vm\r\n\t   * @param {DocumentFragment} frag\r\n\t   * @param {Vue} [host]\r\n\t   * @param {Object} [scope]\r\n\t   * @param {Fragment} [parentFrag]\r\n\t   */\r\n\t  function Fragment(linker, vm, frag, host, scope, parentFrag) {\r\n\t    this.children = [];\r\n\t    this.childFrags = [];\r\n\t    this.vm = vm;\r\n\t    this.scope = scope;\r\n\t    this.inserted = false;\r\n\t    this.parentFrag = parentFrag;\r\n\t    if (parentFrag) {\r\n\t      parentFrag.childFrags.push(this);\r\n\t    }\r\n\t    this.unlink = linker(vm, frag, host, scope, this);\r\n\t    var single = this.single = frag.childNodes.length === 1 &&\r\n\t    // do not go single mode if the only node is an anchor\r\n\t    !frag.childNodes[0].__v_anchor;\r\n\t    if (single) {\r\n\t      this.node = frag.childNodes[0];\r\n\t      this.before = singleBefore;\r\n\t      this.remove = singleRemove;\r\n\t    } else {\r\n\t      this.node = createAnchor('fragment-start');\r\n\t      this.end = createAnchor('fragment-end');\r\n\t      this.frag = frag;\r\n\t      prepend(this.node, frag);\r\n\t      frag.appendChild(this.end);\r\n\t      this.before = multiBefore;\r\n\t      this.remove = multiRemove;\r\n\t    }\r\n\t    this.node.__v_frag = this;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Call attach/detach for all components contained within\r\n\t   * this fragment. Also do so recursively for all child\r\n\t   * fragments.\r\n\t   *\r\n\t   * @param {Function} hook\r\n\t   */\r\n\t\r\n\t  Fragment.prototype.callHook = function (hook) {\r\n\t    var i, l;\r\n\t    for (i = 0, l = this.childFrags.length; i < l; i++) {\r\n\t      this.childFrags[i].callHook(hook);\r\n\t    }\r\n\t    for (i = 0, l = this.children.length; i < l; i++) {\r\n\t      hook(this.children[i]);\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Insert fragment before target, single node version\r\n\t   *\r\n\t   * @param {Node} target\r\n\t   * @param {Boolean} withTransition\r\n\t   */\r\n\t\r\n\t  function singleBefore(target, withTransition) {\r\n\t    this.inserted = true;\r\n\t    var method = withTransition !== false ? beforeWithTransition : before;\r\n\t    method(this.node, target, this.vm);\r\n\t    if (inDoc(this.node)) {\r\n\t      this.callHook(attach);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Remove fragment, single node version\r\n\t   */\r\n\t\r\n\t  function singleRemove() {\r\n\t    this.inserted = false;\r\n\t    var shouldCallRemove = inDoc(this.node);\r\n\t    var self = this;\r\n\t    this.beforeRemove();\r\n\t    removeWithTransition(this.node, this.vm, function () {\r\n\t      if (shouldCallRemove) {\r\n\t        self.callHook(detach);\r\n\t      }\r\n\t      self.destroy();\r\n\t    });\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Insert fragment before target, multi-nodes version\r\n\t   *\r\n\t   * @param {Node} target\r\n\t   * @param {Boolean} withTransition\r\n\t   */\r\n\t\r\n\t  function multiBefore(target, withTransition) {\r\n\t    this.inserted = true;\r\n\t    var vm = this.vm;\r\n\t    var method = withTransition !== false ? beforeWithTransition : before;\r\n\t    mapNodeRange(this.node, this.end, function (node) {\r\n\t      method(node, target, vm);\r\n\t    });\r\n\t    if (inDoc(this.node)) {\r\n\t      this.callHook(attach);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Remove fragment, multi-nodes version\r\n\t   */\r\n\t\r\n\t  function multiRemove() {\r\n\t    this.inserted = false;\r\n\t    var self = this;\r\n\t    var shouldCallRemove = inDoc(this.node);\r\n\t    this.beforeRemove();\r\n\t    removeNodeRange(this.node, this.end, this.vm, this.frag, function () {\r\n\t      if (shouldCallRemove) {\r\n\t        self.callHook(detach);\r\n\t      }\r\n\t      self.destroy();\r\n\t    });\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Prepare the fragment for removal.\r\n\t   */\r\n\t\r\n\t  Fragment.prototype.beforeRemove = function () {\r\n\t    var i, l;\r\n\t    for (i = 0, l = this.childFrags.length; i < l; i++) {\r\n\t      // call the same method recursively on child\r\n\t      // fragments, depth-first\r\n\t      this.childFrags[i].beforeRemove(false);\r\n\t    }\r\n\t    for (i = 0, l = this.children.length; i < l; i++) {\r\n\t      // Call destroy for all contained instances,\r\n\t      // with remove:false and defer:true.\r\n\t      // Defer is necessary because we need to\r\n\t      // keep the children to call detach hooks\r\n\t      // on them.\r\n\t      this.children[i].$destroy(false, true);\r\n\t    }\r\n\t    var dirs = this.unlink.dirs;\r\n\t    for (i = 0, l = dirs.length; i < l; i++) {\r\n\t      // disable the watchers on all the directives\r\n\t      // so that the rendered content stays the same\r\n\t      // during removal.\r\n\t      dirs[i]._watcher && dirs[i]._watcher.teardown();\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Destroy the fragment.\r\n\t   */\r\n\t\r\n\t  Fragment.prototype.destroy = function () {\r\n\t    if (this.parentFrag) {\r\n\t      this.parentFrag.childFrags.$remove(this);\r\n\t    }\r\n\t    this.node.__v_frag = null;\r\n\t    this.unlink();\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Call attach hook for a Vue instance.\r\n\t   *\r\n\t   * @param {Vue} child\r\n\t   */\r\n\t\r\n\t  function attach(child) {\r\n\t    if (!child._isAttached && inDoc(child.$el)) {\r\n\t      child._callHook('attached');\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Call detach hook for a Vue instance.\r\n\t   *\r\n\t   * @param {Vue} child\r\n\t   */\r\n\t\r\n\t  function detach(child) {\r\n\t    if (child._isAttached && !inDoc(child.$el)) {\r\n\t      child._callHook('detached');\r\n\t    }\r\n\t  }\r\n\t\r\n\t  var linkerCache = new Cache(5000);\r\n\t\r\n\t  /**\r\n\t   * A factory that can be used to create instances of a\r\n\t   * fragment. Caches the compiled linker if possible.\r\n\t   *\r\n\t   * @param {Vue} vm\r\n\t   * @param {Element|String} el\r\n\t   */\r\n\t  function FragmentFactory(vm, el) {\r\n\t    this.vm = vm;\r\n\t    var template;\r\n\t    var isString = typeof el === 'string';\r\n\t    if (isString || isTemplate(el) && !el.hasAttribute('v-if')) {\r\n\t      template = parseTemplate(el, true);\r\n\t    } else {\r\n\t      template = document.createDocumentFragment();\r\n\t      template.appendChild(el);\r\n\t    }\r\n\t    this.template = template;\r\n\t    // linker can be cached, but only for components\r\n\t    var linker;\r\n\t    var cid = vm.constructor.cid;\r\n\t    if (cid > 0) {\r\n\t      var cacheId = cid + (isString ? el : getOuterHTML(el));\r\n\t      linker = linkerCache.get(cacheId);\r\n\t      if (!linker) {\r\n\t        linker = compile(template, vm.$options, true);\r\n\t        linkerCache.put(cacheId, linker);\r\n\t      }\r\n\t    } else {\r\n\t      linker = compile(template, vm.$options, true);\r\n\t    }\r\n\t    this.linker = linker;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Create a fragment instance with given host and scope.\r\n\t   *\r\n\t   * @param {Vue} host\r\n\t   * @param {Object} scope\r\n\t   * @param {Fragment} parentFrag\r\n\t   */\r\n\t\r\n\t  FragmentFactory.prototype.create = function (host, scope, parentFrag) {\r\n\t    var frag = cloneNode(this.template);\r\n\t    return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag);\r\n\t  };\r\n\t\r\n\t  var ON = 700;\r\n\t  var MODEL = 800;\r\n\t  var BIND = 850;\r\n\t  var TRANSITION = 1100;\r\n\t  var EL = 1500;\r\n\t  var COMPONENT = 1500;\r\n\t  var PARTIAL = 1750;\r\n\t  var IF = 2100;\r\n\t  var FOR = 2200;\r\n\t  var SLOT = 2300;\r\n\t\r\n\t  var uid$3 = 0;\r\n\t\r\n\t  var vFor = {\r\n\t\r\n\t    priority: FOR,\r\n\t    terminal: true,\r\n\t\r\n\t    params: ['track-by', 'stagger', 'enter-stagger', 'leave-stagger'],\r\n\t\r\n\t    bind: function bind() {\r\n\t      // support \"item in/of items\" syntax\r\n\t      var inMatch = this.expression.match(/(.*) (?:in|of) (.*)/);\r\n\t      if (inMatch) {\r\n\t        var itMatch = inMatch[1].match(/\\((.*),(.*)\\)/);\r\n\t        if (itMatch) {\r\n\t          this.iterator = itMatch[1].trim();\r\n\t          this.alias = itMatch[2].trim();\r\n\t        } else {\r\n\t          this.alias = inMatch[1].trim();\r\n\t        }\r\n\t        this.expression = inMatch[2];\r\n\t      }\r\n\t\r\n\t      if (!this.alias) {\r\n\t        'development' !== 'production' && warn('Invalid v-for expression \"' + this.descriptor.raw + '\": ' + 'alias is required.', this.vm);\r\n\t        return;\r\n\t      }\r\n\t\r\n\t      // uid as a cache identifier\r\n\t      this.id = '__v-for__' + ++uid$3;\r\n\t\r\n\t      // check if this is an option list,\r\n\t      // so that we know if we need to update the <select>'s\r\n\t      // v-model when the option list has changed.\r\n\t      // because v-model has a lower priority than v-for,\r\n\t      // the v-model is not bound here yet, so we have to\r\n\t      // retrive it in the actual updateModel() function.\r\n\t      var tag = this.el.tagName;\r\n\t      this.isOption = (tag === 'OPTION' || tag === 'OPTGROUP') && this.el.parentNode.tagName === 'SELECT';\r\n\t\r\n\t      // setup anchor nodes\r\n\t      this.start = createAnchor('v-for-start');\r\n\t      this.end = createAnchor('v-for-end');\r\n\t      replace(this.el, this.end);\r\n\t      before(this.start, this.end);\r\n\t\r\n\t      // cache\r\n\t      this.cache = Object.create(null);\r\n\t\r\n\t      // fragment factory\r\n\t      this.factory = new FragmentFactory(this.vm, this.el);\r\n\t    },\r\n\t\r\n\t    update: function update(data) {\r\n\t      this.diff(data);\r\n\t      this.updateRef();\r\n\t      this.updateModel();\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Diff, based on new data and old data, determine the\r\n\t     * minimum amount of DOM manipulations needed to make the\r\n\t     * DOM reflect the new data Array.\r\n\t     *\r\n\t     * The algorithm diffs the new data Array by storing a\r\n\t     * hidden reference to an owner vm instance on previously\r\n\t     * seen data. This allows us to achieve O(n) which is\r\n\t     * better than a levenshtein distance based algorithm,\r\n\t     * which is O(m * n).\r\n\t     *\r\n\t     * @param {Array} data\r\n\t     */\r\n\t\r\n\t    diff: function diff(data) {\r\n\t      // check if the Array was converted from an Object\r\n\t      var item = data[0];\r\n\t      var convertedFromObject = this.fromObject = isObject(item) && hasOwn(item, '$key') && hasOwn(item, '$value');\r\n\t\r\n\t      var trackByKey = this.params.trackBy;\r\n\t      var oldFrags = this.frags;\r\n\t      var frags = this.frags = new Array(data.length);\r\n\t      var alias = this.alias;\r\n\t      var iterator = this.iterator;\r\n\t      var start = this.start;\r\n\t      var end = this.end;\r\n\t      var inDocument = inDoc(start);\r\n\t      var init = !oldFrags;\r\n\t      var i, l, frag, key, value, primitive;\r\n\t\r\n\t      // First pass, go through the new Array and fill up\r\n\t      // the new frags array. If a piece of data has a cached\r\n\t      // instance for it, we reuse it. Otherwise build a new\r\n\t      // instance.\r\n\t      for (i = 0, l = data.length; i < l; i++) {\r\n\t        item = data[i];\r\n\t        key = convertedFromObject ? item.$key : null;\r\n\t        value = convertedFromObject ? item.$value : item;\r\n\t        primitive = !isObject(value);\r\n\t        frag = !init && this.getCachedFrag(value, i, key);\r\n\t        if (frag) {\r\n\t          // reusable fragment\r\n\t          frag.reused = true;\r\n\t          // update $index\r\n\t          frag.scope.$index = i;\r\n\t          // update $key\r\n\t          if (key) {\r\n\t            frag.scope.$key = key;\r\n\t          }\r\n\t          // update iterator\r\n\t          if (iterator) {\r\n\t            frag.scope[iterator] = key !== null ? key : i;\r\n\t          }\r\n\t          // update data for track-by, object repeat &\r\n\t          // primitive values.\r\n\t          if (trackByKey || convertedFromObject || primitive) {\r\n\t            withoutConversion(function () {\r\n\t              frag.scope[alias] = value;\r\n\t            });\r\n\t          }\r\n\t        } else {\r\n\t          // new isntance\r\n\t          frag = this.create(value, alias, i, key);\r\n\t          frag.fresh = !init;\r\n\t        }\r\n\t        frags[i] = frag;\r\n\t        if (init) {\r\n\t          frag.before(end);\r\n\t        }\r\n\t      }\r\n\t\r\n\t      // we're done for the initial render.\r\n\t      if (init) {\r\n\t        return;\r\n\t      }\r\n\t\r\n\t      // Second pass, go through the old fragments and\r\n\t      // destroy those who are not reused (and remove them\r\n\t      // from cache)\r\n\t      var removalIndex = 0;\r\n\t      var totalRemoved = oldFrags.length - frags.length;\r\n\t      // when removing a large number of fragments, watcher removal\r\n\t      // turns out to be a perf bottleneck, so we batch the watcher\r\n\t      // removals into a single filter call!\r\n\t      this.vm._vForRemoving = true;\r\n\t      for (i = 0, l = oldFrags.length; i < l; i++) {\r\n\t        frag = oldFrags[i];\r\n\t        if (!frag.reused) {\r\n\t          this.deleteCachedFrag(frag);\r\n\t          this.remove(frag, removalIndex++, totalRemoved, inDocument);\r\n\t        }\r\n\t      }\r\n\t      this.vm._vForRemoving = false;\r\n\t      if (removalIndex) {\r\n\t        this.vm._watchers = this.vm._watchers.filter(function (w) {\r\n\t          return w.active;\r\n\t        });\r\n\t      }\r\n\t\r\n\t      // Final pass, move/insert new fragments into the\r\n\t      // right place.\r\n\t      var targetPrev, prevEl, currentPrev;\r\n\t      var insertionIndex = 0;\r\n\t      for (i = 0, l = frags.length; i < l; i++) {\r\n\t        frag = frags[i];\r\n\t        // this is the frag that we should be after\r\n\t        targetPrev = frags[i - 1];\r\n\t        prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;\r\n\t        if (frag.reused && !frag.staggerCb) {\r\n\t          currentPrev = findPrevFrag(frag, start, this.id);\r\n\t          if (currentPrev !== targetPrev && (!currentPrev ||\r\n\t          // optimization for moving a single item.\r\n\t          // thanks to suggestions by @livoras in #1807\r\n\t          findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {\r\n\t            this.move(frag, prevEl);\r\n\t          }\r\n\t        } else {\r\n\t          // new instance, or still in stagger.\r\n\t          // insert with updated stagger index.\r\n\t          this.insert(frag, insertionIndex++, prevEl, inDocument);\r\n\t        }\r\n\t        frag.reused = frag.fresh = false;\r\n\t      }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Create a new fragment instance.\r\n\t     *\r\n\t     * @param {*} value\r\n\t     * @param {String} alias\r\n\t     * @param {Number} index\r\n\t     * @param {String} [key]\r\n\t     * @return {Fragment}\r\n\t     */\r\n\t\r\n\t    create: function create(value, alias, index, key) {\r\n\t      var host = this._host;\r\n\t      // create iteration scope\r\n\t      var parentScope = this._scope || this.vm;\r\n\t      var scope = Object.create(parentScope);\r\n\t      // ref holder for the scope\r\n\t      scope.$refs = Object.create(parentScope.$refs);\r\n\t      scope.$els = Object.create(parentScope.$els);\r\n\t      // make sure point $parent to parent scope\r\n\t      scope.$parent = parentScope;\r\n\t      // for two-way binding on alias\r\n\t      scope.$forContext = this;\r\n\t      // define scope properties\r\n\t      // important: define the scope alias without forced conversion\r\n\t      // so that frozen data structures remain non-reactive.\r\n\t      withoutConversion(function () {\r\n\t        defineReactive(scope, alias, value);\r\n\t      });\r\n\t      defineReactive(scope, '$index', index);\r\n\t      if (key) {\r\n\t        defineReactive(scope, '$key', key);\r\n\t      } else if (scope.$key) {\r\n\t        // avoid accidental fallback\r\n\t        def(scope, '$key', null);\r\n\t      }\r\n\t      if (this.iterator) {\r\n\t        defineReactive(scope, this.iterator, key !== null ? key : index);\r\n\t      }\r\n\t      var frag = this.factory.create(host, scope, this._frag);\r\n\t      frag.forId = this.id;\r\n\t      this.cacheFrag(value, frag, index, key);\r\n\t      return frag;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Update the v-ref on owner vm.\r\n\t     */\r\n\t\r\n\t    updateRef: function updateRef() {\r\n\t      var ref = this.descriptor.ref;\r\n\t      if (!ref) return;\r\n\t      var hash = (this._scope || this.vm).$refs;\r\n\t      var refs;\r\n\t      if (!this.fromObject) {\r\n\t        refs = this.frags.map(findVmFromFrag);\r\n\t      } else {\r\n\t        refs = {};\r\n\t        this.frags.forEach(function (frag) {\r\n\t          refs[frag.scope.$key] = findVmFromFrag(frag);\r\n\t        });\r\n\t      }\r\n\t      hash[ref] = refs;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * For option lists, update the containing v-model on\r\n\t     * parent <select>.\r\n\t     */\r\n\t\r\n\t    updateModel: function updateModel() {\r\n\t      if (this.isOption) {\r\n\t        var parent = this.start.parentNode;\r\n\t        var model = parent && parent.__v_model;\r\n\t        if (model) {\r\n\t          model.forceUpdate();\r\n\t        }\r\n\t      }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Insert a fragment. Handles staggering.\r\n\t     *\r\n\t     * @param {Fragment} frag\r\n\t     * @param {Number} index\r\n\t     * @param {Node} prevEl\r\n\t     * @param {Boolean} inDocument\r\n\t     */\r\n\t\r\n\t    insert: function insert(frag, index, prevEl, inDocument) {\r\n\t      if (frag.staggerCb) {\r\n\t        frag.staggerCb.cancel();\r\n\t        frag.staggerCb = null;\r\n\t      }\r\n\t      var staggerAmount = this.getStagger(frag, index, null, 'enter');\r\n\t      if (inDocument && staggerAmount) {\r\n\t        // create an anchor and insert it synchronously,\r\n\t        // so that we can resolve the correct order without\r\n\t        // worrying about some elements not inserted yet\r\n\t        var anchor = frag.staggerAnchor;\r\n\t        if (!anchor) {\r\n\t          anchor = frag.staggerAnchor = createAnchor('stagger-anchor');\r\n\t          anchor.__v_frag = frag;\r\n\t        }\r\n\t        after(anchor, prevEl);\r\n\t        var op = frag.staggerCb = cancellable(function () {\r\n\t          frag.staggerCb = null;\r\n\t          frag.before(anchor);\r\n\t          remove(anchor);\r\n\t        });\r\n\t        setTimeout(op, staggerAmount);\r\n\t      } else {\r\n\t        var target = prevEl.nextSibling;\r\n\t        /* istanbul ignore if */\r\n\t        if (!target) {\r\n\t          // reset end anchor position in case the position was messed up\r\n\t          // by an external drag-n-drop library.\r\n\t          after(this.end, prevEl);\r\n\t          target = this.end;\r\n\t        }\r\n\t        frag.before(target);\r\n\t      }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Remove a fragment. Handles staggering.\r\n\t     *\r\n\t     * @param {Fragment} frag\r\n\t     * @param {Number} index\r\n\t     * @param {Number} total\r\n\t     * @param {Boolean} inDocument\r\n\t     */\r\n\t\r\n\t    remove: function remove(frag, index, total, inDocument) {\r\n\t      if (frag.staggerCb) {\r\n\t        frag.staggerCb.cancel();\r\n\t        frag.staggerCb = null;\r\n\t        // it's not possible for the same frag to be removed\r\n\t        // twice, so if we have a pending stagger callback,\r\n\t        // it means this frag is queued for enter but removed\r\n\t        // before its transition started. Since it is already\r\n\t        // destroyed, we can just leave it in detached state.\r\n\t        return;\r\n\t      }\r\n\t      var staggerAmount = this.getStagger(frag, index, total, 'leave');\r\n\t      if (inDocument && staggerAmount) {\r\n\t        var op = frag.staggerCb = cancellable(function () {\r\n\t          frag.staggerCb = null;\r\n\t          frag.remove();\r\n\t        });\r\n\t        setTimeout(op, staggerAmount);\r\n\t      } else {\r\n\t        frag.remove();\r\n\t      }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Move a fragment to a new position.\r\n\t     * Force no transition.\r\n\t     *\r\n\t     * @param {Fragment} frag\r\n\t     * @param {Node} prevEl\r\n\t     */\r\n\t\r\n\t    move: function move(frag, prevEl) {\r\n\t      // fix a common issue with Sortable:\r\n\t      // if prevEl doesn't have nextSibling, this means it's\r\n\t      // been dragged after the end anchor. Just re-position\r\n\t      // the end anchor to the end of the container.\r\n\t      /* istanbul ignore if */\r\n\t      if (!prevEl.nextSibling) {\r\n\t        this.end.parentNode.appendChild(this.end);\r\n\t      }\r\n\t      frag.before(prevEl.nextSibling, false);\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Cache a fragment using track-by or the object key.\r\n\t     *\r\n\t     * @param {*} value\r\n\t     * @param {Fragment} frag\r\n\t     * @param {Number} index\r\n\t     * @param {String} [key]\r\n\t     */\r\n\t\r\n\t    cacheFrag: function cacheFrag(value, frag, index, key) {\r\n\t      var trackByKey = this.params.trackBy;\r\n\t      var cache = this.cache;\r\n\t      var primitive = !isObject(value);\r\n\t      var id;\r\n\t      if (key || trackByKey || primitive) {\r\n\t        id = getTrackByKey(index, key, value, trackByKey);\r\n\t        if (!cache[id]) {\r\n\t          cache[id] = frag;\r\n\t        } else if (trackByKey !== '$index') {\r\n\t          'development' !== 'production' && this.warnDuplicate(value);\r\n\t        }\r\n\t      } else {\r\n\t        id = this.id;\r\n\t        if (hasOwn(value, id)) {\r\n\t          if (value[id] === null) {\r\n\t            value[id] = frag;\r\n\t          } else {\r\n\t            'development' !== 'production' && this.warnDuplicate(value);\r\n\t          }\r\n\t        } else if (Object.isExtensible(value)) {\r\n\t          def(value, id, frag);\r\n\t        } else if (true) {\r\n\t          warn('Frozen v-for objects cannot be automatically tracked, make sure to ' + 'provide a track-by key.');\r\n\t        }\r\n\t      }\r\n\t      frag.raw = value;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Get a cached fragment from the value/index/key\r\n\t     *\r\n\t     * @param {*} value\r\n\t     * @param {Number} index\r\n\t     * @param {String} key\r\n\t     * @return {Fragment}\r\n\t     */\r\n\t\r\n\t    getCachedFrag: function getCachedFrag(value, index, key) {\r\n\t      var trackByKey = this.params.trackBy;\r\n\t      var primitive = !isObject(value);\r\n\t      var frag;\r\n\t      if (key || trackByKey || primitive) {\r\n\t        var id = getTrackByKey(index, key, value, trackByKey);\r\n\t        frag = this.cache[id];\r\n\t      } else {\r\n\t        frag = value[this.id];\r\n\t      }\r\n\t      if (frag && (frag.reused || frag.fresh)) {\r\n\t        'development' !== 'production' && this.warnDuplicate(value);\r\n\t      }\r\n\t      return frag;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Delete a fragment from cache.\r\n\t     *\r\n\t     * @param {Fragment} frag\r\n\t     */\r\n\t\r\n\t    deleteCachedFrag: function deleteCachedFrag(frag) {\r\n\t      var value = frag.raw;\r\n\t      var trackByKey = this.params.trackBy;\r\n\t      var scope = frag.scope;\r\n\t      var index = scope.$index;\r\n\t      // fix #948: avoid accidentally fall through to\r\n\t      // a parent repeater which happens to have $key.\r\n\t      var key = hasOwn(scope, '$key') && scope.$key;\r\n\t      var primitive = !isObject(value);\r\n\t      if (trackByKey || key || primitive) {\r\n\t        var id = getTrackByKey(index, key, value, trackByKey);\r\n\t        this.cache[id] = null;\r\n\t      } else {\r\n\t        value[this.id] = null;\r\n\t        frag.raw = null;\r\n\t      }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Get the stagger amount for an insertion/removal.\r\n\t     *\r\n\t     * @param {Fragment} frag\r\n\t     * @param {Number} index\r\n\t     * @param {Number} total\r\n\t     * @param {String} type\r\n\t     */\r\n\t\r\n\t    getStagger: function getStagger(frag, index, total, type) {\r\n\t      type = type + 'Stagger';\r\n\t      var trans = frag.node.__v_trans;\r\n\t      var hooks = trans && trans.hooks;\r\n\t      var hook = hooks && (hooks[type] || hooks.stagger);\r\n\t      return hook ? hook.call(frag, index, total) : index * parseInt(this.params[type] || this.params.stagger, 10);\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Pre-process the value before piping it through the\r\n\t     * filters. This is passed to and called by the watcher.\r\n\t     */\r\n\t\r\n\t    _preProcess: function _preProcess(value) {\r\n\t      // regardless of type, store the un-filtered raw value.\r\n\t      this.rawValue = value;\r\n\t      return value;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Post-process the value after it has been piped through\r\n\t     * the filters. This is passed to and called by the watcher.\r\n\t     *\r\n\t     * It is necessary for this to be called during the\r\n\t     * watcher's dependency collection phase because we want\r\n\t     * the v-for to update when the source Object is mutated.\r\n\t     */\r\n\t\r\n\t    _postProcess: function _postProcess(value) {\r\n\t      if (isArray(value)) {\r\n\t        return value;\r\n\t      } else if (isPlainObject(value)) {\r\n\t        // convert plain object to array.\r\n\t        var keys = Object.keys(value);\r\n\t        var i = keys.length;\r\n\t        var res = new Array(i);\r\n\t        var key;\r\n\t        while (i--) {\r\n\t          key = keys[i];\r\n\t          res[i] = {\r\n\t            $key: key,\r\n\t            $value: value[key]\r\n\t          };\r\n\t        }\r\n\t        return res;\r\n\t      } else {\r\n\t        if (typeof value === 'number' && !isNaN(value)) {\r\n\t          value = range(value);\r\n\t        }\r\n\t        return value || [];\r\n\t      }\r\n\t    },\r\n\t\r\n\t    unbind: function unbind() {\r\n\t      if (this.descriptor.ref) {\r\n\t        (this._scope || this.vm).$refs[this.descriptor.ref] = null;\r\n\t      }\r\n\t      if (this.frags) {\r\n\t        var i = this.frags.length;\r\n\t        var frag;\r\n\t        while (i--) {\r\n\t          frag = this.frags[i];\r\n\t          this.deleteCachedFrag(frag);\r\n\t          frag.destroy();\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Helper to find the previous element that is a fragment\r\n\t   * anchor. This is necessary because a destroyed frag's\r\n\t   * element could still be lingering in the DOM before its\r\n\t   * leaving transition finishes, but its inserted flag\r\n\t   * should have been set to false so we can skip them.\r\n\t   *\r\n\t   * If this is a block repeat, we want to make sure we only\r\n\t   * return frag that is bound to this v-for. (see #929)\r\n\t   *\r\n\t   * @param {Fragment} frag\r\n\t   * @param {Comment|Text} anchor\r\n\t   * @param {String} id\r\n\t   * @return {Fragment}\r\n\t   */\r\n\t\r\n\t  function findPrevFrag(frag, anchor, id) {\r\n\t    var el = frag.node.previousSibling;\r\n\t    /* istanbul ignore if */\r\n\t    if (!el) return;\r\n\t    frag = el.__v_frag;\r\n\t    while ((!frag || frag.forId !== id || !frag.inserted) && el !== anchor) {\r\n\t      el = el.previousSibling;\r\n\t      /* istanbul ignore if */\r\n\t      if (!el) return;\r\n\t      frag = el.__v_frag;\r\n\t    }\r\n\t    return frag;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Find a vm from a fragment.\r\n\t   *\r\n\t   * @param {Fragment} frag\r\n\t   * @return {Vue|undefined}\r\n\t   */\r\n\t\r\n\t  function findVmFromFrag(frag) {\r\n\t    var node = frag.node;\r\n\t    // handle multi-node frag\r\n\t    if (frag.end) {\r\n\t      while (!node.__vue__ && node !== frag.end && node.nextSibling) {\r\n\t        node = node.nextSibling;\r\n\t      }\r\n\t    }\r\n\t    return node.__vue__;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Create a range array from given number.\r\n\t   *\r\n\t   * @param {Number} n\r\n\t   * @return {Array}\r\n\t   */\r\n\t\r\n\t  function range(n) {\r\n\t    var i = -1;\r\n\t    var ret = new Array(Math.floor(n));\r\n\t    while (++i < n) {\r\n\t      ret[i] = i;\r\n\t    }\r\n\t    return ret;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Get the track by key for an item.\r\n\t   *\r\n\t   * @param {Number} index\r\n\t   * @param {String} key\r\n\t   * @param {*} value\r\n\t   * @param {String} [trackByKey]\r\n\t   */\r\n\t\r\n\t  function getTrackByKey(index, key, value, trackByKey) {\r\n\t    return trackByKey ? trackByKey === '$index' ? index : trackByKey.charAt(0).match(/\\w/) ? getPath(value, trackByKey) : value[trackByKey] : key || value;\r\n\t  }\r\n\t\r\n\t  if (true) {\r\n\t    vFor.warnDuplicate = function (value) {\r\n\t      warn('Duplicate value found in v-for=\"' + this.descriptor.raw + '\": ' + JSON.stringify(value) + '. Use track-by=\"$index\" if ' + 'you are expecting duplicate values.', this.vm);\r\n\t    };\r\n\t  }\r\n\t\r\n\t  var vIf = {\r\n\t\r\n\t    priority: IF,\r\n\t    terminal: true,\r\n\t\r\n\t    bind: function bind() {\r\n\t      var el = this.el;\r\n\t      if (!el.__vue__) {\r\n\t        // check else block\r\n\t        var next = el.nextElementSibling;\r\n\t        if (next && getAttr(next, 'v-else') !== null) {\r\n\t          remove(next);\r\n\t          this.elseEl = next;\r\n\t        }\r\n\t        // check main block\r\n\t        this.anchor = createAnchor('v-if');\r\n\t        replace(el, this.anchor);\r\n\t      } else {\r\n\t        'development' !== 'production' && warn('v-if=\"' + this.expression + '\" cannot be ' + 'used on an instance root element.', this.vm);\r\n\t        this.invalid = true;\r\n\t      }\r\n\t    },\r\n\t\r\n\t    update: function update(value) {\r\n\t      if (this.invalid) return;\r\n\t      if (value) {\r\n\t        if (!this.frag) {\r\n\t          this.insert();\r\n\t        }\r\n\t      } else {\r\n\t        this.remove();\r\n\t      }\r\n\t    },\r\n\t\r\n\t    insert: function insert() {\r\n\t      if (this.elseFrag) {\r\n\t        this.elseFrag.remove();\r\n\t        this.elseFrag = null;\r\n\t      }\r\n\t      // lazy init factory\r\n\t      if (!this.factory) {\r\n\t        this.factory = new FragmentFactory(this.vm, this.el);\r\n\t      }\r\n\t      this.frag = this.factory.create(this._host, this._scope, this._frag);\r\n\t      this.frag.before(this.anchor);\r\n\t    },\r\n\t\r\n\t    remove: function remove() {\r\n\t      if (this.frag) {\r\n\t        this.frag.remove();\r\n\t        this.frag = null;\r\n\t      }\r\n\t      if (this.elseEl && !this.elseFrag) {\r\n\t        if (!this.elseFactory) {\r\n\t          this.elseFactory = new FragmentFactory(this.elseEl._context || this.vm, this.elseEl);\r\n\t        }\r\n\t        this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag);\r\n\t        this.elseFrag.before(this.anchor);\r\n\t      }\r\n\t    },\r\n\t\r\n\t    unbind: function unbind() {\r\n\t      if (this.frag) {\r\n\t        this.frag.destroy();\r\n\t      }\r\n\t      if (this.elseFrag) {\r\n\t        this.elseFrag.destroy();\r\n\t      }\r\n\t    }\r\n\t  };\r\n\t\r\n\t  var show = {\r\n\t\r\n\t    bind: function bind() {\r\n\t      // check else block\r\n\t      var next = this.el.nextElementSibling;\r\n\t      if (next && getAttr(next, 'v-else') !== null) {\r\n\t        this.elseEl = next;\r\n\t      }\r\n\t    },\r\n\t\r\n\t    update: function update(value) {\r\n\t      this.apply(this.el, value);\r\n\t      if (this.elseEl) {\r\n\t        this.apply(this.elseEl, !value);\r\n\t      }\r\n\t    },\r\n\t\r\n\t    apply: function apply(el, value) {\r\n\t      if (inDoc(el)) {\r\n\t        applyTransition(el, value ? 1 : -1, toggle, this.vm);\r\n\t      } else {\r\n\t        toggle();\r\n\t      }\r\n\t      function toggle() {\r\n\t        el.style.display = value ? '' : 'none';\r\n\t      }\r\n\t    }\r\n\t  };\r\n\t\r\n\t  var text$2 = {\r\n\t\r\n\t    bind: function bind() {\r\n\t      var self = this;\r\n\t      var el = this.el;\r\n\t      var isRange = el.type === 'range';\r\n\t      var lazy = this.params.lazy;\r\n\t      var number = this.params.number;\r\n\t      var debounce = this.params.debounce;\r\n\t\r\n\t      // handle composition events.\r\n\t      //   http://blog.evanyou.me/2014/01/03/composition-event/\r\n\t      // skip this for Android because it handles composition\r\n\t      // events quite differently. Android doesn't trigger\r\n\t      // composition events for language input methods e.g.\r\n\t      // Chinese, but instead triggers them for spelling\r\n\t      // suggestions... (see Discussion/#162)\r\n\t      var composing = false;\r\n\t      if (!isAndroid && !isRange) {\r\n\t        this.on('compositionstart', function () {\r\n\t          composing = true;\r\n\t        });\r\n\t        this.on('compositionend', function () {\r\n\t          composing = false;\r\n\t          // in IE11 the \"compositionend\" event fires AFTER\r\n\t          // the \"input\" event, so the input handler is blocked\r\n\t          // at the end... have to call it here.\r\n\t          //\r\n\t          // #1327: in lazy mode this is unecessary.\r\n\t          if (!lazy) {\r\n\t            self.listener();\r\n\t          }\r\n\t        });\r\n\t      }\r\n\t\r\n\t      // prevent messing with the input when user is typing,\r\n\t      // and force update on blur.\r\n\t      this.focused = false;\r\n\t      if (!isRange && !lazy) {\r\n\t        this.on('focus', function () {\r\n\t          self.focused = true;\r\n\t        });\r\n\t        this.on('blur', function () {\r\n\t          self.focused = false;\r\n\t          // do not sync value after fragment removal (#2017)\r\n\t          if (!self._frag || self._frag.inserted) {\r\n\t            self.rawListener();\r\n\t          }\r\n\t        });\r\n\t      }\r\n\t\r\n\t      // Now attach the main listener\r\n\t      this.listener = this.rawListener = function () {\r\n\t        if (composing || !self._bound) {\r\n\t          return;\r\n\t        }\r\n\t        var val = number || isRange ? toNumber(el.value) : el.value;\r\n\t        self.set(val);\r\n\t        // force update on next tick to avoid lock & same value\r\n\t        // also only update when user is not typing\r\n\t        nextTick(function () {\r\n\t          if (self._bound && !self.focused) {\r\n\t            self.update(self._watcher.value);\r\n\t          }\r\n\t        });\r\n\t      };\r\n\t\r\n\t      // apply debounce\r\n\t      if (debounce) {\r\n\t        this.listener = _debounce(this.listener, debounce);\r\n\t      }\r\n\t\r\n\t      // Support jQuery events, since jQuery.trigger() doesn't\r\n\t      // trigger native events in some cases and some plugins\r\n\t      // rely on $.trigger()\r\n\t      //\r\n\t      // We want to make sure if a listener is attached using\r\n\t      // jQuery, it is also removed with jQuery, that's why\r\n\t      // we do the check for each directive instance and\r\n\t      // store that check result on itself. This also allows\r\n\t      // easier test coverage control by unsetting the global\r\n\t      // jQuery variable in tests.\r\n\t      this.hasjQuery = typeof jQuery === 'function';\r\n\t      if (this.hasjQuery) {\r\n\t        var method = jQuery.fn.on ? 'on' : 'bind';\r\n\t        jQuery(el)[method]('change', this.rawListener);\r\n\t        if (!lazy) {\r\n\t          jQuery(el)[method]('input', this.listener);\r\n\t        }\r\n\t      } else {\r\n\t        this.on('change', this.rawListener);\r\n\t        if (!lazy) {\r\n\t          this.on('input', this.listener);\r\n\t        }\r\n\t      }\r\n\t\r\n\t      // IE9 doesn't fire input event on backspace/del/cut\r\n\t      if (!lazy && isIE9) {\r\n\t        this.on('cut', function () {\r\n\t          nextTick(self.listener);\r\n\t        });\r\n\t        this.on('keyup', function (e) {\r\n\t          if (e.keyCode === 46 || e.keyCode === 8) {\r\n\t            self.listener();\r\n\t          }\r\n\t        });\r\n\t      }\r\n\t\r\n\t      // set initial value if present\r\n\t      if (el.hasAttribute('value') || el.tagName === 'TEXTAREA' && el.value.trim()) {\r\n\t        this.afterBind = this.listener;\r\n\t      }\r\n\t    },\r\n\t\r\n\t    update: function update(value) {\r\n\t      // #3029 only update when the value changes. This prevent\r\n\t      // browsers from overwriting values like selectionStart\r\n\t      value = _toString(value);\r\n\t      if (value !== this.el.value) this.el.value = value;\r\n\t    },\r\n\t\r\n\t    unbind: function unbind() {\r\n\t      var el = this.el;\r\n\t      if (this.hasjQuery) {\r\n\t        var method = jQuery.fn.off ? 'off' : 'unbind';\r\n\t        jQuery(el)[method]('change', this.listener);\r\n\t        jQuery(el)[method]('input', this.listener);\r\n\t      }\r\n\t    }\r\n\t  };\r\n\t\r\n\t  var radio = {\r\n\t\r\n\t    bind: function bind() {\r\n\t      var self = this;\r\n\t      var el = this.el;\r\n\t\r\n\t      this.getValue = function () {\r\n\t        // value overwrite via v-bind:value\r\n\t        if (el.hasOwnProperty('_value')) {\r\n\t          return el._value;\r\n\t        }\r\n\t        var val = el.value;\r\n\t        if (self.params.number) {\r\n\t          val = toNumber(val);\r\n\t        }\r\n\t        return val;\r\n\t      };\r\n\t\r\n\t      this.listener = function () {\r\n\t        self.set(self.getValue());\r\n\t      };\r\n\t      this.on('change', this.listener);\r\n\t\r\n\t      if (el.hasAttribute('checked')) {\r\n\t        this.afterBind = this.listener;\r\n\t      }\r\n\t    },\r\n\t\r\n\t    update: function update(value) {\r\n\t      this.el.checked = looseEqual(value, this.getValue());\r\n\t    }\r\n\t  };\r\n\t\r\n\t  var select = {\r\n\t\r\n\t    bind: function bind() {\r\n\t      var _this = this;\r\n\t\r\n\t      var self = this;\r\n\t      var el = this.el;\r\n\t\r\n\t      // method to force update DOM using latest value.\r\n\t      this.forceUpdate = function () {\r\n\t        if (self._watcher) {\r\n\t          self.update(self._watcher.get());\r\n\t        }\r\n\t      };\r\n\t\r\n\t      // check if this is a multiple select\r\n\t      var multiple = this.multiple = el.hasAttribute('multiple');\r\n\t\r\n\t      // attach listener\r\n\t      this.listener = function () {\r\n\t        var value = getValue(el, multiple);\r\n\t        value = self.params.number ? isArray(value) ? value.map(toNumber) : toNumber(value) : value;\r\n\t        self.set(value);\r\n\t      };\r\n\t      this.on('change', this.listener);\r\n\t\r\n\t      // if has initial value, set afterBind\r\n\t      var initValue = getValue(el, multiple, true);\r\n\t      if (multiple && initValue.length || !multiple && initValue !== null) {\r\n\t        this.afterBind = this.listener;\r\n\t      }\r\n\t\r\n\t      // All major browsers except Firefox resets\r\n\t      // selectedIndex with value -1 to 0 when the element\r\n\t      // is appended to a new parent, therefore we have to\r\n\t      // force a DOM update whenever that happens...\r\n\t      this.vm.$on('hook:attached', function () {\r\n\t        nextTick(_this.forceUpdate);\r\n\t      });\r\n\t      if (!inDoc(el)) {\r\n\t        nextTick(this.forceUpdate);\r\n\t      }\r\n\t    },\r\n\t\r\n\t    update: function update(value) {\r\n\t      var el = this.el;\r\n\t      el.selectedIndex = -1;\r\n\t      var multi = this.multiple && isArray(value);\r\n\t      var options = el.options;\r\n\t      var i = options.length;\r\n\t      var op, val;\r\n\t      while (i--) {\r\n\t        op = options[i];\r\n\t        val = op.hasOwnProperty('_value') ? op._value : op.value;\r\n\t        /* eslint-disable eqeqeq */\r\n\t        op.selected = multi ? indexOf$1(value, val) > -1 : looseEqual(value, val);\r\n\t        /* eslint-enable eqeqeq */\r\n\t      }\r\n\t    },\r\n\t\r\n\t    unbind: function unbind() {\r\n\t      /* istanbul ignore next */\r\n\t      this.vm.$off('hook:attached', this.forceUpdate);\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Get select value\r\n\t   *\r\n\t   * @param {SelectElement} el\r\n\t   * @param {Boolean} multi\r\n\t   * @param {Boolean} init\r\n\t   * @return {Array|*}\r\n\t   */\r\n\t\r\n\t  function getValue(el, multi, init) {\r\n\t    var res = multi ? [] : null;\r\n\t    var op, val, selected;\r\n\t    for (var i = 0, l = el.options.length; i < l; i++) {\r\n\t      op = el.options[i];\r\n\t      selected = init ? op.hasAttribute('selected') : op.selected;\r\n\t      if (selected) {\r\n\t        val = op.hasOwnProperty('_value') ? op._value : op.value;\r\n\t        if (multi) {\r\n\t          res.push(val);\r\n\t        } else {\r\n\t          return val;\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t    return res;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Native Array.indexOf uses strict equal, but in this\r\n\t   * case we need to match string/numbers with custom equal.\r\n\t   *\r\n\t   * @param {Array} arr\r\n\t   * @param {*} val\r\n\t   */\r\n\t\r\n\t  function indexOf$1(arr, val) {\r\n\t    var i = arr.length;\r\n\t    while (i--) {\r\n\t      if (looseEqual(arr[i], val)) {\r\n\t        return i;\r\n\t      }\r\n\t    }\r\n\t    return -1;\r\n\t  }\r\n\t\r\n\t  var checkbox = {\r\n\t\r\n\t    bind: function bind() {\r\n\t      var self = this;\r\n\t      var el = this.el;\r\n\t\r\n\t      this.getValue = function () {\r\n\t        return el.hasOwnProperty('_value') ? el._value : self.params.number ? toNumber(el.value) : el.value;\r\n\t      };\r\n\t\r\n\t      function getBooleanValue() {\r\n\t        var val = el.checked;\r\n\t        if (val && el.hasOwnProperty('_trueValue')) {\r\n\t          return el._trueValue;\r\n\t        }\r\n\t        if (!val && el.hasOwnProperty('_falseValue')) {\r\n\t          return el._falseValue;\r\n\t        }\r\n\t        return val;\r\n\t      }\r\n\t\r\n\t      this.listener = function () {\r\n\t        var model = self._watcher.value;\r\n\t        if (isArray(model)) {\r\n\t          var val = self.getValue();\r\n\t          if (el.checked) {\r\n\t            if (indexOf(model, val) < 0) {\r\n\t              model.push(val);\r\n\t            }\r\n\t          } else {\r\n\t            model.$remove(val);\r\n\t          }\r\n\t        } else {\r\n\t          self.set(getBooleanValue());\r\n\t        }\r\n\t      };\r\n\t\r\n\t      this.on('change', this.listener);\r\n\t      if (el.hasAttribute('checked')) {\r\n\t        this.afterBind = this.listener;\r\n\t      }\r\n\t    },\r\n\t\r\n\t    update: function update(value) {\r\n\t      var el = this.el;\r\n\t      if (isArray(value)) {\r\n\t        el.checked = indexOf(value, this.getValue()) > -1;\r\n\t      } else {\r\n\t        if (el.hasOwnProperty('_trueValue')) {\r\n\t          el.checked = looseEqual(value, el._trueValue);\r\n\t        } else {\r\n\t          el.checked = !!value;\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t  };\r\n\t\r\n\t  var handlers = {\r\n\t    text: text$2,\r\n\t    radio: radio,\r\n\t    select: select,\r\n\t    checkbox: checkbox\r\n\t  };\r\n\t\r\n\t  var model = {\r\n\t\r\n\t    priority: MODEL,\r\n\t    twoWay: true,\r\n\t    handlers: handlers,\r\n\t    params: ['lazy', 'number', 'debounce'],\r\n\t\r\n\t    /**\r\n\t     * Possible elements:\r\n\t     *   <select>\r\n\t     *   <textarea>\r\n\t     *   <input type=\"*\">\r\n\t     *     - text\r\n\t     *     - checkbox\r\n\t     *     - radio\r\n\t     *     - number\r\n\t     */\r\n\t\r\n\t    bind: function bind() {\r\n\t      // friendly warning...\r\n\t      this.checkFilters();\r\n\t      if (this.hasRead && !this.hasWrite) {\r\n\t        'development' !== 'production' && warn('It seems you are using a read-only filter with ' + 'v-model=\"' + this.descriptor.raw + '\". ' + 'You might want to use a two-way filter to ensure correct behavior.', this.vm);\r\n\t      }\r\n\t      var el = this.el;\r\n\t      var tag = el.tagName;\r\n\t      var handler;\r\n\t      if (tag === 'INPUT') {\r\n\t        handler = handlers[el.type] || handlers.text;\r\n\t      } else if (tag === 'SELECT') {\r\n\t        handler = handlers.select;\r\n\t      } else if (tag === 'TEXTAREA') {\r\n\t        handler = handlers.text;\r\n\t      } else {\r\n\t        'development' !== 'production' && warn('v-model does not support element type: ' + tag, this.vm);\r\n\t        return;\r\n\t      }\r\n\t      el.__v_model = this;\r\n\t      handler.bind.call(this);\r\n\t      this.update = handler.update;\r\n\t      this._unbind = handler.unbind;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Check read/write filter stats.\r\n\t     */\r\n\t\r\n\t    checkFilters: function checkFilters() {\r\n\t      var filters = this.filters;\r\n\t      if (!filters) return;\r\n\t      var i = filters.length;\r\n\t      while (i--) {\r\n\t        var filter = resolveAsset(this.vm.$options, 'filters', filters[i].name);\r\n\t        if (typeof filter === 'function' || filter.read) {\r\n\t          this.hasRead = true;\r\n\t        }\r\n\t        if (filter.write) {\r\n\t          this.hasWrite = true;\r\n\t        }\r\n\t      }\r\n\t    },\r\n\t\r\n\t    unbind: function unbind() {\r\n\t      this.el.__v_model = null;\r\n\t      this._unbind && this._unbind();\r\n\t    }\r\n\t  };\r\n\t\r\n\t  // keyCode aliases\r\n\t  var keyCodes = {\r\n\t    esc: 27,\r\n\t    tab: 9,\r\n\t    enter: 13,\r\n\t    space: 32,\r\n\t    'delete': [8, 46],\r\n\t    up: 38,\r\n\t    left: 37,\r\n\t    right: 39,\r\n\t    down: 40\r\n\t  };\r\n\t\r\n\t  function keyFilter(handler, keys) {\r\n\t    var codes = keys.map(function (key) {\r\n\t      var charCode = key.charCodeAt(0);\r\n\t      if (charCode > 47 && charCode < 58) {\r\n\t        return parseInt(key, 10);\r\n\t      }\r\n\t      if (key.length === 1) {\r\n\t        charCode = key.toUpperCase().charCodeAt(0);\r\n\t        if (charCode > 64 && charCode < 91) {\r\n\t          return charCode;\r\n\t        }\r\n\t      }\r\n\t      return keyCodes[key];\r\n\t    });\r\n\t    codes = [].concat.apply([], codes);\r\n\t    return function keyHandler(e) {\r\n\t      if (codes.indexOf(e.keyCode) > -1) {\r\n\t        return handler.call(this, e);\r\n\t      }\r\n\t    };\r\n\t  }\r\n\t\r\n\t  function stopFilter(handler) {\r\n\t    return function stopHandler(e) {\r\n\t      e.stopPropagation();\r\n\t      return handler.call(this, e);\r\n\t    };\r\n\t  }\r\n\t\r\n\t  function preventFilter(handler) {\r\n\t    return function preventHandler(e) {\r\n\t      e.preventDefault();\r\n\t      return handler.call(this, e);\r\n\t    };\r\n\t  }\r\n\t\r\n\t  function selfFilter(handler) {\r\n\t    return function selfHandler(e) {\r\n\t      if (e.target === e.currentTarget) {\r\n\t        return handler.call(this, e);\r\n\t      }\r\n\t    };\r\n\t  }\r\n\t\r\n\t  var on$1 = {\r\n\t\r\n\t    priority: ON,\r\n\t    acceptStatement: true,\r\n\t    keyCodes: keyCodes,\r\n\t\r\n\t    bind: function bind() {\r\n\t      // deal with iframes\r\n\t      if (this.el.tagName === 'IFRAME' && this.arg !== 'load') {\r\n\t        var self = this;\r\n\t        this.iframeBind = function () {\r\n\t          on(self.el.contentWindow, self.arg, self.handler, self.modifiers.capture);\r\n\t        };\r\n\t        this.on('load', this.iframeBind);\r\n\t      }\r\n\t    },\r\n\t\r\n\t    update: function update(handler) {\r\n\t      // stub a noop for v-on with no value,\r\n\t      // e.g. @mousedown.prevent\r\n\t      if (!this.descriptor.raw) {\r\n\t        handler = function () {};\r\n\t      }\r\n\t\r\n\t      if (typeof handler !== 'function') {\r\n\t        'development' !== 'production' && warn('v-on:' + this.arg + '=\"' + this.expression + '\" expects a function value, ' + 'got ' + handler, this.vm);\r\n\t        return;\r\n\t      }\r\n\t\r\n\t      // apply modifiers\r\n\t      if (this.modifiers.stop) {\r\n\t        handler = stopFilter(handler);\r\n\t      }\r\n\t      if (this.modifiers.prevent) {\r\n\t        handler = preventFilter(handler);\r\n\t      }\r\n\t      if (this.modifiers.self) {\r\n\t        handler = selfFilter(handler);\r\n\t      }\r\n\t      // key filter\r\n\t      var keys = Object.keys(this.modifiers).filter(function (key) {\r\n\t        return key !== 'stop' && key !== 'prevent' && key !== 'self' && key !== 'capture';\r\n\t      });\r\n\t      if (keys.length) {\r\n\t        handler = keyFilter(handler, keys);\r\n\t      }\r\n\t\r\n\t      this.reset();\r\n\t      this.handler = handler;\r\n\t\r\n\t      if (this.iframeBind) {\r\n\t        this.iframeBind();\r\n\t      } else {\r\n\t        on(this.el, this.arg, this.handler, this.modifiers.capture);\r\n\t      }\r\n\t    },\r\n\t\r\n\t    reset: function reset() {\r\n\t      var el = this.iframeBind ? this.el.contentWindow : this.el;\r\n\t      if (this.handler) {\r\n\t        off(el, this.arg, this.handler);\r\n\t      }\r\n\t    },\r\n\t\r\n\t    unbind: function unbind() {\r\n\t      this.reset();\r\n\t    }\r\n\t  };\r\n\t\r\n\t  var prefixes = ['-webkit-', '-moz-', '-ms-'];\r\n\t  var camelPrefixes = ['Webkit', 'Moz', 'ms'];\r\n\t  var importantRE = /!important;?$/;\r\n\t  var propCache = Object.create(null);\r\n\t\r\n\t  var testEl = null;\r\n\t\r\n\t  var style = {\r\n\t\r\n\t    deep: true,\r\n\t\r\n\t    update: function update(value) {\r\n\t      if (typeof value === 'string') {\r\n\t        this.el.style.cssText = value;\r\n\t      } else if (isArray(value)) {\r\n\t        this.handleObject(value.reduce(extend, {}));\r\n\t      } else {\r\n\t        this.handleObject(value || {});\r\n\t      }\r\n\t    },\r\n\t\r\n\t    handleObject: function handleObject(value) {\r\n\t      // cache object styles so that only changed props\r\n\t      // are actually updated.\r\n\t      var cache = this.cache || (this.cache = {});\r\n\t      var name, val;\r\n\t      for (name in cache) {\r\n\t        if (!(name in value)) {\r\n\t          this.handleSingle(name, null);\r\n\t          delete cache[name];\r\n\t        }\r\n\t      }\r\n\t      for (name in value) {\r\n\t        val = value[name];\r\n\t        if (val !== cache[name]) {\r\n\t          cache[name] = val;\r\n\t          this.handleSingle(name, val);\r\n\t        }\r\n\t      }\r\n\t    },\r\n\t\r\n\t    handleSingle: function handleSingle(prop, value) {\r\n\t      prop = normalize(prop);\r\n\t      if (!prop) return; // unsupported prop\r\n\t      // cast possible numbers/booleans into strings\r\n\t      if (value != null) value += '';\r\n\t      if (value) {\r\n\t        var isImportant = importantRE.test(value) ? 'important' : '';\r\n\t        if (isImportant) {\r\n\t          /* istanbul ignore if */\r\n\t          if (true) {\r\n\t            warn('It\\'s probably a bad idea to use !important with inline rules. ' + 'This feature will be deprecated in a future version of Vue.');\r\n\t          }\r\n\t          value = value.replace(importantRE, '').trim();\r\n\t          this.el.style.setProperty(prop.kebab, value, isImportant);\r\n\t        } else {\r\n\t          this.el.style[prop.camel] = value;\r\n\t        }\r\n\t      } else {\r\n\t        this.el.style[prop.camel] = '';\r\n\t      }\r\n\t    }\r\n\t\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Normalize a CSS property name.\r\n\t   * - cache result\r\n\t   * - auto prefix\r\n\t   * - camelCase -> dash-case\r\n\t   *\r\n\t   * @param {String} prop\r\n\t   * @return {String}\r\n\t   */\r\n\t\r\n\t  function normalize(prop) {\r\n\t    if (propCache[prop]) {\r\n\t      return propCache[prop];\r\n\t    }\r\n\t    var res = prefix(prop);\r\n\t    propCache[prop] = propCache[res] = res;\r\n\t    return res;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Auto detect the appropriate prefix for a CSS property.\r\n\t   * https://gist.github.com/paulirish/523692\r\n\t   *\r\n\t   * @param {String} prop\r\n\t   * @return {String}\r\n\t   */\r\n\t\r\n\t  function prefix(prop) {\r\n\t    prop = hyphenate(prop);\r\n\t    var camel = camelize(prop);\r\n\t    var upper = camel.charAt(0).toUpperCase() + camel.slice(1);\r\n\t    if (!testEl) {\r\n\t      testEl = document.createElement('div');\r\n\t    }\r\n\t    var i = prefixes.length;\r\n\t    var prefixed;\r\n\t    if (camel !== 'filter' && camel in testEl.style) {\r\n\t      return {\r\n\t        kebab: prop,\r\n\t        camel: camel\r\n\t      };\r\n\t    }\r\n\t    while (i--) {\r\n\t      prefixed = camelPrefixes[i] + upper;\r\n\t      if (prefixed in testEl.style) {\r\n\t        return {\r\n\t          kebab: prefixes[i] + prop,\r\n\t          camel: prefixed\r\n\t        };\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t\r\n\t  // xlink\r\n\t  var xlinkNS = 'http://www.w3.org/1999/xlink';\r\n\t  var xlinkRE = /^xlink:/;\r\n\t\r\n\t  // check for attributes that prohibit interpolations\r\n\t  var disallowedInterpAttrRE = /^v-|^:|^@|^(?:is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/;\r\n\t  // these attributes should also set their corresponding properties\r\n\t  // because they only affect the initial state of the element\r\n\t  var attrWithPropsRE = /^(?:value|checked|selected|muted)$/;\r\n\t  // these attributes expect enumrated values of \"true\" or \"false\"\r\n\t  // but are not boolean attributes\r\n\t  var enumeratedAttrRE = /^(?:draggable|contenteditable|spellcheck)$/;\r\n\t\r\n\t  // these attributes should set a hidden property for\r\n\t  // binding v-model to object values\r\n\t  var modelProps = {\r\n\t    value: '_value',\r\n\t    'true-value': '_trueValue',\r\n\t    'false-value': '_falseValue'\r\n\t  };\r\n\t\r\n\t  var bind$1 = {\r\n\t\r\n\t    priority: BIND,\r\n\t\r\n\t    bind: function bind() {\r\n\t      var attr = this.arg;\r\n\t      var tag = this.el.tagName;\r\n\t      // should be deep watch on object mode\r\n\t      if (!attr) {\r\n\t        this.deep = true;\r\n\t      }\r\n\t      // handle interpolation bindings\r\n\t      var descriptor = this.descriptor;\r\n\t      var tokens = descriptor.interp;\r\n\t      if (tokens) {\r\n\t        // handle interpolations with one-time tokens\r\n\t        if (descriptor.hasOneTime) {\r\n\t          this.expression = tokensToExp(tokens, this._scope || this.vm);\r\n\t        }\r\n\t\r\n\t        // only allow binding on native attributes\r\n\t        if (disallowedInterpAttrRE.test(attr) || attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT')) {\r\n\t          'development' !== 'production' && warn(attr + '=\"' + descriptor.raw + '\": ' + 'attribute interpolation is not allowed in Vue.js ' + 'directives and special attributes.', this.vm);\r\n\t          this.el.removeAttribute(attr);\r\n\t          this.invalid = true;\r\n\t        }\r\n\t\r\n\t        /* istanbul ignore if */\r\n\t        if (true) {\r\n\t          var raw = attr + '=\"' + descriptor.raw + '\": ';\r\n\t          // warn src\r\n\t          if (attr === 'src') {\r\n\t            warn(raw + 'interpolation in \"src\" attribute will cause ' + 'a 404 request. Use v-bind:src instead.', this.vm);\r\n\t          }\r\n\t\r\n\t          // warn style\r\n\t          if (attr === 'style') {\r\n\t            warn(raw + 'interpolation in \"style\" attribute will cause ' + 'the attribute to be discarded in Internet Explorer. ' + 'Use v-bind:style instead.', this.vm);\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t    },\r\n\t\r\n\t    update: function update(value) {\r\n\t      if (this.invalid) {\r\n\t        return;\r\n\t      }\r\n\t      var attr = this.arg;\r\n\t      if (this.arg) {\r\n\t        this.handleSingle(attr, value);\r\n\t      } else {\r\n\t        this.handleObject(value || {});\r\n\t      }\r\n\t    },\r\n\t\r\n\t    // share object handler with v-bind:class\r\n\t    handleObject: style.handleObject,\r\n\t\r\n\t    handleSingle: function handleSingle(attr, value) {\r\n\t      var el = this.el;\r\n\t      var interp = this.descriptor.interp;\r\n\t      if (this.modifiers.camel) {\r\n\t        attr = camelize(attr);\r\n\t      }\r\n\t      if (!interp && attrWithPropsRE.test(attr) && attr in el) {\r\n\t        var attrValue = attr === 'value' ? value == null // IE9 will set input.value to \"null\" for null...\r\n\t        ? '' : value : value;\r\n\t\r\n\t        if (el[attr] !== attrValue) {\r\n\t          el[attr] = attrValue;\r\n\t        }\r\n\t      }\r\n\t      // set model props\r\n\t      var modelProp = modelProps[attr];\r\n\t      if (!interp && modelProp) {\r\n\t        el[modelProp] = value;\r\n\t        // update v-model if present\r\n\t        var model = el.__v_model;\r\n\t        if (model) {\r\n\t          model.listener();\r\n\t        }\r\n\t      }\r\n\t      // do not set value attribute for textarea\r\n\t      if (attr === 'value' && el.tagName === 'TEXTAREA') {\r\n\t        el.removeAttribute(attr);\r\n\t        return;\r\n\t      }\r\n\t      // update attribute\r\n\t      if (enumeratedAttrRE.test(attr)) {\r\n\t        el.setAttribute(attr, value ? 'true' : 'false');\r\n\t      } else if (value != null && value !== false) {\r\n\t        if (attr === 'class') {\r\n\t          // handle edge case #1960:\r\n\t          // class interpolation should not overwrite Vue transition class\r\n\t          if (el.__v_trans) {\r\n\t            value += ' ' + el.__v_trans.id + '-transition';\r\n\t          }\r\n\t          setClass(el, value);\r\n\t        } else if (xlinkRE.test(attr)) {\r\n\t          el.setAttributeNS(xlinkNS, attr, value === true ? '' : value);\r\n\t        } else {\r\n\t          el.setAttribute(attr, value === true ? '' : value);\r\n\t        }\r\n\t      } else {\r\n\t        el.removeAttribute(attr);\r\n\t      }\r\n\t    }\r\n\t  };\r\n\t\r\n\t  var el = {\r\n\t\r\n\t    priority: EL,\r\n\t\r\n\t    bind: function bind() {\r\n\t      /* istanbul ignore if */\r\n\t      if (!this.arg) {\r\n\t        return;\r\n\t      }\r\n\t      var id = this.id = camelize(this.arg);\r\n\t      var refs = (this._scope || this.vm).$els;\r\n\t      if (hasOwn(refs, id)) {\r\n\t        refs[id] = this.el;\r\n\t      } else {\r\n\t        defineReactive(refs, id, this.el);\r\n\t      }\r\n\t    },\r\n\t\r\n\t    unbind: function unbind() {\r\n\t      var refs = (this._scope || this.vm).$els;\r\n\t      if (refs[this.id] === this.el) {\r\n\t        refs[this.id] = null;\r\n\t      }\r\n\t    }\r\n\t  };\r\n\t\r\n\t  var ref = {\r\n\t    bind: function bind() {\r\n\t      'development' !== 'production' && warn('v-ref:' + this.arg + ' must be used on a child ' + 'component. Found on <' + this.el.tagName.toLowerCase() + '>.', this.vm);\r\n\t    }\r\n\t  };\r\n\t\r\n\t  var cloak = {\r\n\t    bind: function bind() {\r\n\t      var el = this.el;\r\n\t      this.vm.$once('pre-hook:compiled', function () {\r\n\t        el.removeAttribute('v-cloak');\r\n\t      });\r\n\t    }\r\n\t  };\r\n\t\r\n\t  // must export plain object\r\n\t  var directives = {\r\n\t    text: text$1,\r\n\t    html: html,\r\n\t    'for': vFor,\r\n\t    'if': vIf,\r\n\t    show: show,\r\n\t    model: model,\r\n\t    on: on$1,\r\n\t    bind: bind$1,\r\n\t    el: el,\r\n\t    ref: ref,\r\n\t    cloak: cloak\r\n\t  };\r\n\t\r\n\t  var vClass = {\r\n\t\r\n\t    deep: true,\r\n\t\r\n\t    update: function update(value) {\r\n\t      if (!value) {\r\n\t        this.cleanup();\r\n\t      } else if (typeof value === 'string') {\r\n\t        this.setClass(value.trim().split(/\\s+/));\r\n\t      } else {\r\n\t        this.setClass(normalize$1(value));\r\n\t      }\r\n\t    },\r\n\t\r\n\t    setClass: function setClass(value) {\r\n\t      this.cleanup(value);\r\n\t      for (var i = 0, l = value.length; i < l; i++) {\r\n\t        var val = value[i];\r\n\t        if (val) {\r\n\t          apply(this.el, val, addClass);\r\n\t        }\r\n\t      }\r\n\t      this.prevKeys = value;\r\n\t    },\r\n\t\r\n\t    cleanup: function cleanup(value) {\r\n\t      var prevKeys = this.prevKeys;\r\n\t      if (!prevKeys) return;\r\n\t      var i = prevKeys.length;\r\n\t      while (i--) {\r\n\t        var key = prevKeys[i];\r\n\t        if (!value || value.indexOf(key) < 0) {\r\n\t          apply(this.el, key, removeClass);\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Normalize objects and arrays (potentially containing objects)\r\n\t   * into array of strings.\r\n\t   *\r\n\t   * @param {Object|Array<String|Object>} value\r\n\t   * @return {Array<String>}\r\n\t   */\r\n\t\r\n\t  function normalize$1(value) {\r\n\t    var res = [];\r\n\t    if (isArray(value)) {\r\n\t      for (var i = 0, l = value.length; i < l; i++) {\r\n\t        var _key = value[i];\r\n\t        if (_key) {\r\n\t          if (typeof _key === 'string') {\r\n\t            res.push(_key);\r\n\t          } else {\r\n\t            for (var k in _key) {\r\n\t              if (_key[k]) res.push(k);\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t    } else if (isObject(value)) {\r\n\t      for (var key in value) {\r\n\t        if (value[key]) res.push(key);\r\n\t      }\r\n\t    }\r\n\t    return res;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Add or remove a class/classes on an element\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @param {String} key The class name. This may or may not\r\n\t   *                     contain a space character, in such a\r\n\t   *                     case we'll deal with multiple class\r\n\t   *                     names at once.\r\n\t   * @param {Function} fn\r\n\t   */\r\n\t\r\n\t  function apply(el, key, fn) {\r\n\t    key = key.trim();\r\n\t    if (key.indexOf(' ') === -1) {\r\n\t      fn(el, key);\r\n\t      return;\r\n\t    }\r\n\t    // The key contains one or more space characters.\r\n\t    // Since a class name doesn't accept such characters, we\r\n\t    // treat it as multiple classes.\r\n\t    var keys = key.split(/\\s+/);\r\n\t    for (var i = 0, l = keys.length; i < l; i++) {\r\n\t      fn(el, keys[i]);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  var component = {\r\n\t\r\n\t    priority: COMPONENT,\r\n\t\r\n\t    params: ['keep-alive', 'transition-mode', 'inline-template'],\r\n\t\r\n\t    /**\r\n\t     * Setup. Two possible usages:\r\n\t     *\r\n\t     * - static:\r\n\t     *   <comp> or <div v-component=\"comp\">\r\n\t     *\r\n\t     * - dynamic:\r\n\t     *   <component :is=\"view\">\r\n\t     */\r\n\t\r\n\t    bind: function bind() {\r\n\t      if (!this.el.__vue__) {\r\n\t        // keep-alive cache\r\n\t        this.keepAlive = this.params.keepAlive;\r\n\t        if (this.keepAlive) {\r\n\t          this.cache = {};\r\n\t        }\r\n\t        // check inline-template\r\n\t        if (this.params.inlineTemplate) {\r\n\t          // extract inline template as a DocumentFragment\r\n\t          this.inlineTemplate = extractContent(this.el, true);\r\n\t        }\r\n\t        // component resolution related state\r\n\t        this.pendingComponentCb = this.Component = null;\r\n\t        // transition related state\r\n\t        this.pendingRemovals = 0;\r\n\t        this.pendingRemovalCb = null;\r\n\t        // create a ref anchor\r\n\t        this.anchor = createAnchor('v-component');\r\n\t        replace(this.el, this.anchor);\r\n\t        // remove is attribute.\r\n\t        // this is removed during compilation, but because compilation is\r\n\t        // cached, when the component is used elsewhere this attribute\r\n\t        // will remain at link time.\r\n\t        this.el.removeAttribute('is');\r\n\t        this.el.removeAttribute(':is');\r\n\t        // remove ref, same as above\r\n\t        if (this.descriptor.ref) {\r\n\t          this.el.removeAttribute('v-ref:' + hyphenate(this.descriptor.ref));\r\n\t        }\r\n\t        // if static, build right now.\r\n\t        if (this.literal) {\r\n\t          this.setComponent(this.expression);\r\n\t        }\r\n\t      } else {\r\n\t        'development' !== 'production' && warn('cannot mount component \"' + this.expression + '\" ' + 'on already mounted element: ' + this.el);\r\n\t      }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Public update, called by the watcher in the dynamic\r\n\t     * literal scenario, e.g. <component :is=\"view\">\r\n\t     */\r\n\t\r\n\t    update: function update(value) {\r\n\t      if (!this.literal) {\r\n\t        this.setComponent(value);\r\n\t      }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Switch dynamic components. May resolve the component\r\n\t     * asynchronously, and perform transition based on\r\n\t     * specified transition mode. Accepts a few additional\r\n\t     * arguments specifically for vue-router.\r\n\t     *\r\n\t     * The callback is called when the full transition is\r\n\t     * finished.\r\n\t     *\r\n\t     * @param {String} value\r\n\t     * @param {Function} [cb]\r\n\t     */\r\n\t\r\n\t    setComponent: function setComponent(value, cb) {\r\n\t      this.invalidatePending();\r\n\t      if (!value) {\r\n\t        // just remove current\r\n\t        this.unbuild(true);\r\n\t        this.remove(this.childVM, cb);\r\n\t        this.childVM = null;\r\n\t      } else {\r\n\t        var self = this;\r\n\t        this.resolveComponent(value, function () {\r\n\t          self.mountComponent(cb);\r\n\t        });\r\n\t      }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Resolve the component constructor to use when creating\r\n\t     * the child vm.\r\n\t     *\r\n\t     * @param {String|Function} value\r\n\t     * @param {Function} cb\r\n\t     */\r\n\t\r\n\t    resolveComponent: function resolveComponent(value, cb) {\r\n\t      var self = this;\r\n\t      this.pendingComponentCb = cancellable(function (Component) {\r\n\t        self.ComponentName = Component.options.name || (typeof value === 'string' ? value : null);\r\n\t        self.Component = Component;\r\n\t        cb();\r\n\t      });\r\n\t      this.vm._resolveComponent(value, this.pendingComponentCb);\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Create a new instance using the current constructor and\r\n\t     * replace the existing instance. This method doesn't care\r\n\t     * whether the new component and the old one are actually\r\n\t     * the same.\r\n\t     *\r\n\t     * @param {Function} [cb]\r\n\t     */\r\n\t\r\n\t    mountComponent: function mountComponent(cb) {\r\n\t      // actual mount\r\n\t      this.unbuild(true);\r\n\t      var self = this;\r\n\t      var activateHooks = this.Component.options.activate;\r\n\t      var cached = this.getCached();\r\n\t      var newComponent = this.build();\r\n\t      if (activateHooks && !cached) {\r\n\t        this.waitingFor = newComponent;\r\n\t        callActivateHooks(activateHooks, newComponent, function () {\r\n\t          if (self.waitingFor !== newComponent) {\r\n\t            return;\r\n\t          }\r\n\t          self.waitingFor = null;\r\n\t          self.transition(newComponent, cb);\r\n\t        });\r\n\t      } else {\r\n\t        // update ref for kept-alive component\r\n\t        if (cached) {\r\n\t          newComponent._updateRef();\r\n\t        }\r\n\t        this.transition(newComponent, cb);\r\n\t      }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * When the component changes or unbinds before an async\r\n\t     * constructor is resolved, we need to invalidate its\r\n\t     * pending callback.\r\n\t     */\r\n\t\r\n\t    invalidatePending: function invalidatePending() {\r\n\t      if (this.pendingComponentCb) {\r\n\t        this.pendingComponentCb.cancel();\r\n\t        this.pendingComponentCb = null;\r\n\t      }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Instantiate/insert a new child vm.\r\n\t     * If keep alive and has cached instance, insert that\r\n\t     * instance; otherwise build a new one and cache it.\r\n\t     *\r\n\t     * @param {Object} [extraOptions]\r\n\t     * @return {Vue} - the created instance\r\n\t     */\r\n\t\r\n\t    build: function build(extraOptions) {\r\n\t      var cached = this.getCached();\r\n\t      if (cached) {\r\n\t        return cached;\r\n\t      }\r\n\t      if (this.Component) {\r\n\t        // default options\r\n\t        var options = {\r\n\t          name: this.ComponentName,\r\n\t          el: cloneNode(this.el),\r\n\t          template: this.inlineTemplate,\r\n\t          // make sure to add the child with correct parent\r\n\t          // if this is a transcluded component, its parent\r\n\t          // should be the transclusion host.\r\n\t          parent: this._host || this.vm,\r\n\t          // if no inline-template, then the compiled\r\n\t          // linker can be cached for better performance.\r\n\t          _linkerCachable: !this.inlineTemplate,\r\n\t          _ref: this.descriptor.ref,\r\n\t          _asComponent: true,\r\n\t          _isRouterView: this._isRouterView,\r\n\t          // if this is a transcluded component, context\r\n\t          // will be the common parent vm of this instance\r\n\t          // and its host.\r\n\t          _context: this.vm,\r\n\t          // if this is inside an inline v-for, the scope\r\n\t          // will be the intermediate scope created for this\r\n\t          // repeat fragment. this is used for linking props\r\n\t          // and container directives.\r\n\t          _scope: this._scope,\r\n\t          // pass in the owner fragment of this component.\r\n\t          // this is necessary so that the fragment can keep\r\n\t          // track of its contained components in order to\r\n\t          // call attach/detach hooks for them.\r\n\t          _frag: this._frag\r\n\t        };\r\n\t        // extra options\r\n\t        // in 1.0.0 this is used by vue-router only\r\n\t        /* istanbul ignore if */\r\n\t        if (extraOptions) {\r\n\t          extend(options, extraOptions);\r\n\t        }\r\n\t        var child = new this.Component(options);\r\n\t        if (this.keepAlive) {\r\n\t          this.cache[this.Component.cid] = child;\r\n\t        }\r\n\t        /* istanbul ignore if */\r\n\t        if ('development' !== 'production' && this.el.hasAttribute('transition') && child._isFragment) {\r\n\t          warn('Transitions will not work on a fragment instance. ' + 'Template: ' + child.$options.template, child);\r\n\t        }\r\n\t        return child;\r\n\t      }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Try to get a cached instance of the current component.\r\n\t     *\r\n\t     * @return {Vue|undefined}\r\n\t     */\r\n\t\r\n\t    getCached: function getCached() {\r\n\t      return this.keepAlive && this.cache[this.Component.cid];\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Teardown the current child, but defers cleanup so\r\n\t     * that we can separate the destroy and removal steps.\r\n\t     *\r\n\t     * @param {Boolean} defer\r\n\t     */\r\n\t\r\n\t    unbuild: function unbuild(defer) {\r\n\t      if (this.waitingFor) {\r\n\t        if (!this.keepAlive) {\r\n\t          this.waitingFor.$destroy();\r\n\t        }\r\n\t        this.waitingFor = null;\r\n\t      }\r\n\t      var child = this.childVM;\r\n\t      if (!child || this.keepAlive) {\r\n\t        if (child) {\r\n\t          // remove ref\r\n\t          child._inactive = true;\r\n\t          child._updateRef(true);\r\n\t        }\r\n\t        return;\r\n\t      }\r\n\t      // the sole purpose of `deferCleanup` is so that we can\r\n\t      // \"deactivate\" the vm right now and perform DOM removal\r\n\t      // later.\r\n\t      child.$destroy(false, defer);\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Remove current destroyed child and manually do\r\n\t     * the cleanup after removal.\r\n\t     *\r\n\t     * @param {Function} cb\r\n\t     */\r\n\t\r\n\t    remove: function remove(child, cb) {\r\n\t      var keepAlive = this.keepAlive;\r\n\t      if (child) {\r\n\t        // we may have a component switch when a previous\r\n\t        // component is still being transitioned out.\r\n\t        // we want to trigger only one lastest insertion cb\r\n\t        // when the existing transition finishes. (#1119)\r\n\t        this.pendingRemovals++;\r\n\t        this.pendingRemovalCb = cb;\r\n\t        var self = this;\r\n\t        child.$remove(function () {\r\n\t          self.pendingRemovals--;\r\n\t          if (!keepAlive) child._cleanup();\r\n\t          if (!self.pendingRemovals && self.pendingRemovalCb) {\r\n\t            self.pendingRemovalCb();\r\n\t            self.pendingRemovalCb = null;\r\n\t          }\r\n\t        });\r\n\t      } else if (cb) {\r\n\t        cb();\r\n\t      }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Actually swap the components, depending on the\r\n\t     * transition mode. Defaults to simultaneous.\r\n\t     *\r\n\t     * @param {Vue} target\r\n\t     * @param {Function} [cb]\r\n\t     */\r\n\t\r\n\t    transition: function transition(target, cb) {\r\n\t      var self = this;\r\n\t      var current = this.childVM;\r\n\t      // for devtool inspection\r\n\t      if (current) current._inactive = true;\r\n\t      target._inactive = false;\r\n\t      this.childVM = target;\r\n\t      switch (self.params.transitionMode) {\r\n\t        case 'in-out':\r\n\t          target.$before(self.anchor, function () {\r\n\t            self.remove(current, cb);\r\n\t          });\r\n\t          break;\r\n\t        case 'out-in':\r\n\t          self.remove(current, function () {\r\n\t            target.$before(self.anchor, cb);\r\n\t          });\r\n\t          break;\r\n\t        default:\r\n\t          self.remove(current);\r\n\t          target.$before(self.anchor, cb);\r\n\t      }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Unbind.\r\n\t     */\r\n\t\r\n\t    unbind: function unbind() {\r\n\t      this.invalidatePending();\r\n\t      // Do not defer cleanup when unbinding\r\n\t      this.unbuild();\r\n\t      // destroy all keep-alive cached instances\r\n\t      if (this.cache) {\r\n\t        for (var key in this.cache) {\r\n\t          this.cache[key].$destroy();\r\n\t        }\r\n\t        this.cache = null;\r\n\t      }\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Call activate hooks in order (asynchronous)\r\n\t   *\r\n\t   * @param {Array} hooks\r\n\t   * @param {Vue} vm\r\n\t   * @param {Function} cb\r\n\t   */\r\n\t\r\n\t  function callActivateHooks(hooks, vm, cb) {\r\n\t    var total = hooks.length;\r\n\t    var called = 0;\r\n\t    hooks[0].call(vm, next);\r\n\t    function next() {\r\n\t      if (++called >= total) {\r\n\t        cb();\r\n\t      } else {\r\n\t        hooks[called].call(vm, next);\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t\r\n\t  var propBindingModes = config._propBindingModes;\r\n\t  var empty = {};\r\n\t\r\n\t  // regexes\r\n\t  var identRE$1 = /^[$_a-zA-Z]+[\\w$]*$/;\r\n\t  var settablePathRE = /^[A-Za-z_$][\\w$]*(\\.[A-Za-z_$][\\w$]*|\\[[^\\[\\]]+\\])*$/;\r\n\t\r\n\t  /**\r\n\t   * Compile props on a root element and return\r\n\t   * a props link function.\r\n\t   *\r\n\t   * @param {Element|DocumentFragment} el\r\n\t   * @param {Array} propOptions\r\n\t   * @param {Vue} vm\r\n\t   * @return {Function} propsLinkFn\r\n\t   */\r\n\t\r\n\t  function compileProps(el, propOptions, vm) {\r\n\t    var props = [];\r\n\t    var names = Object.keys(propOptions);\r\n\t    var i = names.length;\r\n\t    var options, name, attr, value, path, parsed, prop;\r\n\t    while (i--) {\r\n\t      name = names[i];\r\n\t      options = propOptions[name] || empty;\r\n\t\r\n\t      if ('development' !== 'production' && name === '$data') {\r\n\t        warn('Do not use $data as prop.', vm);\r\n\t        continue;\r\n\t      }\r\n\t\r\n\t      // props could contain dashes, which will be\r\n\t      // interpreted as minus calculations by the parser\r\n\t      // so we need to camelize the path here\r\n\t      path = camelize(name);\r\n\t      if (!identRE$1.test(path)) {\r\n\t        'development' !== 'production' && warn('Invalid prop key: \"' + name + '\". Prop keys ' + 'must be valid identifiers.', vm);\r\n\t        continue;\r\n\t      }\r\n\t\r\n\t      prop = {\r\n\t        name: name,\r\n\t        path: path,\r\n\t        options: options,\r\n\t        mode: propBindingModes.ONE_WAY,\r\n\t        raw: null\r\n\t      };\r\n\t\r\n\t      attr = hyphenate(name);\r\n\t      // first check dynamic version\r\n\t      if ((value = getBindAttr(el, attr)) === null) {\r\n\t        if ((value = getBindAttr(el, attr + '.sync')) !== null) {\r\n\t          prop.mode = propBindingModes.TWO_WAY;\r\n\t        } else if ((value = getBindAttr(el, attr + '.once')) !== null) {\r\n\t          prop.mode = propBindingModes.ONE_TIME;\r\n\t        }\r\n\t      }\r\n\t      if (value !== null) {\r\n\t        // has dynamic binding!\r\n\t        prop.raw = value;\r\n\t        parsed = parseDirective(value);\r\n\t        value = parsed.expression;\r\n\t        prop.filters = parsed.filters;\r\n\t        // check binding type\r\n\t        if (isLiteral(value) && !parsed.filters) {\r\n\t          // for expressions containing literal numbers and\r\n\t          // booleans, there's no need to setup a prop binding,\r\n\t          // so we can optimize them as a one-time set.\r\n\t          prop.optimizedLiteral = true;\r\n\t        } else {\r\n\t          prop.dynamic = true;\r\n\t          // check non-settable path for two-way bindings\r\n\t          if ('development' !== 'production' && prop.mode === propBindingModes.TWO_WAY && !settablePathRE.test(value)) {\r\n\t            prop.mode = propBindingModes.ONE_WAY;\r\n\t            warn('Cannot bind two-way prop with non-settable ' + 'parent path: ' + value, vm);\r\n\t          }\r\n\t        }\r\n\t        prop.parentPath = value;\r\n\t\r\n\t        // warn required two-way\r\n\t        if ('development' !== 'production' && options.twoWay && prop.mode !== propBindingModes.TWO_WAY) {\r\n\t          warn('Prop \"' + name + '\" expects a two-way binding type.', vm);\r\n\t        }\r\n\t      } else if ((value = getAttr(el, attr)) !== null) {\r\n\t        // has literal binding!\r\n\t        prop.raw = value;\r\n\t      } else if (true) {\r\n\t        // check possible camelCase prop usage\r\n\t        var lowerCaseName = path.toLowerCase();\r\n\t        value = /[A-Z\\-]/.test(name) && (el.getAttribute(lowerCaseName) || el.getAttribute(':' + lowerCaseName) || el.getAttribute('v-bind:' + lowerCaseName) || el.getAttribute(':' + lowerCaseName + '.once') || el.getAttribute('v-bind:' + lowerCaseName + '.once') || el.getAttribute(':' + lowerCaseName + '.sync') || el.getAttribute('v-bind:' + lowerCaseName + '.sync'));\r\n\t        if (value) {\r\n\t          warn('Possible usage error for prop `' + lowerCaseName + '` - ' + 'did you mean `' + attr + '`? HTML is case-insensitive, remember to use ' + 'kebab-case for props in templates.', vm);\r\n\t        } else if (options.required) {\r\n\t          // warn missing required\r\n\t          warn('Missing required prop: ' + name, vm);\r\n\t        }\r\n\t      }\r\n\t      // push prop\r\n\t      props.push(prop);\r\n\t    }\r\n\t    return makePropsLinkFn(props);\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Build a function that applies props to a vm.\r\n\t   *\r\n\t   * @param {Array} props\r\n\t   * @return {Function} propsLinkFn\r\n\t   */\r\n\t\r\n\t  function makePropsLinkFn(props) {\r\n\t    return function propsLinkFn(vm, scope) {\r\n\t      // store resolved props info\r\n\t      vm._props = {};\r\n\t      var inlineProps = vm.$options.propsData;\r\n\t      var i = props.length;\r\n\t      var prop, path, options, value, raw;\r\n\t      while (i--) {\r\n\t        prop = props[i];\r\n\t        raw = prop.raw;\r\n\t        path = prop.path;\r\n\t        options = prop.options;\r\n\t        vm._props[path] = prop;\r\n\t        if (inlineProps && hasOwn(inlineProps, path)) {\r\n\t          initProp(vm, prop, inlineProps[path]);\r\n\t        }if (raw === null) {\r\n\t          // initialize absent prop\r\n\t          initProp(vm, prop, undefined);\r\n\t        } else if (prop.dynamic) {\r\n\t          // dynamic prop\r\n\t          if (prop.mode === propBindingModes.ONE_TIME) {\r\n\t            // one time binding\r\n\t            value = (scope || vm._context || vm).$get(prop.parentPath);\r\n\t            initProp(vm, prop, value);\r\n\t          } else {\r\n\t            if (vm._context) {\r\n\t              // dynamic binding\r\n\t              vm._bindDir({\r\n\t                name: 'prop',\r\n\t                def: propDef,\r\n\t                prop: prop\r\n\t              }, null, null, scope); // el, host, scope\r\n\t            } else {\r\n\t                // root instance\r\n\t                initProp(vm, prop, vm.$get(prop.parentPath));\r\n\t              }\r\n\t          }\r\n\t        } else if (prop.optimizedLiteral) {\r\n\t          // optimized literal, cast it and just set once\r\n\t          var stripped = stripQuotes(raw);\r\n\t          value = stripped === raw ? toBoolean(toNumber(raw)) : stripped;\r\n\t          initProp(vm, prop, value);\r\n\t        } else {\r\n\t          // string literal, but we need to cater for\r\n\t          // Boolean props with no value, or with same\r\n\t          // literal value (e.g. disabled=\"disabled\")\r\n\t          // see https://github.com/vuejs/vue-loader/issues/182\r\n\t          value = options.type === Boolean && (raw === '' || raw === hyphenate(prop.name)) ? true : raw;\r\n\t          initProp(vm, prop, value);\r\n\t        }\r\n\t      }\r\n\t    };\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Process a prop with a rawValue, applying necessary coersions,\r\n\t   * default values & assertions and call the given callback with\r\n\t   * processed value.\r\n\t   *\r\n\t   * @param {Vue} vm\r\n\t   * @param {Object} prop\r\n\t   * @param {*} rawValue\r\n\t   * @param {Function} fn\r\n\t   */\r\n\t\r\n\t  function processPropValue(vm, prop, rawValue, fn) {\r\n\t    var isSimple = prop.dynamic && isSimplePath(prop.parentPath);\r\n\t    var value = rawValue;\r\n\t    if (value === undefined) {\r\n\t      value = getPropDefaultValue(vm, prop);\r\n\t    }\r\n\t    value = coerceProp(prop, value, vm);\r\n\t    var coerced = value !== rawValue;\r\n\t    if (!assertProp(prop, value, vm)) {\r\n\t      value = undefined;\r\n\t    }\r\n\t    if (isSimple && !coerced) {\r\n\t      withoutConversion(function () {\r\n\t        fn(value);\r\n\t      });\r\n\t    } else {\r\n\t      fn(value);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Set a prop's initial value on a vm and its data object.\r\n\t   *\r\n\t   * @param {Vue} vm\r\n\t   * @param {Object} prop\r\n\t   * @param {*} value\r\n\t   */\r\n\t\r\n\t  function initProp(vm, prop, value) {\r\n\t    processPropValue(vm, prop, value, function (value) {\r\n\t      defineReactive(vm, prop.path, value);\r\n\t    });\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Update a prop's value on a vm.\r\n\t   *\r\n\t   * @param {Vue} vm\r\n\t   * @param {Object} prop\r\n\t   * @param {*} value\r\n\t   */\r\n\t\r\n\t  function updateProp(vm, prop, value) {\r\n\t    processPropValue(vm, prop, value, function (value) {\r\n\t      vm[prop.path] = value;\r\n\t    });\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Get the default value of a prop.\r\n\t   *\r\n\t   * @param {Vue} vm\r\n\t   * @param {Object} prop\r\n\t   * @return {*}\r\n\t   */\r\n\t\r\n\t  function getPropDefaultValue(vm, prop) {\r\n\t    // no default, return undefined\r\n\t    var options = prop.options;\r\n\t    if (!hasOwn(options, 'default')) {\r\n\t      // absent boolean value defaults to false\r\n\t      return options.type === Boolean ? false : undefined;\r\n\t    }\r\n\t    var def = options['default'];\r\n\t    // warn against non-factory defaults for Object & Array\r\n\t    if (isObject(def)) {\r\n\t      'development' !== 'production' && warn('Invalid default value for prop \"' + prop.name + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\r\n\t    }\r\n\t    // call factory function for non-Function types\r\n\t    return typeof def === 'function' && options.type !== Function ? def.call(vm) : def;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Assert whether a prop is valid.\r\n\t   *\r\n\t   * @param {Object} prop\r\n\t   * @param {*} value\r\n\t   * @param {Vue} vm\r\n\t   */\r\n\t\r\n\t  function assertProp(prop, value, vm) {\r\n\t    if (!prop.options.required && ( // non-required\r\n\t    prop.raw === null || // abscent\r\n\t    value == null) // null or undefined\r\n\t    ) {\r\n\t        return true;\r\n\t      }\r\n\t    var options = prop.options;\r\n\t    var type = options.type;\r\n\t    var valid = !type;\r\n\t    var expectedTypes = [];\r\n\t    if (type) {\r\n\t      if (!isArray(type)) {\r\n\t        type = [type];\r\n\t      }\r\n\t      for (var i = 0; i < type.length && !valid; i++) {\r\n\t        var assertedType = assertType(value, type[i]);\r\n\t        expectedTypes.push(assertedType.expectedType);\r\n\t        valid = assertedType.valid;\r\n\t      }\r\n\t    }\r\n\t    if (!valid) {\r\n\t      if (true) {\r\n\t        warn('Invalid prop: type check failed for prop \"' + prop.name + '\".' + ' Expected ' + expectedTypes.map(formatType).join(', ') + ', got ' + formatValue(value) + '.', vm);\r\n\t      }\r\n\t      return false;\r\n\t    }\r\n\t    var validator = options.validator;\r\n\t    if (validator) {\r\n\t      if (!validator(value)) {\r\n\t        'development' !== 'production' && warn('Invalid prop: custom validator check failed for prop \"' + prop.name + '\".', vm);\r\n\t        return false;\r\n\t      }\r\n\t    }\r\n\t    return true;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Force parsing value with coerce option.\r\n\t   *\r\n\t   * @param {*} value\r\n\t   * @param {Object} options\r\n\t   * @return {*}\r\n\t   */\r\n\t\r\n\t  function coerceProp(prop, value, vm) {\r\n\t    var coerce = prop.options.coerce;\r\n\t    if (!coerce) {\r\n\t      return value;\r\n\t    }\r\n\t    if (typeof coerce === 'function') {\r\n\t      return coerce(value);\r\n\t    } else {\r\n\t      'development' !== 'production' && warn('Invalid coerce for prop \"' + prop.name + '\": expected function, got ' + typeof coerce + '.', vm);\r\n\t      return value;\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Assert the type of a value\r\n\t   *\r\n\t   * @param {*} value\r\n\t   * @param {Function} type\r\n\t   * @return {Object}\r\n\t   */\r\n\t\r\n\t  function assertType(value, type) {\r\n\t    var valid;\r\n\t    var expectedType;\r\n\t    if (type === String) {\r\n\t      expectedType = 'string';\r\n\t      valid = typeof value === expectedType;\r\n\t    } else if (type === Number) {\r\n\t      expectedType = 'number';\r\n\t      valid = typeof value === expectedType;\r\n\t    } else if (type === Boolean) {\r\n\t      expectedType = 'boolean';\r\n\t      valid = typeof value === expectedType;\r\n\t    } else if (type === Function) {\r\n\t      expectedType = 'function';\r\n\t      valid = typeof value === expectedType;\r\n\t    } else if (type === Object) {\r\n\t      expectedType = 'object';\r\n\t      valid = isPlainObject(value);\r\n\t    } else if (type === Array) {\r\n\t      expectedType = 'array';\r\n\t      valid = isArray(value);\r\n\t    } else {\r\n\t      valid = value instanceof type;\r\n\t    }\r\n\t    return {\r\n\t      valid: valid,\r\n\t      expectedType: expectedType\r\n\t    };\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Format type for output\r\n\t   *\r\n\t   * @param {String} type\r\n\t   * @return {String}\r\n\t   */\r\n\t\r\n\t  function formatType(type) {\r\n\t    return type ? type.charAt(0).toUpperCase() + type.slice(1) : 'custom type';\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Format value\r\n\t   *\r\n\t   * @param {*} value\r\n\t   * @return {String}\r\n\t   */\r\n\t\r\n\t  function formatValue(val) {\r\n\t    return Object.prototype.toString.call(val).slice(8, -1);\r\n\t  }\r\n\t\r\n\t  var bindingModes = config._propBindingModes;\r\n\t\r\n\t  var propDef = {\r\n\t\r\n\t    bind: function bind() {\r\n\t      var child = this.vm;\r\n\t      var parent = child._context;\r\n\t      // passed in from compiler directly\r\n\t      var prop = this.descriptor.prop;\r\n\t      var childKey = prop.path;\r\n\t      var parentKey = prop.parentPath;\r\n\t      var twoWay = prop.mode === bindingModes.TWO_WAY;\r\n\t\r\n\t      var parentWatcher = this.parentWatcher = new Watcher(parent, parentKey, function (val) {\r\n\t        updateProp(child, prop, val);\r\n\t      }, {\r\n\t        twoWay: twoWay,\r\n\t        filters: prop.filters,\r\n\t        // important: props need to be observed on the\r\n\t        // v-for scope if present\r\n\t        scope: this._scope\r\n\t      });\r\n\t\r\n\t      // set the child initial value.\r\n\t      initProp(child, prop, parentWatcher.value);\r\n\t\r\n\t      // setup two-way binding\r\n\t      if (twoWay) {\r\n\t        // important: defer the child watcher creation until\r\n\t        // the created hook (after data observation)\r\n\t        var self = this;\r\n\t        child.$once('pre-hook:created', function () {\r\n\t          self.childWatcher = new Watcher(child, childKey, function (val) {\r\n\t            parentWatcher.set(val);\r\n\t          }, {\r\n\t            // ensure sync upward before parent sync down.\r\n\t            // this is necessary in cases e.g. the child\r\n\t            // mutates a prop array, then replaces it. (#1683)\r\n\t            sync: true\r\n\t          });\r\n\t        });\r\n\t      }\r\n\t    },\r\n\t\r\n\t    unbind: function unbind() {\r\n\t      this.parentWatcher.teardown();\r\n\t      if (this.childWatcher) {\r\n\t        this.childWatcher.teardown();\r\n\t      }\r\n\t    }\r\n\t  };\r\n\t\r\n\t  var queue$1 = [];\r\n\t  var queued = false;\r\n\t\r\n\t  /**\r\n\t   * Push a job into the queue.\r\n\t   *\r\n\t   * @param {Function} job\r\n\t   */\r\n\t\r\n\t  function pushJob(job) {\r\n\t    queue$1.push(job);\r\n\t    if (!queued) {\r\n\t      queued = true;\r\n\t      nextTick(flush);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Flush the queue, and do one forced reflow before\r\n\t   * triggering transitions.\r\n\t   */\r\n\t\r\n\t  function flush() {\r\n\t    // Force layout\r\n\t    var f = document.documentElement.offsetHeight;\r\n\t    for (var i = 0; i < queue$1.length; i++) {\r\n\t      queue$1[i]();\r\n\t    }\r\n\t    queue$1 = [];\r\n\t    queued = false;\r\n\t    // dummy return, so js linters don't complain about\r\n\t    // unused variable f\r\n\t    return f;\r\n\t  }\r\n\t\r\n\t  var TYPE_TRANSITION = 'transition';\r\n\t  var TYPE_ANIMATION = 'animation';\r\n\t  var transDurationProp = transitionProp + 'Duration';\r\n\t  var animDurationProp = animationProp + 'Duration';\r\n\t\r\n\t  /**\r\n\t   * If a just-entered element is applied the\r\n\t   * leave class while its enter transition hasn't started yet,\r\n\t   * and the transitioned property has the same value for both\r\n\t   * enter/leave, then the leave transition will be skipped and\r\n\t   * the transitionend event never fires. This function ensures\r\n\t   * its callback to be called after a transition has started\r\n\t   * by waiting for double raf.\r\n\t   *\r\n\t   * It falls back to setTimeout on devices that support CSS\r\n\t   * transitions but not raf (e.g. Android 4.2 browser) - since\r\n\t   * these environments are usually slow, we are giving it a\r\n\t   * relatively large timeout.\r\n\t   */\r\n\t\r\n\t  var raf = inBrowser && window.requestAnimationFrame;\r\n\t  var waitForTransitionStart = raf\r\n\t  /* istanbul ignore next */\r\n\t  ? function (fn) {\r\n\t    raf(function () {\r\n\t      raf(fn);\r\n\t    });\r\n\t  } : function (fn) {\r\n\t    setTimeout(fn, 50);\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * A Transition object that encapsulates the state and logic\r\n\t   * of the transition.\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @param {String} id\r\n\t   * @param {Object} hooks\r\n\t   * @param {Vue} vm\r\n\t   */\r\n\t  function Transition(el, id, hooks, vm) {\r\n\t    this.id = id;\r\n\t    this.el = el;\r\n\t    this.enterClass = hooks && hooks.enterClass || id + '-enter';\r\n\t    this.leaveClass = hooks && hooks.leaveClass || id + '-leave';\r\n\t    this.hooks = hooks;\r\n\t    this.vm = vm;\r\n\t    // async state\r\n\t    this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null;\r\n\t    this.justEntered = false;\r\n\t    this.entered = this.left = false;\r\n\t    this.typeCache = {};\r\n\t    // check css transition type\r\n\t    this.type = hooks && hooks.type;\r\n\t    /* istanbul ignore if */\r\n\t    if (true) {\r\n\t      if (this.type && this.type !== TYPE_TRANSITION && this.type !== TYPE_ANIMATION) {\r\n\t        warn('invalid CSS transition type for transition=\"' + this.id + '\": ' + this.type, vm);\r\n\t      }\r\n\t    }\r\n\t    // bind\r\n\t    var self = this;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone'].forEach(function (m) {\r\n\t      self[m] = bind(self[m], self);\r\n\t    });\r\n\t  }\r\n\t\r\n\t  var p$1 = Transition.prototype;\r\n\t\r\n\t  /**\r\n\t   * Start an entering transition.\r\n\t   *\r\n\t   * 1. enter transition triggered\r\n\t   * 2. call beforeEnter hook\r\n\t   * 3. add enter class\r\n\t   * 4. insert/show element\r\n\t   * 5. call enter hook (with possible explicit js callback)\r\n\t   * 6. reflow\r\n\t   * 7. based on transition type:\r\n\t   *    - transition:\r\n\t   *        remove class now, wait for transitionend,\r\n\t   *        then done if there's no explicit js callback.\r\n\t   *    - animation:\r\n\t   *        wait for animationend, remove class,\r\n\t   *        then done if there's no explicit js callback.\r\n\t   *    - no css transition:\r\n\t   *        done now if there's no explicit js callback.\r\n\t   * 8. wait for either done or js callback, then call\r\n\t   *    afterEnter hook.\r\n\t   *\r\n\t   * @param {Function} op - insert/show the element\r\n\t   * @param {Function} [cb]\r\n\t   */\r\n\t\r\n\t  p$1.enter = function (op, cb) {\r\n\t    this.cancelPending();\r\n\t    this.callHook('beforeEnter');\r\n\t    this.cb = cb;\r\n\t    addClass(this.el, this.enterClass);\r\n\t    op();\r\n\t    this.entered = false;\r\n\t    this.callHookWithCb('enter');\r\n\t    if (this.entered) {\r\n\t      return; // user called done synchronously.\r\n\t    }\r\n\t    this.cancel = this.hooks && this.hooks.enterCancelled;\r\n\t    pushJob(this.enterNextTick);\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * The \"nextTick\" phase of an entering transition, which is\r\n\t   * to be pushed into a queue and executed after a reflow so\r\n\t   * that removing the class can trigger a CSS transition.\r\n\t   */\r\n\t\r\n\t  p$1.enterNextTick = function () {\r\n\t    var _this = this;\r\n\t\r\n\t    // prevent transition skipping\r\n\t    this.justEntered = true;\r\n\t    waitForTransitionStart(function () {\r\n\t      _this.justEntered = false;\r\n\t    });\r\n\t    var enterDone = this.enterDone;\r\n\t    var type = this.getCssTransitionType(this.enterClass);\r\n\t    if (!this.pendingJsCb) {\r\n\t      if (type === TYPE_TRANSITION) {\r\n\t        // trigger transition by removing enter class now\r\n\t        removeClass(this.el, this.enterClass);\r\n\t        this.setupCssCb(transitionEndEvent, enterDone);\r\n\t      } else if (type === TYPE_ANIMATION) {\r\n\t        this.setupCssCb(animationEndEvent, enterDone);\r\n\t      } else {\r\n\t        enterDone();\r\n\t      }\r\n\t    } else if (type === TYPE_TRANSITION) {\r\n\t      removeClass(this.el, this.enterClass);\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * The \"cleanup\" phase of an entering transition.\r\n\t   */\r\n\t\r\n\t  p$1.enterDone = function () {\r\n\t    this.entered = true;\r\n\t    this.cancel = this.pendingJsCb = null;\r\n\t    removeClass(this.el, this.enterClass);\r\n\t    this.callHook('afterEnter');\r\n\t    if (this.cb) this.cb();\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Start a leaving transition.\r\n\t   *\r\n\t   * 1. leave transition triggered.\r\n\t   * 2. call beforeLeave hook\r\n\t   * 3. add leave class (trigger css transition)\r\n\t   * 4. call leave hook (with possible explicit js callback)\r\n\t   * 5. reflow if no explicit js callback is provided\r\n\t   * 6. based on transition type:\r\n\t   *    - transition or animation:\r\n\t   *        wait for end event, remove class, then done if\r\n\t   *        there's no explicit js callback.\r\n\t   *    - no css transition:\r\n\t   *        done if there's no explicit js callback.\r\n\t   * 7. wait for either done or js callback, then call\r\n\t   *    afterLeave hook.\r\n\t   *\r\n\t   * @param {Function} op - remove/hide the element\r\n\t   * @param {Function} [cb]\r\n\t   */\r\n\t\r\n\t  p$1.leave = function (op, cb) {\r\n\t    this.cancelPending();\r\n\t    this.callHook('beforeLeave');\r\n\t    this.op = op;\r\n\t    this.cb = cb;\r\n\t    addClass(this.el, this.leaveClass);\r\n\t    this.left = false;\r\n\t    this.callHookWithCb('leave');\r\n\t    if (this.left) {\r\n\t      return; // user called done synchronously.\r\n\t    }\r\n\t    this.cancel = this.hooks && this.hooks.leaveCancelled;\r\n\t    // only need to handle leaveDone if\r\n\t    // 1. the transition is already done (synchronously called\r\n\t    //    by the user, which causes this.op set to null)\r\n\t    // 2. there's no explicit js callback\r\n\t    if (this.op && !this.pendingJsCb) {\r\n\t      // if a CSS transition leaves immediately after enter,\r\n\t      // the transitionend event never fires. therefore we\r\n\t      // detect such cases and end the leave immediately.\r\n\t      if (this.justEntered) {\r\n\t        this.leaveDone();\r\n\t      } else {\r\n\t        pushJob(this.leaveNextTick);\r\n\t      }\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * The \"nextTick\" phase of a leaving transition.\r\n\t   */\r\n\t\r\n\t  p$1.leaveNextTick = function () {\r\n\t    var type = this.getCssTransitionType(this.leaveClass);\r\n\t    if (type) {\r\n\t      var event = type === TYPE_TRANSITION ? transitionEndEvent : animationEndEvent;\r\n\t      this.setupCssCb(event, this.leaveDone);\r\n\t    } else {\r\n\t      this.leaveDone();\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * The \"cleanup\" phase of a leaving transition.\r\n\t   */\r\n\t\r\n\t  p$1.leaveDone = function () {\r\n\t    this.left = true;\r\n\t    this.cancel = this.pendingJsCb = null;\r\n\t    this.op();\r\n\t    removeClass(this.el, this.leaveClass);\r\n\t    this.callHook('afterLeave');\r\n\t    if (this.cb) this.cb();\r\n\t    this.op = null;\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Cancel any pending callbacks from a previously running\r\n\t   * but not finished transition.\r\n\t   */\r\n\t\r\n\t  p$1.cancelPending = function () {\r\n\t    this.op = this.cb = null;\r\n\t    var hasPending = false;\r\n\t    if (this.pendingCssCb) {\r\n\t      hasPending = true;\r\n\t      off(this.el, this.pendingCssEvent, this.pendingCssCb);\r\n\t      this.pendingCssEvent = this.pendingCssCb = null;\r\n\t    }\r\n\t    if (this.pendingJsCb) {\r\n\t      hasPending = true;\r\n\t      this.pendingJsCb.cancel();\r\n\t      this.pendingJsCb = null;\r\n\t    }\r\n\t    if (hasPending) {\r\n\t      removeClass(this.el, this.enterClass);\r\n\t      removeClass(this.el, this.leaveClass);\r\n\t    }\r\n\t    if (this.cancel) {\r\n\t      this.cancel.call(this.vm, this.el);\r\n\t      this.cancel = null;\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Call a user-provided synchronous hook function.\r\n\t   *\r\n\t   * @param {String} type\r\n\t   */\r\n\t\r\n\t  p$1.callHook = function (type) {\r\n\t    if (this.hooks && this.hooks[type]) {\r\n\t      this.hooks[type].call(this.vm, this.el);\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Call a user-provided, potentially-async hook function.\r\n\t   * We check for the length of arguments to see if the hook\r\n\t   * expects a `done` callback. If true, the transition's end\r\n\t   * will be determined by when the user calls that callback;\r\n\t   * otherwise, the end is determined by the CSS transition or\r\n\t   * animation.\r\n\t   *\r\n\t   * @param {String} type\r\n\t   */\r\n\t\r\n\t  p$1.callHookWithCb = function (type) {\r\n\t    var hook = this.hooks && this.hooks[type];\r\n\t    if (hook) {\r\n\t      if (hook.length > 1) {\r\n\t        this.pendingJsCb = cancellable(this[type + 'Done']);\r\n\t      }\r\n\t      hook.call(this.vm, this.el, this.pendingJsCb);\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Get an element's transition type based on the\r\n\t   * calculated styles.\r\n\t   *\r\n\t   * @param {String} className\r\n\t   * @return {Number}\r\n\t   */\r\n\t\r\n\t  p$1.getCssTransitionType = function (className) {\r\n\t    /* istanbul ignore if */\r\n\t    if (!transitionEndEvent ||\r\n\t    // skip CSS transitions if page is not visible -\r\n\t    // this solves the issue of transitionend events not\r\n\t    // firing until the page is visible again.\r\n\t    // pageVisibility API is supported in IE10+, same as\r\n\t    // CSS transitions.\r\n\t    document.hidden ||\r\n\t    // explicit js-only transition\r\n\t    this.hooks && this.hooks.css === false ||\r\n\t    // element is hidden\r\n\t    isHidden(this.el)) {\r\n\t      return;\r\n\t    }\r\n\t    var type = this.type || this.typeCache[className];\r\n\t    if (type) return type;\r\n\t    var inlineStyles = this.el.style;\r\n\t    var computedStyles = window.getComputedStyle(this.el);\r\n\t    var transDuration = inlineStyles[transDurationProp] || computedStyles[transDurationProp];\r\n\t    if (transDuration && transDuration !== '0s') {\r\n\t      type = TYPE_TRANSITION;\r\n\t    } else {\r\n\t      var animDuration = inlineStyles[animDurationProp] || computedStyles[animDurationProp];\r\n\t      if (animDuration && animDuration !== '0s') {\r\n\t        type = TYPE_ANIMATION;\r\n\t      }\r\n\t    }\r\n\t    if (type) {\r\n\t      this.typeCache[className] = type;\r\n\t    }\r\n\t    return type;\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Setup a CSS transitionend/animationend callback.\r\n\t   *\r\n\t   * @param {String} event\r\n\t   * @param {Function} cb\r\n\t   */\r\n\t\r\n\t  p$1.setupCssCb = function (event, cb) {\r\n\t    this.pendingCssEvent = event;\r\n\t    var self = this;\r\n\t    var el = this.el;\r\n\t    var onEnd = this.pendingCssCb = function (e) {\r\n\t      if (e.target === el) {\r\n\t        off(el, event, onEnd);\r\n\t        self.pendingCssEvent = self.pendingCssCb = null;\r\n\t        if (!self.pendingJsCb && cb) {\r\n\t          cb();\r\n\t        }\r\n\t      }\r\n\t    };\r\n\t    on(el, event, onEnd);\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Check if an element is hidden - in that case we can just\r\n\t   * skip the transition alltogether.\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @return {Boolean}\r\n\t   */\r\n\t\r\n\t  function isHidden(el) {\r\n\t    if (/svg$/.test(el.namespaceURI)) {\r\n\t      // SVG elements do not have offset(Width|Height)\r\n\t      // so we need to check the client rect\r\n\t      var rect = el.getBoundingClientRect();\r\n\t      return !(rect.width || rect.height);\r\n\t    } else {\r\n\t      return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  var transition$1 = {\r\n\t\r\n\t    priority: TRANSITION,\r\n\t\r\n\t    update: function update(id, oldId) {\r\n\t      var el = this.el;\r\n\t      // resolve on owner vm\r\n\t      var hooks = resolveAsset(this.vm.$options, 'transitions', id);\r\n\t      id = id || 'v';\r\n\t      oldId = oldId || 'v';\r\n\t      el.__v_trans = new Transition(el, id, hooks, this.vm);\r\n\t      removeClass(el, oldId + '-transition');\r\n\t      addClass(el, id + '-transition');\r\n\t    }\r\n\t  };\r\n\t\r\n\t  var internalDirectives = {\r\n\t    style: style,\r\n\t    'class': vClass,\r\n\t    component: component,\r\n\t    prop: propDef,\r\n\t    transition: transition$1\r\n\t  };\r\n\t\r\n\t  // special binding prefixes\r\n\t  var bindRE = /^v-bind:|^:/;\r\n\t  var onRE = /^v-on:|^@/;\r\n\t  var dirAttrRE = /^v-([^:]+)(?:$|:(.*)$)/;\r\n\t  var modifierRE = /\\.[^\\.]+/g;\r\n\t  var transitionRE = /^(v-bind:|:)?transition$/;\r\n\t\r\n\t  // default directive priority\r\n\t  var DEFAULT_PRIORITY = 1000;\r\n\t  var DEFAULT_TERMINAL_PRIORITY = 2000;\r\n\t\r\n\t  /**\r\n\t   * Compile a template and return a reusable composite link\r\n\t   * function, which recursively contains more link functions\r\n\t   * inside. This top level compile function would normally\r\n\t   * be called on instance root nodes, but can also be used\r\n\t   * for partial compilation if the partial argument is true.\r\n\t   *\r\n\t   * The returned composite link function, when called, will\r\n\t   * return an unlink function that tearsdown all directives\r\n\t   * created during the linking phase.\r\n\t   *\r\n\t   * @param {Element|DocumentFragment} el\r\n\t   * @param {Object} options\r\n\t   * @param {Boolean} partial\r\n\t   * @return {Function}\r\n\t   */\r\n\t\r\n\t  function compile(el, options, partial) {\r\n\t    // link function for the node itself.\r\n\t    var nodeLinkFn = partial || !options._asComponent ? compileNode(el, options) : null;\r\n\t    // link function for the childNodes\r\n\t    var childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && !isScript(el) && el.hasChildNodes() ? compileNodeList(el.childNodes, options) : null;\r\n\t\r\n\t    /**\r\n\t     * A composite linker function to be called on a already\r\n\t     * compiled piece of DOM, which instantiates all directive\r\n\t     * instances.\r\n\t     *\r\n\t     * @param {Vue} vm\r\n\t     * @param {Element|DocumentFragment} el\r\n\t     * @param {Vue} [host] - host vm of transcluded content\r\n\t     * @param {Object} [scope] - v-for scope\r\n\t     * @param {Fragment} [frag] - link context fragment\r\n\t     * @return {Function|undefined}\r\n\t     */\r\n\t\r\n\t    return function compositeLinkFn(vm, el, host, scope, frag) {\r\n\t      // cache childNodes before linking parent, fix #657\r\n\t      var childNodes = toArray(el.childNodes);\r\n\t      // link\r\n\t      var dirs = linkAndCapture(function compositeLinkCapturer() {\r\n\t        if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag);\r\n\t        if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag);\r\n\t      }, vm);\r\n\t      return makeUnlinkFn(vm, dirs);\r\n\t    };\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Apply a linker to a vm/element pair and capture the\r\n\t   * directives created during the process.\r\n\t   *\r\n\t   * @param {Function} linker\r\n\t   * @param {Vue} vm\r\n\t   */\r\n\t\r\n\t  function linkAndCapture(linker, vm) {\r\n\t    /* istanbul ignore if */\r\n\t    if (false) {}\r\n\t    var originalDirCount = vm._directives.length;\r\n\t    linker();\r\n\t    var dirs = vm._directives.slice(originalDirCount);\r\n\t    dirs.sort(directiveComparator);\r\n\t    for (var i = 0, l = dirs.length; i < l; i++) {\r\n\t      dirs[i]._bind();\r\n\t    }\r\n\t    return dirs;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Directive priority sort comparator\r\n\t   *\r\n\t   * @param {Object} a\r\n\t   * @param {Object} b\r\n\t   */\r\n\t\r\n\t  function directiveComparator(a, b) {\r\n\t    a = a.descriptor.def.priority || DEFAULT_PRIORITY;\r\n\t    b = b.descriptor.def.priority || DEFAULT_PRIORITY;\r\n\t    return a > b ? -1 : a === b ? 0 : 1;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Linker functions return an unlink function that\r\n\t   * tearsdown all directives instances generated during\r\n\t   * the process.\r\n\t   *\r\n\t   * We create unlink functions with only the necessary\r\n\t   * information to avoid retaining additional closures.\r\n\t   *\r\n\t   * @param {Vue} vm\r\n\t   * @param {Array} dirs\r\n\t   * @param {Vue} [context]\r\n\t   * @param {Array} [contextDirs]\r\n\t   * @return {Function}\r\n\t   */\r\n\t\r\n\t  function makeUnlinkFn(vm, dirs, context, contextDirs) {\r\n\t    function unlink(destroying) {\r\n\t      teardownDirs(vm, dirs, destroying);\r\n\t      if (context && contextDirs) {\r\n\t        teardownDirs(context, contextDirs);\r\n\t      }\r\n\t    }\r\n\t    // expose linked directives\r\n\t    unlink.dirs = dirs;\r\n\t    return unlink;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Teardown partial linked directives.\r\n\t   *\r\n\t   * @param {Vue} vm\r\n\t   * @param {Array} dirs\r\n\t   * @param {Boolean} destroying\r\n\t   */\r\n\t\r\n\t  function teardownDirs(vm, dirs, destroying) {\r\n\t    var i = dirs.length;\r\n\t    while (i--) {\r\n\t      dirs[i]._teardown();\r\n\t      if ('development' !== 'production' && !destroying) {\r\n\t        vm._directives.$remove(dirs[i]);\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Compile link props on an instance.\r\n\t   *\r\n\t   * @param {Vue} vm\r\n\t   * @param {Element} el\r\n\t   * @param {Object} props\r\n\t   * @param {Object} [scope]\r\n\t   * @return {Function}\r\n\t   */\r\n\t\r\n\t  function compileAndLinkProps(vm, el, props, scope) {\r\n\t    var propsLinkFn = compileProps(el, props, vm);\r\n\t    var propDirs = linkAndCapture(function () {\r\n\t      propsLinkFn(vm, scope);\r\n\t    }, vm);\r\n\t    return makeUnlinkFn(vm, propDirs);\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Compile the root element of an instance.\r\n\t   *\r\n\t   * 1. attrs on context container (context scope)\r\n\t   * 2. attrs on the component template root node, if\r\n\t   *    replace:true (child scope)\r\n\t   *\r\n\t   * If this is a fragment instance, we only need to compile 1.\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @param {Object} options\r\n\t   * @param {Object} contextOptions\r\n\t   * @return {Function}\r\n\t   */\r\n\t\r\n\t  function compileRoot(el, options, contextOptions) {\r\n\t    var containerAttrs = options._containerAttrs;\r\n\t    var replacerAttrs = options._replacerAttrs;\r\n\t    var contextLinkFn, replacerLinkFn;\r\n\t\r\n\t    // only need to compile other attributes for\r\n\t    // non-fragment instances\r\n\t    if (el.nodeType !== 11) {\r\n\t      // for components, container and replacer need to be\r\n\t      // compiled separately and linked in different scopes.\r\n\t      if (options._asComponent) {\r\n\t        // 2. container attributes\r\n\t        if (containerAttrs && contextOptions) {\r\n\t          contextLinkFn = compileDirectives(containerAttrs, contextOptions);\r\n\t        }\r\n\t        if (replacerAttrs) {\r\n\t          // 3. replacer attributes\r\n\t          replacerLinkFn = compileDirectives(replacerAttrs, options);\r\n\t        }\r\n\t      } else {\r\n\t        // non-component, just compile as a normal element.\r\n\t        replacerLinkFn = compileDirectives(el.attributes, options);\r\n\t      }\r\n\t    } else if ('development' !== 'production' && containerAttrs) {\r\n\t      // warn container directives for fragment instances\r\n\t      var names = containerAttrs.filter(function (attr) {\r\n\t        // allow vue-loader/vueify scoped css attributes\r\n\t        return attr.name.indexOf('_v-') < 0 &&\r\n\t        // allow event listeners\r\n\t        !onRE.test(attr.name) &&\r\n\t        // allow slots\r\n\t        attr.name !== 'slot';\r\n\t      }).map(function (attr) {\r\n\t        return '\"' + attr.name + '\"';\r\n\t      });\r\n\t      if (names.length) {\r\n\t        var plural = names.length > 1;\r\n\t        warn('Attribute' + (plural ? 's ' : ' ') + names.join(', ') + (plural ? ' are' : ' is') + ' ignored on component ' + '<' + options.el.tagName.toLowerCase() + '> because ' + 'the component is a fragment instance: ' + 'http://vuejs.org/guide/components.html#Fragment-Instance');\r\n\t      }\r\n\t    }\r\n\t\r\n\t    options._containerAttrs = options._replacerAttrs = null;\r\n\t    return function rootLinkFn(vm, el, scope) {\r\n\t      // link context scope dirs\r\n\t      var context = vm._context;\r\n\t      var contextDirs;\r\n\t      if (context && contextLinkFn) {\r\n\t        contextDirs = linkAndCapture(function () {\r\n\t          contextLinkFn(context, el, null, scope);\r\n\t        }, context);\r\n\t      }\r\n\t\r\n\t      // link self\r\n\t      var selfDirs = linkAndCapture(function () {\r\n\t        if (replacerLinkFn) replacerLinkFn(vm, el);\r\n\t      }, vm);\r\n\t\r\n\t      // return the unlink function that tearsdown context\r\n\t      // container directives.\r\n\t      return makeUnlinkFn(vm, selfDirs, context, contextDirs);\r\n\t    };\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Compile a node and return a nodeLinkFn based on the\r\n\t   * node type.\r\n\t   *\r\n\t   * @param {Node} node\r\n\t   * @param {Object} options\r\n\t   * @return {Function|null}\r\n\t   */\r\n\t\r\n\t  function compileNode(node, options) {\r\n\t    var type = node.nodeType;\r\n\t    if (type === 1 && !isScript(node)) {\r\n\t      return compileElement(node, options);\r\n\t    } else if (type === 3 && node.data.trim()) {\r\n\t      return compileTextNode(node, options);\r\n\t    } else {\r\n\t      return null;\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Compile an element and return a nodeLinkFn.\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @param {Object} options\r\n\t   * @return {Function|null}\r\n\t   */\r\n\t\r\n\t  function compileElement(el, options) {\r\n\t    // preprocess textareas.\r\n\t    // textarea treats its text content as the initial value.\r\n\t    // just bind it as an attr directive for value.\r\n\t    if (el.tagName === 'TEXTAREA') {\r\n\t      var tokens = parseText(el.value);\r\n\t      if (tokens) {\r\n\t        el.setAttribute(':value', tokensToExp(tokens));\r\n\t        el.value = '';\r\n\t      }\r\n\t    }\r\n\t    var linkFn;\r\n\t    var hasAttrs = el.hasAttributes();\r\n\t    var attrs = hasAttrs && toArray(el.attributes);\r\n\t    // check terminal directives (for & if)\r\n\t    if (hasAttrs) {\r\n\t      linkFn = checkTerminalDirectives(el, attrs, options);\r\n\t    }\r\n\t    // check element directives\r\n\t    if (!linkFn) {\r\n\t      linkFn = checkElementDirectives(el, options);\r\n\t    }\r\n\t    // check component\r\n\t    if (!linkFn) {\r\n\t      linkFn = checkComponent(el, options);\r\n\t    }\r\n\t    // normal directives\r\n\t    if (!linkFn && hasAttrs) {\r\n\t      linkFn = compileDirectives(attrs, options);\r\n\t    }\r\n\t    return linkFn;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Compile a textNode and return a nodeLinkFn.\r\n\t   *\r\n\t   * @param {TextNode} node\r\n\t   * @param {Object} options\r\n\t   * @return {Function|null} textNodeLinkFn\r\n\t   */\r\n\t\r\n\t  function compileTextNode(node, options) {\r\n\t    // skip marked text nodes\r\n\t    if (node._skip) {\r\n\t      return removeText;\r\n\t    }\r\n\t\r\n\t    var tokens = parseText(node.wholeText);\r\n\t    if (!tokens) {\r\n\t      return null;\r\n\t    }\r\n\t\r\n\t    // mark adjacent text nodes as skipped,\r\n\t    // because we are using node.wholeText to compile\r\n\t    // all adjacent text nodes together. This fixes\r\n\t    // issues in IE where sometimes it splits up a single\r\n\t    // text node into multiple ones.\r\n\t    var next = node.nextSibling;\r\n\t    while (next && next.nodeType === 3) {\r\n\t      next._skip = true;\r\n\t      next = next.nextSibling;\r\n\t    }\r\n\t\r\n\t    var frag = document.createDocumentFragment();\r\n\t    var el, token;\r\n\t    for (var i = 0, l = tokens.length; i < l; i++) {\r\n\t      token = tokens[i];\r\n\t      el = token.tag ? processTextToken(token, options) : document.createTextNode(token.value);\r\n\t      frag.appendChild(el);\r\n\t    }\r\n\t    return makeTextNodeLinkFn(tokens, frag, options);\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Linker for an skipped text node.\r\n\t   *\r\n\t   * @param {Vue} vm\r\n\t   * @param {Text} node\r\n\t   */\r\n\t\r\n\t  function removeText(vm, node) {\r\n\t    remove(node);\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Process a single text token.\r\n\t   *\r\n\t   * @param {Object} token\r\n\t   * @param {Object} options\r\n\t   * @return {Node}\r\n\t   */\r\n\t\r\n\t  function processTextToken(token, options) {\r\n\t    var el;\r\n\t    if (token.oneTime) {\r\n\t      el = document.createTextNode(token.value);\r\n\t    } else {\r\n\t      if (token.html) {\r\n\t        el = document.createComment('v-html');\r\n\t        setTokenType('html');\r\n\t      } else {\r\n\t        // IE will clean up empty textNodes during\r\n\t        // frag.cloneNode(true), so we have to give it\r\n\t        // something here...\r\n\t        el = document.createTextNode(' ');\r\n\t        setTokenType('text');\r\n\t      }\r\n\t    }\r\n\t    function setTokenType(type) {\r\n\t      if (token.descriptor) return;\r\n\t      var parsed = parseDirective(token.value);\r\n\t      token.descriptor = {\r\n\t        name: type,\r\n\t        def: directives[type],\r\n\t        expression: parsed.expression,\r\n\t        filters: parsed.filters\r\n\t      };\r\n\t    }\r\n\t    return el;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Build a function that processes a textNode.\r\n\t   *\r\n\t   * @param {Array<Object>} tokens\r\n\t   * @param {DocumentFragment} frag\r\n\t   */\r\n\t\r\n\t  function makeTextNodeLinkFn(tokens, frag) {\r\n\t    return function textNodeLinkFn(vm, el, host, scope) {\r\n\t      var fragClone = frag.cloneNode(true);\r\n\t      var childNodes = toArray(fragClone.childNodes);\r\n\t      var token, value, node;\r\n\t      for (var i = 0, l = tokens.length; i < l; i++) {\r\n\t        token = tokens[i];\r\n\t        value = token.value;\r\n\t        if (token.tag) {\r\n\t          node = childNodes[i];\r\n\t          if (token.oneTime) {\r\n\t            value = (scope || vm).$eval(value);\r\n\t            if (token.html) {\r\n\t              replace(node, parseTemplate(value, true));\r\n\t            } else {\r\n\t              node.data = _toString(value);\r\n\t            }\r\n\t          } else {\r\n\t            vm._bindDir(token.descriptor, node, host, scope);\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t      replace(el, fragClone);\r\n\t    };\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Compile a node list and return a childLinkFn.\r\n\t   *\r\n\t   * @param {NodeList} nodeList\r\n\t   * @param {Object} options\r\n\t   * @return {Function|undefined}\r\n\t   */\r\n\t\r\n\t  function compileNodeList(nodeList, options) {\r\n\t    var linkFns = [];\r\n\t    var nodeLinkFn, childLinkFn, node;\r\n\t    for (var i = 0, l = nodeList.length; i < l; i++) {\r\n\t      node = nodeList[i];\r\n\t      nodeLinkFn = compileNode(node, options);\r\n\t      childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && node.tagName !== 'SCRIPT' && node.hasChildNodes() ? compileNodeList(node.childNodes, options) : null;\r\n\t      linkFns.push(nodeLinkFn, childLinkFn);\r\n\t    }\r\n\t    return linkFns.length ? makeChildLinkFn(linkFns) : null;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Make a child link function for a node's childNodes.\r\n\t   *\r\n\t   * @param {Array<Function>} linkFns\r\n\t   * @return {Function} childLinkFn\r\n\t   */\r\n\t\r\n\t  function makeChildLinkFn(linkFns) {\r\n\t    return function childLinkFn(vm, nodes, host, scope, frag) {\r\n\t      var node, nodeLinkFn, childrenLinkFn;\r\n\t      for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {\r\n\t        node = nodes[n];\r\n\t        nodeLinkFn = linkFns[i++];\r\n\t        childrenLinkFn = linkFns[i++];\r\n\t        // cache childNodes before linking parent, fix #657\r\n\t        var childNodes = toArray(node.childNodes);\r\n\t        if (nodeLinkFn) {\r\n\t          nodeLinkFn(vm, node, host, scope, frag);\r\n\t        }\r\n\t        if (childrenLinkFn) {\r\n\t          childrenLinkFn(vm, childNodes, host, scope, frag);\r\n\t        }\r\n\t      }\r\n\t    };\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Check for element directives (custom elements that should\r\n\t   * be resovled as terminal directives).\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @param {Object} options\r\n\t   */\r\n\t\r\n\t  function checkElementDirectives(el, options) {\r\n\t    var tag = el.tagName.toLowerCase();\r\n\t    if (commonTagRE.test(tag)) {\r\n\t      return;\r\n\t    }\r\n\t    var def = resolveAsset(options, 'elementDirectives', tag);\r\n\t    if (def) {\r\n\t      return makeTerminalNodeLinkFn(el, tag, '', options, def);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Check if an element is a component. If yes, return\r\n\t   * a component link function.\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @param {Object} options\r\n\t   * @return {Function|undefined}\r\n\t   */\r\n\t\r\n\t  function checkComponent(el, options) {\r\n\t    var component = checkComponentAttr(el, options);\r\n\t    if (component) {\r\n\t      var ref = findRef(el);\r\n\t      var descriptor = {\r\n\t        name: 'component',\r\n\t        ref: ref,\r\n\t        expression: component.id,\r\n\t        def: internalDirectives.component,\r\n\t        modifiers: {\r\n\t          literal: !component.dynamic\r\n\t        }\r\n\t      };\r\n\t      var componentLinkFn = function componentLinkFn(vm, el, host, scope, frag) {\r\n\t        if (ref) {\r\n\t          defineReactive((scope || vm).$refs, ref, null);\r\n\t        }\r\n\t        vm._bindDir(descriptor, el, host, scope, frag);\r\n\t      };\r\n\t      componentLinkFn.terminal = true;\r\n\t      return componentLinkFn;\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Check an element for terminal directives in fixed order.\r\n\t   * If it finds one, return a terminal link function.\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @param {Array} attrs\r\n\t   * @param {Object} options\r\n\t   * @return {Function} terminalLinkFn\r\n\t   */\r\n\t\r\n\t  function checkTerminalDirectives(el, attrs, options) {\r\n\t    // skip v-pre\r\n\t    if (getAttr(el, 'v-pre') !== null) {\r\n\t      return skip;\r\n\t    }\r\n\t    // skip v-else block, but only if following v-if\r\n\t    if (el.hasAttribute('v-else')) {\r\n\t      var prev = el.previousElementSibling;\r\n\t      if (prev && prev.hasAttribute('v-if')) {\r\n\t        return skip;\r\n\t      }\r\n\t    }\r\n\t\r\n\t    var attr, name, value, modifiers, matched, dirName, rawName, arg, def, termDef;\r\n\t    for (var i = 0, j = attrs.length; i < j; i++) {\r\n\t      attr = attrs[i];\r\n\t      name = attr.name.replace(modifierRE, '');\r\n\t      if (matched = name.match(dirAttrRE)) {\r\n\t        def = resolveAsset(options, 'directives', matched[1]);\r\n\t        if (def && def.terminal) {\r\n\t          if (!termDef || (def.priority || DEFAULT_TERMINAL_PRIORITY) > termDef.priority) {\r\n\t            termDef = def;\r\n\t            rawName = attr.name;\r\n\t            modifiers = parseModifiers(attr.name);\r\n\t            value = attr.value;\r\n\t            dirName = matched[1];\r\n\t            arg = matched[2];\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t\r\n\t    if (termDef) {\r\n\t      return makeTerminalNodeLinkFn(el, dirName, value, options, termDef, rawName, arg, modifiers);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  function skip() {}\r\n\t  skip.terminal = true;\r\n\t\r\n\t  /**\r\n\t   * Build a node link function for a terminal directive.\r\n\t   * A terminal link function terminates the current\r\n\t   * compilation recursion and handles compilation of the\r\n\t   * subtree in the directive.\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @param {String} dirName\r\n\t   * @param {String} value\r\n\t   * @param {Object} options\r\n\t   * @param {Object} def\r\n\t   * @param {String} [rawName]\r\n\t   * @param {String} [arg]\r\n\t   * @param {Object} [modifiers]\r\n\t   * @return {Function} terminalLinkFn\r\n\t   */\r\n\t\r\n\t  function makeTerminalNodeLinkFn(el, dirName, value, options, def, rawName, arg, modifiers) {\r\n\t    var parsed = parseDirective(value);\r\n\t    var descriptor = {\r\n\t      name: dirName,\r\n\t      arg: arg,\r\n\t      expression: parsed.expression,\r\n\t      filters: parsed.filters,\r\n\t      raw: value,\r\n\t      attr: rawName,\r\n\t      modifiers: modifiers,\r\n\t      def: def\r\n\t    };\r\n\t    // check ref for v-for and router-view\r\n\t    if (dirName === 'for' || dirName === 'router-view') {\r\n\t      descriptor.ref = findRef(el);\r\n\t    }\r\n\t    var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {\r\n\t      if (descriptor.ref) {\r\n\t        defineReactive((scope || vm).$refs, descriptor.ref, null);\r\n\t      }\r\n\t      vm._bindDir(descriptor, el, host, scope, frag);\r\n\t    };\r\n\t    fn.terminal = true;\r\n\t    return fn;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Compile the directives on an element and return a linker.\r\n\t   *\r\n\t   * @param {Array|NamedNodeMap} attrs\r\n\t   * @param {Object} options\r\n\t   * @return {Function}\r\n\t   */\r\n\t\r\n\t  function compileDirectives(attrs, options) {\r\n\t    var i = attrs.length;\r\n\t    var dirs = [];\r\n\t    var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens, matched;\r\n\t    while (i--) {\r\n\t      attr = attrs[i];\r\n\t      name = rawName = attr.name;\r\n\t      value = rawValue = attr.value;\r\n\t      tokens = parseText(value);\r\n\t      // reset arg\r\n\t      arg = null;\r\n\t      // check modifiers\r\n\t      modifiers = parseModifiers(name);\r\n\t      name = name.replace(modifierRE, '');\r\n\t\r\n\t      // attribute interpolations\r\n\t      if (tokens) {\r\n\t        value = tokensToExp(tokens);\r\n\t        arg = name;\r\n\t        pushDir('bind', directives.bind, tokens);\r\n\t        // warn against mixing mustaches with v-bind\r\n\t        if (true) {\r\n\t          if (name === 'class' && Array.prototype.some.call(attrs, function (attr) {\r\n\t            return attr.name === ':class' || attr.name === 'v-bind:class';\r\n\t          })) {\r\n\t            warn('class=\"' + rawValue + '\": Do not mix mustache interpolation ' + 'and v-bind for \"class\" on the same element. Use one or the other.', options);\r\n\t          }\r\n\t        }\r\n\t      } else\r\n\t\r\n\t        // special attribute: transition\r\n\t        if (transitionRE.test(name)) {\r\n\t          modifiers.literal = !bindRE.test(name);\r\n\t          pushDir('transition', internalDirectives.transition);\r\n\t        } else\r\n\t\r\n\t          // event handlers\r\n\t          if (onRE.test(name)) {\r\n\t            arg = name.replace(onRE, '');\r\n\t            pushDir('on', directives.on);\r\n\t          } else\r\n\t\r\n\t            // attribute bindings\r\n\t            if (bindRE.test(name)) {\r\n\t              dirName = name.replace(bindRE, '');\r\n\t              if (dirName === 'style' || dirName === 'class') {\r\n\t                pushDir(dirName, internalDirectives[dirName]);\r\n\t              } else {\r\n\t                arg = dirName;\r\n\t                pushDir('bind', directives.bind);\r\n\t              }\r\n\t            } else\r\n\t\r\n\t              // normal directives\r\n\t              if (matched = name.match(dirAttrRE)) {\r\n\t                dirName = matched[1];\r\n\t                arg = matched[2];\r\n\t\r\n\t                // skip v-else (when used with v-show)\r\n\t                if (dirName === 'else') {\r\n\t                  continue;\r\n\t                }\r\n\t\r\n\t                dirDef = resolveAsset(options, 'directives', dirName, true);\r\n\t                if (dirDef) {\r\n\t                  pushDir(dirName, dirDef);\r\n\t                }\r\n\t              }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * Push a directive.\r\n\t     *\r\n\t     * @param {String} dirName\r\n\t     * @param {Object|Function} def\r\n\t     * @param {Array} [interpTokens]\r\n\t     */\r\n\t\r\n\t    function pushDir(dirName, def, interpTokens) {\r\n\t      var hasOneTimeToken = interpTokens && hasOneTime(interpTokens);\r\n\t      var parsed = !hasOneTimeToken && parseDirective(value);\r\n\t      dirs.push({\r\n\t        name: dirName,\r\n\t        attr: rawName,\r\n\t        raw: rawValue,\r\n\t        def: def,\r\n\t        arg: arg,\r\n\t        modifiers: modifiers,\r\n\t        // conversion from interpolation strings with one-time token\r\n\t        // to expression is differed until directive bind time so that we\r\n\t        // have access to the actual vm context for one-time bindings.\r\n\t        expression: parsed && parsed.expression,\r\n\t        filters: parsed && parsed.filters,\r\n\t        interp: interpTokens,\r\n\t        hasOneTime: hasOneTimeToken\r\n\t      });\r\n\t    }\r\n\t\r\n\t    if (dirs.length) {\r\n\t      return makeNodeLinkFn(dirs);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Parse modifiers from directive attribute name.\r\n\t   *\r\n\t   * @param {String} name\r\n\t   * @return {Object}\r\n\t   */\r\n\t\r\n\t  function parseModifiers(name) {\r\n\t    var res = Object.create(null);\r\n\t    var match = name.match(modifierRE);\r\n\t    if (match) {\r\n\t      var i = match.length;\r\n\t      while (i--) {\r\n\t        res[match[i].slice(1)] = true;\r\n\t      }\r\n\t    }\r\n\t    return res;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Build a link function for all directives on a single node.\r\n\t   *\r\n\t   * @param {Array} directives\r\n\t   * @return {Function} directivesLinkFn\r\n\t   */\r\n\t\r\n\t  function makeNodeLinkFn(directives) {\r\n\t    return function nodeLinkFn(vm, el, host, scope, frag) {\r\n\t      // reverse apply because it's sorted low to high\r\n\t      var i = directives.length;\r\n\t      while (i--) {\r\n\t        vm._bindDir(directives[i], el, host, scope, frag);\r\n\t      }\r\n\t    };\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Check if an interpolation string contains one-time tokens.\r\n\t   *\r\n\t   * @param {Array} tokens\r\n\t   * @return {Boolean}\r\n\t   */\r\n\t\r\n\t  function hasOneTime(tokens) {\r\n\t    var i = tokens.length;\r\n\t    while (i--) {\r\n\t      if (tokens[i].oneTime) return true;\r\n\t    }\r\n\t  }\r\n\t\r\n\t  function isScript(el) {\r\n\t    return el.tagName === 'SCRIPT' && (!el.hasAttribute('type') || el.getAttribute('type') === 'text/javascript');\r\n\t  }\r\n\t\r\n\t  var specialCharRE = /[^\\w\\-:\\.]/;\r\n\t\r\n\t  /**\r\n\t   * Process an element or a DocumentFragment based on a\r\n\t   * instance option object. This allows us to transclude\r\n\t   * a template node/fragment before the instance is created,\r\n\t   * so the processed fragment can then be cloned and reused\r\n\t   * in v-for.\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @param {Object} options\r\n\t   * @return {Element|DocumentFragment}\r\n\t   */\r\n\t\r\n\t  function transclude(el, options) {\r\n\t    // extract container attributes to pass them down\r\n\t    // to compiler, because they need to be compiled in\r\n\t    // parent scope. we are mutating the options object here\r\n\t    // assuming the same object will be used for compile\r\n\t    // right after this.\r\n\t    if (options) {\r\n\t      options._containerAttrs = extractAttrs(el);\r\n\t    }\r\n\t    // for template tags, what we want is its content as\r\n\t    // a documentFragment (for fragment instances)\r\n\t    if (isTemplate(el)) {\r\n\t      el = parseTemplate(el);\r\n\t    }\r\n\t    if (options) {\r\n\t      if (options._asComponent && !options.template) {\r\n\t        options.template = '<slot></slot>';\r\n\t      }\r\n\t      if (options.template) {\r\n\t        options._content = extractContent(el);\r\n\t        el = transcludeTemplate(el, options);\r\n\t      }\r\n\t    }\r\n\t    if (isFragment(el)) {\r\n\t      // anchors for fragment instance\r\n\t      // passing in `persist: true` to avoid them being\r\n\t      // discarded by IE during template cloning\r\n\t      prepend(createAnchor('v-start', true), el);\r\n\t      el.appendChild(createAnchor('v-end', true));\r\n\t    }\r\n\t    return el;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Process the template option.\r\n\t   * If the replace option is true this will swap the $el.\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @param {Object} options\r\n\t   * @return {Element|DocumentFragment}\r\n\t   */\r\n\t\r\n\t  function transcludeTemplate(el, options) {\r\n\t    var template = options.template;\r\n\t    var frag = parseTemplate(template, true);\r\n\t    if (frag) {\r\n\t      var replacer = frag.firstChild;\r\n\t      var tag = replacer.tagName && replacer.tagName.toLowerCase();\r\n\t      if (options.replace) {\r\n\t        /* istanbul ignore if */\r\n\t        if (el === document.body) {\r\n\t          'development' !== 'production' && warn('You are mounting an instance with a template to ' + '<body>. This will replace <body> entirely. You ' + 'should probably use `replace: false` here.');\r\n\t        }\r\n\t        // there are many cases where the instance must\r\n\t        // become a fragment instance: basically anything that\r\n\t        // can create more than 1 root nodes.\r\n\t        if (\r\n\t        // multi-children template\r\n\t        frag.childNodes.length > 1 ||\r\n\t        // non-element template\r\n\t        replacer.nodeType !== 1 ||\r\n\t        // single nested component\r\n\t        tag === 'component' || resolveAsset(options, 'components', tag) || hasBindAttr(replacer, 'is') ||\r\n\t        // element directive\r\n\t        resolveAsset(options, 'elementDirectives', tag) ||\r\n\t        // for block\r\n\t        replacer.hasAttribute('v-for') ||\r\n\t        // if block\r\n\t        replacer.hasAttribute('v-if')) {\r\n\t          return frag;\r\n\t        } else {\r\n\t          options._replacerAttrs = extractAttrs(replacer);\r\n\t          mergeAttrs(el, replacer);\r\n\t          return replacer;\r\n\t        }\r\n\t      } else {\r\n\t        el.appendChild(frag);\r\n\t        return el;\r\n\t      }\r\n\t    } else {\r\n\t      'development' !== 'production' && warn('Invalid template option: ' + template);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Helper to extract a component container's attributes\r\n\t   * into a plain object array.\r\n\t   *\r\n\t   * @param {Element} el\r\n\t   * @return {Array}\r\n\t   */\r\n\t\r\n\t  function extractAttrs(el) {\r\n\t    if (el.nodeType === 1 && el.hasAttributes()) {\r\n\t      return toArray(el.attributes);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Merge the attributes of two elements, and make sure\r\n\t   * the class names are merged properly.\r\n\t   *\r\n\t   * @param {Element} from\r\n\t   * @param {Element} to\r\n\t   */\r\n\t\r\n\t  function mergeAttrs(from, to) {\r\n\t    var attrs = from.attributes;\r\n\t    var i = attrs.length;\r\n\t    var name, value;\r\n\t    while (i--) {\r\n\t      name = attrs[i].name;\r\n\t      value = attrs[i].value;\r\n\t      if (!to.hasAttribute(name) && !specialCharRE.test(name)) {\r\n\t        to.setAttribute(name, value);\r\n\t      } else if (name === 'class' && !parseText(value) && (value = value.trim())) {\r\n\t        value.split(/\\s+/).forEach(function (cls) {\r\n\t          addClass(to, cls);\r\n\t        });\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Scan and determine slot content distribution.\r\n\t   * We do this during transclusion instead at compile time so that\r\n\t   * the distribution is decoupled from the compilation order of\r\n\t   * the slots.\r\n\t   *\r\n\t   * @param {Element|DocumentFragment} template\r\n\t   * @param {Element} content\r\n\t   * @param {Vue} vm\r\n\t   */\r\n\t\r\n\t  function resolveSlots(vm, content) {\r\n\t    if (!content) {\r\n\t      return;\r\n\t    }\r\n\t    var contents = vm._slotContents = Object.create(null);\r\n\t    var el, name;\r\n\t    for (var i = 0, l = content.children.length; i < l; i++) {\r\n\t      el = content.children[i];\r\n\t      /* eslint-disable no-cond-assign */\r\n\t      if (name = el.getAttribute('slot')) {\r\n\t        (contents[name] || (contents[name] = [])).push(el);\r\n\t      }\r\n\t      /* eslint-enable no-cond-assign */\r\n\t      if ('development' !== 'production' && getBindAttr(el, 'slot')) {\r\n\t        warn('The \"slot\" attribute must be static.', vm.$parent);\r\n\t      }\r\n\t    }\r\n\t    for (name in contents) {\r\n\t      contents[name] = extractFragment(contents[name], content);\r\n\t    }\r\n\t    if (content.hasChildNodes()) {\r\n\t      var nodes = content.childNodes;\r\n\t      if (nodes.length === 1 && nodes[0].nodeType === 3 && !nodes[0].data.trim()) {\r\n\t        return;\r\n\t      }\r\n\t      contents['default'] = extractFragment(content.childNodes, content);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Extract qualified content nodes from a node list.\r\n\t   *\r\n\t   * @param {NodeList} nodes\r\n\t   * @return {DocumentFragment}\r\n\t   */\r\n\t\r\n\t  function extractFragment(nodes, parent) {\r\n\t    var frag = document.createDocumentFragment();\r\n\t    nodes = toArray(nodes);\r\n\t    for (var i = 0, l = nodes.length; i < l; i++) {\r\n\t      var node = nodes[i];\r\n\t      if (isTemplate(node) && !node.hasAttribute('v-if') && !node.hasAttribute('v-for')) {\r\n\t        parent.removeChild(node);\r\n\t        node = parseTemplate(node, true);\r\n\t      }\r\n\t      frag.appendChild(node);\r\n\t    }\r\n\t    return frag;\r\n\t  }\r\n\t\r\n\t\r\n\t\r\n\t  var compiler = Object.freeze({\r\n\t  \tcompile: compile,\r\n\t  \tcompileAndLinkProps: compileAndLinkProps,\r\n\t  \tcompileRoot: compileRoot,\r\n\t  \ttransclude: transclude,\r\n\t  \tresolveSlots: resolveSlots\r\n\t  });\r\n\t\r\n\t  function stateMixin (Vue) {\r\n\t    /**\r\n\t     * Accessor for `$data` property, since setting $data\r\n\t     * requires observing the new object and updating\r\n\t     * proxied properties.\r\n\t     */\r\n\t\r\n\t    Object.defineProperty(Vue.prototype, '$data', {\r\n\t      get: function get() {\r\n\t        return this._data;\r\n\t      },\r\n\t      set: function set(newData) {\r\n\t        if (newData !== this._data) {\r\n\t          this._setData(newData);\r\n\t        }\r\n\t      }\r\n\t    });\r\n\t\r\n\t    /**\r\n\t     * Setup the scope of an instance, which contains:\r\n\t     * - observed data\r\n\t     * - computed properties\r\n\t     * - user methods\r\n\t     * - meta properties\r\n\t     */\r\n\t\r\n\t    Vue.prototype._initState = function () {\r\n\t      this._initProps();\r\n\t      this._initMeta();\r\n\t      this._initMethods();\r\n\t      this._initData();\r\n\t      this._initComputed();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Initialize props.\r\n\t     */\r\n\t\r\n\t    Vue.prototype._initProps = function () {\r\n\t      var options = this.$options;\r\n\t      var el = options.el;\r\n\t      var props = options.props;\r\n\t      if (props && !el) {\r\n\t        'development' !== 'production' && warn('Props will not be compiled if no `el` option is ' + 'provided at instantiation.', this);\r\n\t      }\r\n\t      // make sure to convert string selectors into element now\r\n\t      el = options.el = query(el);\r\n\t      this._propsUnlinkFn = el && el.nodeType === 1 && props\r\n\t      // props must be linked in proper scope if inside v-for\r\n\t      ? compileAndLinkProps(this, el, props, this._scope) : null;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Initialize the data.\r\n\t     */\r\n\t\r\n\t    Vue.prototype._initData = function () {\r\n\t      var dataFn = this.$options.data;\r\n\t      var data = this._data = dataFn ? dataFn() : {};\r\n\t      if (!isPlainObject(data)) {\r\n\t        data = {};\r\n\t        'development' !== 'production' && warn('data functions should return an object.', this);\r\n\t      }\r\n\t      var props = this._props;\r\n\t      // proxy data on instance\r\n\t      var keys = Object.keys(data);\r\n\t      var i, key;\r\n\t      i = keys.length;\r\n\t      while (i--) {\r\n\t        key = keys[i];\r\n\t        // there are two scenarios where we can proxy a data key:\r\n\t        // 1. it's not already defined as a prop\r\n\t        // 2. it's provided via a instantiation option AND there are no\r\n\t        //    template prop present\r\n\t        if (!props || !hasOwn(props, key)) {\r\n\t          this._proxy(key);\r\n\t        } else if (true) {\r\n\t          warn('Data field \"' + key + '\" is already defined ' + 'as a prop. To provide default value for a prop, use the \"default\" ' + 'prop option; if you want to pass prop values to an instantiation ' + 'call, use the \"propsData\" option.', this);\r\n\t        }\r\n\t      }\r\n\t      // observe data\r\n\t      observe(data, this);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Swap the instance's $data. Called in $data's setter.\r\n\t     *\r\n\t     * @param {Object} newData\r\n\t     */\r\n\t\r\n\t    Vue.prototype._setData = function (newData) {\r\n\t      newData = newData || {};\r\n\t      var oldData = this._data;\r\n\t      this._data = newData;\r\n\t      var keys, key, i;\r\n\t      // unproxy keys not present in new data\r\n\t      keys = Object.keys(oldData);\r\n\t      i = keys.length;\r\n\t      while (i--) {\r\n\t        key = keys[i];\r\n\t        if (!(key in newData)) {\r\n\t          this._unproxy(key);\r\n\t        }\r\n\t      }\r\n\t      // proxy keys not already proxied,\r\n\t      // and trigger change for changed values\r\n\t      keys = Object.keys(newData);\r\n\t      i = keys.length;\r\n\t      while (i--) {\r\n\t        key = keys[i];\r\n\t        if (!hasOwn(this, key)) {\r\n\t          // new property\r\n\t          this._proxy(key);\r\n\t        }\r\n\t      }\r\n\t      oldData.__ob__.removeVm(this);\r\n\t      observe(newData, this);\r\n\t      this._digest();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Proxy a property, so that\r\n\t     * vm.prop === vm._data.prop\r\n\t     *\r\n\t     * @param {String} key\r\n\t     */\r\n\t\r\n\t    Vue.prototype._proxy = function (key) {\r\n\t      if (!isReserved(key)) {\r\n\t        // need to store ref to self here\r\n\t        // because these getter/setters might\r\n\t        // be called by child scopes via\r\n\t        // prototype inheritance.\r\n\t        var self = this;\r\n\t        Object.defineProperty(self, key, {\r\n\t          configurable: true,\r\n\t          enumerable: true,\r\n\t          get: function proxyGetter() {\r\n\t            return self._data[key];\r\n\t          },\r\n\t          set: function proxySetter(val) {\r\n\t            self._data[key] = val;\r\n\t          }\r\n\t        });\r\n\t      }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Unproxy a property.\r\n\t     *\r\n\t     * @param {String} key\r\n\t     */\r\n\t\r\n\t    Vue.prototype._unproxy = function (key) {\r\n\t      if (!isReserved(key)) {\r\n\t        delete this[key];\r\n\t      }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Force update on every watcher in scope.\r\n\t     */\r\n\t\r\n\t    Vue.prototype._digest = function () {\r\n\t      for (var i = 0, l = this._watchers.length; i < l; i++) {\r\n\t        this._watchers[i].update(true); // shallow updates\r\n\t      }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Setup computed properties. They are essentially\r\n\t     * special getter/setters\r\n\t     */\r\n\t\r\n\t    function noop() {}\r\n\t    Vue.prototype._initComputed = function () {\r\n\t      var computed = this.$options.computed;\r\n\t      if (computed) {\r\n\t        for (var key in computed) {\r\n\t          var userDef = computed[key];\r\n\t          var def = {\r\n\t            enumerable: true,\r\n\t            configurable: true\r\n\t          };\r\n\t          if (typeof userDef === 'function') {\r\n\t            def.get = makeComputedGetter(userDef, this);\r\n\t            def.set = noop;\r\n\t          } else {\r\n\t            def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, this) : bind(userDef.get, this) : noop;\r\n\t            def.set = userDef.set ? bind(userDef.set, this) : noop;\r\n\t          }\r\n\t          Object.defineProperty(this, key, def);\r\n\t        }\r\n\t      }\r\n\t    };\r\n\t\r\n\t    function makeComputedGetter(getter, owner) {\r\n\t      var watcher = new Watcher(owner, getter, null, {\r\n\t        lazy: true\r\n\t      });\r\n\t      return function computedGetter() {\r\n\t        if (watcher.dirty) {\r\n\t          watcher.evaluate();\r\n\t        }\r\n\t        if (Dep.target) {\r\n\t          watcher.depend();\r\n\t        }\r\n\t        return watcher.value;\r\n\t      };\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * Setup instance methods. Methods must be bound to the\r\n\t     * instance since they might be passed down as a prop to\r\n\t     * child components.\r\n\t     */\r\n\t\r\n\t    Vue.prototype._initMethods = function () {\r\n\t      var methods = this.$options.methods;\r\n\t      if (methods) {\r\n\t        for (var key in methods) {\r\n\t          this[key] = bind(methods[key], this);\r\n\t        }\r\n\t      }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Initialize meta information like $index, $key & $value.\r\n\t     */\r\n\t\r\n\t    Vue.prototype._initMeta = function () {\r\n\t      var metas = this.$options._meta;\r\n\t      if (metas) {\r\n\t        for (var key in metas) {\r\n\t          defineReactive(this, key, metas[key]);\r\n\t        }\r\n\t      }\r\n\t    };\r\n\t  }\r\n\t\r\n\t  var eventRE = /^v-on:|^@/;\r\n\t\r\n\t  function eventsMixin (Vue) {\r\n\t    /**\r\n\t     * Setup the instance's option events & watchers.\r\n\t     * If the value is a string, we pull it from the\r\n\t     * instance's methods by name.\r\n\t     */\r\n\t\r\n\t    Vue.prototype._initEvents = function () {\r\n\t      var options = this.$options;\r\n\t      if (options._asComponent) {\r\n\t        registerComponentEvents(this, options.el);\r\n\t      }\r\n\t      registerCallbacks(this, '$on', options.events);\r\n\t      registerCallbacks(this, '$watch', options.watch);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Register v-on events on a child component\r\n\t     *\r\n\t     * @param {Vue} vm\r\n\t     * @param {Element} el\r\n\t     */\r\n\t\r\n\t    function registerComponentEvents(vm, el) {\r\n\t      var attrs = el.attributes;\r\n\t      var name, value, handler;\r\n\t      for (var i = 0, l = attrs.length; i < l; i++) {\r\n\t        name = attrs[i].name;\r\n\t        if (eventRE.test(name)) {\r\n\t          name = name.replace(eventRE, '');\r\n\t          // force the expression into a statement so that\r\n\t          // it always dynamically resolves the method to call (#2670)\r\n\t          // kinda ugly hack, but does the job.\r\n\t          value = attrs[i].value;\r\n\t          if (isSimplePath(value)) {\r\n\t            value += '.apply(this, $arguments)';\r\n\t          }\r\n\t          handler = (vm._scope || vm._context).$eval(value, true);\r\n\t          handler._fromParent = true;\r\n\t          vm.$on(name.replace(eventRE), handler);\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * Register callbacks for option events and watchers.\r\n\t     *\r\n\t     * @param {Vue} vm\r\n\t     * @param {String} action\r\n\t     * @param {Object} hash\r\n\t     */\r\n\t\r\n\t    function registerCallbacks(vm, action, hash) {\r\n\t      if (!hash) return;\r\n\t      var handlers, key, i, j;\r\n\t      for (key in hash) {\r\n\t        handlers = hash[key];\r\n\t        if (isArray(handlers)) {\r\n\t          for (i = 0, j = handlers.length; i < j; i++) {\r\n\t            register(vm, action, key, handlers[i]);\r\n\t          }\r\n\t        } else {\r\n\t          register(vm, action, key, handlers);\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * Helper to register an event/watch callback.\r\n\t     *\r\n\t     * @param {Vue} vm\r\n\t     * @param {String} action\r\n\t     * @param {String} key\r\n\t     * @param {Function|String|Object} handler\r\n\t     * @param {Object} [options]\r\n\t     */\r\n\t\r\n\t    function register(vm, action, key, handler, options) {\r\n\t      var type = typeof handler;\r\n\t      if (type === 'function') {\r\n\t        vm[action](key, handler, options);\r\n\t      } else if (type === 'string') {\r\n\t        var methods = vm.$options.methods;\r\n\t        var method = methods && methods[handler];\r\n\t        if (method) {\r\n\t          vm[action](key, method, options);\r\n\t        } else {\r\n\t          'development' !== 'production' && warn('Unknown method: \"' + handler + '\" when ' + 'registering callback for ' + action + ': \"' + key + '\".', vm);\r\n\t        }\r\n\t      } else if (handler && type === 'object') {\r\n\t        register(vm, action, key, handler.handler, handler);\r\n\t      }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * Setup recursive attached/detached calls\r\n\t     */\r\n\t\r\n\t    Vue.prototype._initDOMHooks = function () {\r\n\t      this.$on('hook:attached', onAttached);\r\n\t      this.$on('hook:detached', onDetached);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Callback to recursively call attached hook on children\r\n\t     */\r\n\t\r\n\t    function onAttached() {\r\n\t      if (!this._isAttached) {\r\n\t        this._isAttached = true;\r\n\t        this.$children.forEach(callAttach);\r\n\t      }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * Iterator to call attached hook\r\n\t     *\r\n\t     * @param {Vue} child\r\n\t     */\r\n\t\r\n\t    function callAttach(child) {\r\n\t      if (!child._isAttached && inDoc(child.$el)) {\r\n\t        child._callHook('attached');\r\n\t      }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * Callback to recursively call detached hook on children\r\n\t     */\r\n\t\r\n\t    function onDetached() {\r\n\t      if (this._isAttached) {\r\n\t        this._isAttached = false;\r\n\t        this.$children.forEach(callDetach);\r\n\t      }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * Iterator to call detached hook\r\n\t     *\r\n\t     * @param {Vue} child\r\n\t     */\r\n\t\r\n\t    function callDetach(child) {\r\n\t      if (child._isAttached && !inDoc(child.$el)) {\r\n\t        child._callHook('detached');\r\n\t      }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * Trigger all handlers for a hook\r\n\t     *\r\n\t     * @param {String} hook\r\n\t     */\r\n\t\r\n\t    Vue.prototype._callHook = function (hook) {\r\n\t      this.$emit('pre-hook:' + hook);\r\n\t      var handlers = this.$options[hook];\r\n\t      if (handlers) {\r\n\t        for (var i = 0, j = handlers.length; i < j; i++) {\r\n\t          handlers[i].call(this);\r\n\t        }\r\n\t      }\r\n\t      this.$emit('hook:' + hook);\r\n\t    };\r\n\t  }\r\n\t\r\n\t  function noop$1() {}\r\n\t\r\n\t  /**\r\n\t   * A directive links a DOM element with a piece of data,\r\n\t   * which is the result of evaluating an expression.\r\n\t   * It registers a watcher with the expression and calls\r\n\t   * the DOM update function when a change is triggered.\r\n\t   *\r\n\t   * @param {Object} descriptor\r\n\t   *                 - {String} name\r\n\t   *                 - {Object} def\r\n\t   *                 - {String} expression\r\n\t   *                 - {Array<Object>} [filters]\r\n\t   *                 - {Object} [modifiers]\r\n\t   *                 - {Boolean} literal\r\n\t   *                 - {String} attr\r\n\t   *                 - {String} arg\r\n\t   *                 - {String} raw\r\n\t   *                 - {String} [ref]\r\n\t   *                 - {Array<Object>} [interp]\r\n\t   *                 - {Boolean} [hasOneTime]\r\n\t   * @param {Vue} vm\r\n\t   * @param {Node} el\r\n\t   * @param {Vue} [host] - transclusion host component\r\n\t   * @param {Object} [scope] - v-for scope\r\n\t   * @param {Fragment} [frag] - owner fragment\r\n\t   * @constructor\r\n\t   */\r\n\t  function Directive(descriptor, vm, el, host, scope, frag) {\r\n\t    this.vm = vm;\r\n\t    this.el = el;\r\n\t    // copy descriptor properties\r\n\t    this.descriptor = descriptor;\r\n\t    this.name = descriptor.name;\r\n\t    this.expression = descriptor.expression;\r\n\t    this.arg = descriptor.arg;\r\n\t    this.modifiers = descriptor.modifiers;\r\n\t    this.filters = descriptor.filters;\r\n\t    this.literal = this.modifiers && this.modifiers.literal;\r\n\t    // private\r\n\t    this._locked = false;\r\n\t    this._bound = false;\r\n\t    this._listeners = null;\r\n\t    // link context\r\n\t    this._host = host;\r\n\t    this._scope = scope;\r\n\t    this._frag = frag;\r\n\t    // store directives on node in dev mode\r\n\t    if ('development' !== 'production' && this.el) {\r\n\t      this.el._vue_directives = this.el._vue_directives || [];\r\n\t      this.el._vue_directives.push(this);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Initialize the directive, mixin definition properties,\r\n\t   * setup the watcher, call definition bind() and update()\r\n\t   * if present.\r\n\t   */\r\n\t\r\n\t  Directive.prototype._bind = function () {\r\n\t    var name = this.name;\r\n\t    var descriptor = this.descriptor;\r\n\t\r\n\t    // remove attribute\r\n\t    if ((name !== 'cloak' || this.vm._isCompiled) && this.el && this.el.removeAttribute) {\r\n\t      var attr = descriptor.attr || 'v-' + name;\r\n\t      this.el.removeAttribute(attr);\r\n\t    }\r\n\t\r\n\t    // copy def properties\r\n\t    var def = descriptor.def;\r\n\t    if (typeof def === 'function') {\r\n\t      this.update = def;\r\n\t    } else {\r\n\t      extend(this, def);\r\n\t    }\r\n\t\r\n\t    // setup directive params\r\n\t    this._setupParams();\r\n\t\r\n\t    // initial bind\r\n\t    if (this.bind) {\r\n\t      this.bind();\r\n\t    }\r\n\t    this._bound = true;\r\n\t\r\n\t    if (this.literal) {\r\n\t      this.update && this.update(descriptor.raw);\r\n\t    } else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {\r\n\t      // wrapped updater for context\r\n\t      var dir = this;\r\n\t      if (this.update) {\r\n\t        this._update = function (val, oldVal) {\r\n\t          if (!dir._locked) {\r\n\t            dir.update(val, oldVal);\r\n\t          }\r\n\t        };\r\n\t      } else {\r\n\t        this._update = noop$1;\r\n\t      }\r\n\t      var preProcess = this._preProcess ? bind(this._preProcess, this) : null;\r\n\t      var postProcess = this._postProcess ? bind(this._postProcess, this) : null;\r\n\t      var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, // callback\r\n\t      {\r\n\t        filters: this.filters,\r\n\t        twoWay: this.twoWay,\r\n\t        deep: this.deep,\r\n\t        preProcess: preProcess,\r\n\t        postProcess: postProcess,\r\n\t        scope: this._scope\r\n\t      });\r\n\t      // v-model with inital inline value need to sync back to\r\n\t      // model instead of update to DOM on init. They would\r\n\t      // set the afterBind hook to indicate that.\r\n\t      if (this.afterBind) {\r\n\t        this.afterBind();\r\n\t      } else if (this.update) {\r\n\t        this.update(watcher.value);\r\n\t      }\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Setup all param attributes, e.g. track-by,\r\n\t   * transition-mode, etc...\r\n\t   */\r\n\t\r\n\t  Directive.prototype._setupParams = function () {\r\n\t    if (!this.params) {\r\n\t      return;\r\n\t    }\r\n\t    var params = this.params;\r\n\t    // swap the params array with a fresh object.\r\n\t    this.params = Object.create(null);\r\n\t    var i = params.length;\r\n\t    var key, val, mappedKey;\r\n\t    while (i--) {\r\n\t      key = hyphenate(params[i]);\r\n\t      mappedKey = camelize(key);\r\n\t      val = getBindAttr(this.el, key);\r\n\t      if (val != null) {\r\n\t        // dynamic\r\n\t        this._setupParamWatcher(mappedKey, val);\r\n\t      } else {\r\n\t        // static\r\n\t        val = getAttr(this.el, key);\r\n\t        if (val != null) {\r\n\t          this.params[mappedKey] = val === '' ? true : val;\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Setup a watcher for a dynamic param.\r\n\t   *\r\n\t   * @param {String} key\r\n\t   * @param {String} expression\r\n\t   */\r\n\t\r\n\t  Directive.prototype._setupParamWatcher = function (key, expression) {\r\n\t    var self = this;\r\n\t    var called = false;\r\n\t    var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {\r\n\t      self.params[key] = val;\r\n\t      // since we are in immediate mode,\r\n\t      // only call the param change callbacks if this is not the first update.\r\n\t      if (called) {\r\n\t        var cb = self.paramWatchers && self.paramWatchers[key];\r\n\t        if (cb) {\r\n\t          cb.call(self, val, oldVal);\r\n\t        }\r\n\t      } else {\r\n\t        called = true;\r\n\t      }\r\n\t    }, {\r\n\t      immediate: true,\r\n\t      user: false\r\n\t    });(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch);\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Check if the directive is a function caller\r\n\t   * and if the expression is a callable one. If both true,\r\n\t   * we wrap up the expression and use it as the event\r\n\t   * handler.\r\n\t   *\r\n\t   * e.g. on-click=\"a++\"\r\n\t   *\r\n\t   * @return {Boolean}\r\n\t   */\r\n\t\r\n\t  Directive.prototype._checkStatement = function () {\r\n\t    var expression = this.expression;\r\n\t    if (expression && this.acceptStatement && !isSimplePath(expression)) {\r\n\t      var fn = parseExpression(expression).get;\r\n\t      var scope = this._scope || this.vm;\r\n\t      var handler = function handler(e) {\r\n\t        scope.$event = e;\r\n\t        fn.call(scope, scope);\r\n\t        scope.$event = null;\r\n\t      };\r\n\t      if (this.filters) {\r\n\t        handler = scope._applyFilters(handler, null, this.filters);\r\n\t      }\r\n\t      this.update(handler);\r\n\t      return true;\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Set the corresponding value with the setter.\r\n\t   * This should only be used in two-way directives\r\n\t   * e.g. v-model.\r\n\t   *\r\n\t   * @param {*} value\r\n\t   * @public\r\n\t   */\r\n\t\r\n\t  Directive.prototype.set = function (value) {\r\n\t    /* istanbul ignore else */\r\n\t    if (this.twoWay) {\r\n\t      this._withLock(function () {\r\n\t        this._watcher.set(value);\r\n\t      });\r\n\t    } else if (true) {\r\n\t      warn('Directive.set() can only be used inside twoWay' + 'directives.');\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Execute a function while preventing that function from\r\n\t   * triggering updates on this directive instance.\r\n\t   *\r\n\t   * @param {Function} fn\r\n\t   */\r\n\t\r\n\t  Directive.prototype._withLock = function (fn) {\r\n\t    var self = this;\r\n\t    self._locked = true;\r\n\t    fn.call(self);\r\n\t    nextTick(function () {\r\n\t      self._locked = false;\r\n\t    });\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Convenience method that attaches a DOM event listener\r\n\t   * to the directive element and autometically tears it down\r\n\t   * during unbind.\r\n\t   *\r\n\t   * @param {String} event\r\n\t   * @param {Function} handler\r\n\t   * @param {Boolean} [useCapture]\r\n\t   */\r\n\t\r\n\t  Directive.prototype.on = function (event, handler, useCapture) {\r\n\t    on(this.el, event, handler, useCapture);(this._listeners || (this._listeners = [])).push([event, handler]);\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Teardown the watcher and call unbind.\r\n\t   */\r\n\t\r\n\t  Directive.prototype._teardown = function () {\r\n\t    if (this._bound) {\r\n\t      this._bound = false;\r\n\t      if (this.unbind) {\r\n\t        this.unbind();\r\n\t      }\r\n\t      if (this._watcher) {\r\n\t        this._watcher.teardown();\r\n\t      }\r\n\t      var listeners = this._listeners;\r\n\t      var i;\r\n\t      if (listeners) {\r\n\t        i = listeners.length;\r\n\t        while (i--) {\r\n\t          off(this.el, listeners[i][0], listeners[i][1]);\r\n\t        }\r\n\t      }\r\n\t      var unwatchFns = this._paramUnwatchFns;\r\n\t      if (unwatchFns) {\r\n\t        i = unwatchFns.length;\r\n\t        while (i--) {\r\n\t          unwatchFns[i]();\r\n\t        }\r\n\t      }\r\n\t      if ('development' !== 'production' && this.el) {\r\n\t        this.el._vue_directives.$remove(this);\r\n\t      }\r\n\t      this.vm = this.el = this._watcher = this._listeners = null;\r\n\t    }\r\n\t  };\r\n\t\r\n\t  function lifecycleMixin (Vue) {\r\n\t    /**\r\n\t     * Update v-ref for component.\r\n\t     *\r\n\t     * @param {Boolean} remove\r\n\t     */\r\n\t\r\n\t    Vue.prototype._updateRef = function (remove) {\r\n\t      var ref = this.$options._ref;\r\n\t      if (ref) {\r\n\t        var refs = (this._scope || this._context).$refs;\r\n\t        if (remove) {\r\n\t          if (refs[ref] === this) {\r\n\t            refs[ref] = null;\r\n\t          }\r\n\t        } else {\r\n\t          refs[ref] = this;\r\n\t        }\r\n\t      }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Transclude, compile and link element.\r\n\t     *\r\n\t     * If a pre-compiled linker is available, that means the\r\n\t     * passed in element will be pre-transcluded and compiled\r\n\t     * as well - all we need to do is to call the linker.\r\n\t     *\r\n\t     * Otherwise we need to call transclude/compile/link here.\r\n\t     *\r\n\t     * @param {Element} el\r\n\t     */\r\n\t\r\n\t    Vue.prototype._compile = function (el) {\r\n\t      var options = this.$options;\r\n\t\r\n\t      // transclude and init element\r\n\t      // transclude can potentially replace original\r\n\t      // so we need to keep reference; this step also injects\r\n\t      // the template and caches the original attributes\r\n\t      // on the container node and replacer node.\r\n\t      var original = el;\r\n\t      el = transclude(el, options);\r\n\t      this._initElement(el);\r\n\t\r\n\t      // handle v-pre on root node (#2026)\r\n\t      if (el.nodeType === 1 && getAttr(el, 'v-pre') !== null) {\r\n\t        return;\r\n\t      }\r\n\t\r\n\t      // root is always compiled per-instance, because\r\n\t      // container attrs and props can be different every time.\r\n\t      var contextOptions = this._context && this._context.$options;\r\n\t      var rootLinker = compileRoot(el, options, contextOptions);\r\n\t\r\n\t      // resolve slot distribution\r\n\t      resolveSlots(this, options._content);\r\n\t\r\n\t      // compile and link the rest\r\n\t      var contentLinkFn;\r\n\t      var ctor = this.constructor;\r\n\t      // component compilation can be cached\r\n\t      // as long as it's not using inline-template\r\n\t      if (options._linkerCachable) {\r\n\t        contentLinkFn = ctor.linker;\r\n\t        if (!contentLinkFn) {\r\n\t          contentLinkFn = ctor.linker = compile(el, options);\r\n\t        }\r\n\t      }\r\n\t\r\n\t      // link phase\r\n\t      // make sure to link root with prop scope!\r\n\t      var rootUnlinkFn = rootLinker(this, el, this._scope);\r\n\t      var contentUnlinkFn = contentLinkFn ? contentLinkFn(this, el) : compile(el, options)(this, el);\r\n\t\r\n\t      // register composite unlink function\r\n\t      // to be called during instance destruction\r\n\t      this._unlinkFn = function () {\r\n\t        rootUnlinkFn();\r\n\t        // passing destroying: true to avoid searching and\r\n\t        // splicing the directives\r\n\t        contentUnlinkFn(true);\r\n\t      };\r\n\t\r\n\t      // finally replace original\r\n\t      if (options.replace) {\r\n\t        replace(original, el);\r\n\t      }\r\n\t\r\n\t      this._isCompiled = true;\r\n\t      this._callHook('compiled');\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Initialize instance element. Called in the public\r\n\t     * $mount() method.\r\n\t     *\r\n\t     * @param {Element} el\r\n\t     */\r\n\t\r\n\t    Vue.prototype._initElement = function (el) {\r\n\t      if (isFragment(el)) {\r\n\t        this._isFragment = true;\r\n\t        this.$el = this._fragmentStart = el.firstChild;\r\n\t        this._fragmentEnd = el.lastChild;\r\n\t        // set persisted text anchors to empty\r\n\t        if (this._fragmentStart.nodeType === 3) {\r\n\t          this._fragmentStart.data = this._fragmentEnd.data = '';\r\n\t        }\r\n\t        this._fragment = el;\r\n\t      } else {\r\n\t        this.$el = el;\r\n\t      }\r\n\t      this.$el.__vue__ = this;\r\n\t      this._callHook('beforeCompile');\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Create and bind a directive to an element.\r\n\t     *\r\n\t     * @param {Object} descriptor - parsed directive descriptor\r\n\t     * @param {Node} node   - target node\r\n\t     * @param {Vue} [host] - transclusion host component\r\n\t     * @param {Object} [scope] - v-for scope\r\n\t     * @param {Fragment} [frag] - owner fragment\r\n\t     */\r\n\t\r\n\t    Vue.prototype._bindDir = function (descriptor, node, host, scope, frag) {\r\n\t      this._directives.push(new Directive(descriptor, this, node, host, scope, frag));\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Teardown an instance, unobserves the data, unbind all the\r\n\t     * directives, turn off all the event listeners, etc.\r\n\t     *\r\n\t     * @param {Boolean} remove - whether to remove the DOM node.\r\n\t     * @param {Boolean} deferCleanup - if true, defer cleanup to\r\n\t     *                                 be called later\r\n\t     */\r\n\t\r\n\t    Vue.prototype._destroy = function (remove, deferCleanup) {\r\n\t      if (this._isBeingDestroyed) {\r\n\t        if (!deferCleanup) {\r\n\t          this._cleanup();\r\n\t        }\r\n\t        return;\r\n\t      }\r\n\t\r\n\t      var destroyReady;\r\n\t      var pendingRemoval;\r\n\t\r\n\t      var self = this;\r\n\t      // Cleanup should be called either synchronously or asynchronoysly as\r\n\t      // callback of this.$remove(), or if remove and deferCleanup are false.\r\n\t      // In any case it should be called after all other removing, unbinding and\r\n\t      // turning of is done\r\n\t      var cleanupIfPossible = function cleanupIfPossible() {\r\n\t        if (destroyReady && !pendingRemoval && !deferCleanup) {\r\n\t          self._cleanup();\r\n\t        }\r\n\t      };\r\n\t\r\n\t      // remove DOM element\r\n\t      if (remove && this.$el) {\r\n\t        pendingRemoval = true;\r\n\t        this.$remove(function () {\r\n\t          pendingRemoval = false;\r\n\t          cleanupIfPossible();\r\n\t        });\r\n\t      }\r\n\t\r\n\t      this._callHook('beforeDestroy');\r\n\t      this._isBeingDestroyed = true;\r\n\t      var i;\r\n\t      // remove self from parent. only necessary\r\n\t      // if parent is not being destroyed as well.\r\n\t      var parent = this.$parent;\r\n\t      if (parent && !parent._isBeingDestroyed) {\r\n\t        parent.$children.$remove(this);\r\n\t        // unregister ref (remove: true)\r\n\t        this._updateRef(true);\r\n\t      }\r\n\t      // destroy all children.\r\n\t      i = this.$children.length;\r\n\t      while (i--) {\r\n\t        this.$children[i].$destroy();\r\n\t      }\r\n\t      // teardown props\r\n\t      if (this._propsUnlinkFn) {\r\n\t        this._propsUnlinkFn();\r\n\t      }\r\n\t      // teardown all directives. this also tearsdown all\r\n\t      // directive-owned watchers.\r\n\t      if (this._unlinkFn) {\r\n\t        this._unlinkFn();\r\n\t      }\r\n\t      i = this._watchers.length;\r\n\t      while (i--) {\r\n\t        this._watchers[i].teardown();\r\n\t      }\r\n\t      // remove reference to self on $el\r\n\t      if (this.$el) {\r\n\t        this.$el.__vue__ = null;\r\n\t      }\r\n\t\r\n\t      destroyReady = true;\r\n\t      cleanupIfPossible();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Clean up to ensure garbage collection.\r\n\t     * This is called after the leave transition if there\r\n\t     * is any.\r\n\t     */\r\n\t\r\n\t    Vue.prototype._cleanup = function () {\r\n\t      if (this._isDestroyed) {\r\n\t        return;\r\n\t      }\r\n\t      // remove self from owner fragment\r\n\t      // do it in cleanup so that we can call $destroy with\r\n\t      // defer right when a fragment is about to be removed.\r\n\t      if (this._frag) {\r\n\t        this._frag.children.$remove(this);\r\n\t      }\r\n\t      // remove reference from data ob\r\n\t      // frozen object may not have observer.\r\n\t      if (this._data && this._data.__ob__) {\r\n\t        this._data.__ob__.removeVm(this);\r\n\t      }\r\n\t      // Clean up references to private properties and other\r\n\t      // instances. preserve reference to _data so that proxy\r\n\t      // accessors still work. The only potential side effect\r\n\t      // here is that mutating the instance after it's destroyed\r\n\t      // may affect the state of other components that are still\r\n\t      // observing the same object, but that seems to be a\r\n\t      // reasonable responsibility for the user rather than\r\n\t      // always throwing an error on them.\r\n\t      this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null;\r\n\t      // call the last hook...\r\n\t      this._isDestroyed = true;\r\n\t      this._callHook('destroyed');\r\n\t      // turn off all instance listeners.\r\n\t      this.$off();\r\n\t    };\r\n\t  }\r\n\t\r\n\t  function miscMixin (Vue) {\r\n\t    /**\r\n\t     * Apply a list of filter (descriptors) to a value.\r\n\t     * Using plain for loops here because this will be called in\r\n\t     * the getter of any watcher with filters so it is very\r\n\t     * performance sensitive.\r\n\t     *\r\n\t     * @param {*} value\r\n\t     * @param {*} [oldValue]\r\n\t     * @param {Array} filters\r\n\t     * @param {Boolean} write\r\n\t     * @return {*}\r\n\t     */\r\n\t\r\n\t    Vue.prototype._applyFilters = function (value, oldValue, filters, write) {\r\n\t      var filter, fn, args, arg, offset, i, l, j, k;\r\n\t      for (i = 0, l = filters.length; i < l; i++) {\r\n\t        filter = filters[write ? l - i - 1 : i];\r\n\t        fn = resolveAsset(this.$options, 'filters', filter.name, true);\r\n\t        if (!fn) continue;\r\n\t        fn = write ? fn.write : fn.read || fn;\r\n\t        if (typeof fn !== 'function') continue;\r\n\t        args = write ? [value, oldValue] : [value];\r\n\t        offset = write ? 2 : 1;\r\n\t        if (filter.args) {\r\n\t          for (j = 0, k = filter.args.length; j < k; j++) {\r\n\t            arg = filter.args[j];\r\n\t            args[j + offset] = arg.dynamic ? this.$get(arg.value) : arg.value;\r\n\t          }\r\n\t        }\r\n\t        value = fn.apply(this, args);\r\n\t      }\r\n\t      return value;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Resolve a component, depending on whether the component\r\n\t     * is defined normally or using an async factory function.\r\n\t     * Resolves synchronously if already resolved, otherwise\r\n\t     * resolves asynchronously and caches the resolved\r\n\t     * constructor on the factory.\r\n\t     *\r\n\t     * @param {String|Function} value\r\n\t     * @param {Function} cb\r\n\t     */\r\n\t\r\n\t    Vue.prototype._resolveComponent = function (value, cb) {\r\n\t      var factory;\r\n\t      if (typeof value === 'function') {\r\n\t        factory = value;\r\n\t      } else {\r\n\t        factory = resolveAsset(this.$options, 'components', value, true);\r\n\t      }\r\n\t      /* istanbul ignore if */\r\n\t      if (!factory) {\r\n\t        return;\r\n\t      }\r\n\t      // async component factory\r\n\t      if (!factory.options) {\r\n\t        if (factory.resolved) {\r\n\t          // cached\r\n\t          cb(factory.resolved);\r\n\t        } else if (factory.requested) {\r\n\t          // pool callbacks\r\n\t          factory.pendingCallbacks.push(cb);\r\n\t        } else {\r\n\t          factory.requested = true;\r\n\t          var cbs = factory.pendingCallbacks = [cb];\r\n\t          factory.call(this, function resolve(res) {\r\n\t            if (isPlainObject(res)) {\r\n\t              res = Vue.extend(res);\r\n\t            }\r\n\t            // cache resolved\r\n\t            factory.resolved = res;\r\n\t            // invoke callbacks\r\n\t            for (var i = 0, l = cbs.length; i < l; i++) {\r\n\t              cbs[i](res);\r\n\t            }\r\n\t          }, function reject(reason) {\r\n\t            'development' !== 'production' && warn('Failed to resolve async component' + (typeof value === 'string' ? ': ' + value : '') + '. ' + (reason ? '\\nReason: ' + reason : ''));\r\n\t          });\r\n\t        }\r\n\t      } else {\r\n\t        // normal component\r\n\t        cb(factory);\r\n\t      }\r\n\t    };\r\n\t  }\r\n\t\r\n\t  var filterRE$1 = /[^|]\\|[^|]/;\r\n\t\r\n\t  function dataAPI (Vue) {\r\n\t    /**\r\n\t     * Get the value from an expression on this vm.\r\n\t     *\r\n\t     * @param {String} exp\r\n\t     * @param {Boolean} [asStatement]\r\n\t     * @return {*}\r\n\t     */\r\n\t\r\n\t    Vue.prototype.$get = function (exp, asStatement) {\r\n\t      var res = parseExpression(exp);\r\n\t      if (res) {\r\n\t        if (asStatement) {\r\n\t          var self = this;\r\n\t          return function statementHandler() {\r\n\t            self.$arguments = toArray(arguments);\r\n\t            var result = res.get.call(self, self);\r\n\t            self.$arguments = null;\r\n\t            return result;\r\n\t          };\r\n\t        } else {\r\n\t          try {\r\n\t            return res.get.call(this, this);\r\n\t          } catch (e) {}\r\n\t        }\r\n\t      }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Set the value from an expression on this vm.\r\n\t     * The expression must be a valid left-hand\r\n\t     * expression in an assignment.\r\n\t     *\r\n\t     * @param {String} exp\r\n\t     * @param {*} val\r\n\t     */\r\n\t\r\n\t    Vue.prototype.$set = function (exp, val) {\r\n\t      var res = parseExpression(exp, true);\r\n\t      if (res && res.set) {\r\n\t        res.set.call(this, this, val);\r\n\t      }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Delete a property on the VM\r\n\t     *\r\n\t     * @param {String} key\r\n\t     */\r\n\t\r\n\t    Vue.prototype.$delete = function (key) {\r\n\t      del(this._data, key);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Watch an expression, trigger callback when its\r\n\t     * value changes.\r\n\t     *\r\n\t     * @param {String|Function} expOrFn\r\n\t     * @param {Function} cb\r\n\t     * @param {Object} [options]\r\n\t     *                 - {Boolean} deep\r\n\t     *                 - {Boolean} immediate\r\n\t     * @return {Function} - unwatchFn\r\n\t     */\r\n\t\r\n\t    Vue.prototype.$watch = function (expOrFn, cb, options) {\r\n\t      var vm = this;\r\n\t      var parsed;\r\n\t      if (typeof expOrFn === 'string') {\r\n\t        parsed = parseDirective(expOrFn);\r\n\t        expOrFn = parsed.expression;\r\n\t      }\r\n\t      var watcher = new Watcher(vm, expOrFn, cb, {\r\n\t        deep: options && options.deep,\r\n\t        sync: options && options.sync,\r\n\t        filters: parsed && parsed.filters,\r\n\t        user: !options || options.user !== false\r\n\t      });\r\n\t      if (options && options.immediate) {\r\n\t        cb.call(vm, watcher.value);\r\n\t      }\r\n\t      return function unwatchFn() {\r\n\t        watcher.teardown();\r\n\t      };\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Evaluate a text directive, including filters.\r\n\t     *\r\n\t     * @param {String} text\r\n\t     * @param {Boolean} [asStatement]\r\n\t     * @return {String}\r\n\t     */\r\n\t\r\n\t    Vue.prototype.$eval = function (text, asStatement) {\r\n\t      // check for filters.\r\n\t      if (filterRE$1.test(text)) {\r\n\t        var dir = parseDirective(text);\r\n\t        // the filter regex check might give false positive\r\n\t        // for pipes inside strings, so it's possible that\r\n\t        // we don't get any filters here\r\n\t        var val = this.$get(dir.expression, asStatement);\r\n\t        return dir.filters ? this._applyFilters(val, null, dir.filters) : val;\r\n\t      } else {\r\n\t        // no filter\r\n\t        return this.$get(text, asStatement);\r\n\t      }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Interpolate a piece of template text.\r\n\t     *\r\n\t     * @param {String} text\r\n\t     * @return {String}\r\n\t     */\r\n\t\r\n\t    Vue.prototype.$interpolate = function (text) {\r\n\t      var tokens = parseText(text);\r\n\t      var vm = this;\r\n\t      if (tokens) {\r\n\t        if (tokens.length === 1) {\r\n\t          return vm.$eval(tokens[0].value) + '';\r\n\t        } else {\r\n\t          return tokens.map(function (token) {\r\n\t            return token.tag ? vm.$eval(token.value) : token.value;\r\n\t          }).join('');\r\n\t        }\r\n\t      } else {\r\n\t        return text;\r\n\t      }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Log instance data as a plain JS object\r\n\t     * so that it is easier to inspect in console.\r\n\t     * This method assumes console is available.\r\n\t     *\r\n\t     * @param {String} [path]\r\n\t     */\r\n\t\r\n\t    Vue.prototype.$log = function (path) {\r\n\t      var data = path ? getPath(this._data, path) : this._data;\r\n\t      if (data) {\r\n\t        data = clean(data);\r\n\t      }\r\n\t      // include computed fields\r\n\t      if (!path) {\r\n\t        var key;\r\n\t        for (key in this.$options.computed) {\r\n\t          data[key] = clean(this[key]);\r\n\t        }\r\n\t        if (this._props) {\r\n\t          for (key in this._props) {\r\n\t            data[key] = clean(this[key]);\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t      console.log(data);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * \"clean\" a getter/setter converted object into a plain\r\n\t     * object copy.\r\n\t     *\r\n\t     * @param {Object} - obj\r\n\t     * @return {Object}\r\n\t     */\r\n\t\r\n\t    function clean(obj) {\r\n\t      return JSON.parse(JSON.stringify(obj));\r\n\t    }\r\n\t  }\r\n\t\r\n\t  function domAPI (Vue) {\r\n\t    /**\r\n\t     * Convenience on-instance nextTick. The callback is\r\n\t     * auto-bound to the instance, and this avoids component\r\n\t     * modules having to rely on the global Vue.\r\n\t     *\r\n\t     * @param {Function} fn\r\n\t     */\r\n\t\r\n\t    Vue.prototype.$nextTick = function (fn) {\r\n\t      nextTick(fn, this);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Append instance to target\r\n\t     *\r\n\t     * @param {Node} target\r\n\t     * @param {Function} [cb]\r\n\t     * @param {Boolean} [withTransition] - defaults to true\r\n\t     */\r\n\t\r\n\t    Vue.prototype.$appendTo = function (target, cb, withTransition) {\r\n\t      return insert(this, target, cb, withTransition, append, appendWithTransition);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Prepend instance to target\r\n\t     *\r\n\t     * @param {Node} target\r\n\t     * @param {Function} [cb]\r\n\t     * @param {Boolean} [withTransition] - defaults to true\r\n\t     */\r\n\t\r\n\t    Vue.prototype.$prependTo = function (target, cb, withTransition) {\r\n\t      target = query(target);\r\n\t      if (target.hasChildNodes()) {\r\n\t        this.$before(target.firstChild, cb, withTransition);\r\n\t      } else {\r\n\t        this.$appendTo(target, cb, withTransition);\r\n\t      }\r\n\t      return this;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Insert instance before target\r\n\t     *\r\n\t     * @param {Node} target\r\n\t     * @param {Function} [cb]\r\n\t     * @param {Boolean} [withTransition] - defaults to true\r\n\t     */\r\n\t\r\n\t    Vue.prototype.$before = function (target, cb, withTransition) {\r\n\t      return insert(this, target, cb, withTransition, beforeWithCb, beforeWithTransition);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Insert instance after target\r\n\t     *\r\n\t     * @param {Node} target\r\n\t     * @param {Function} [cb]\r\n\t     * @param {Boolean} [withTransition] - defaults to true\r\n\t     */\r\n\t\r\n\t    Vue.prototype.$after = function (target, cb, withTransition) {\r\n\t      target = query(target);\r\n\t      if (target.nextSibling) {\r\n\t        this.$before(target.nextSibling, cb, withTransition);\r\n\t      } else {\r\n\t        this.$appendTo(target.parentNode, cb, withTransition);\r\n\t      }\r\n\t      return this;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Remove instance from DOM\r\n\t     *\r\n\t     * @param {Function} [cb]\r\n\t     * @param {Boolean} [withTransition] - defaults to true\r\n\t     */\r\n\t\r\n\t    Vue.prototype.$remove = function (cb, withTransition) {\r\n\t      if (!this.$el.parentNode) {\r\n\t        return cb && cb();\r\n\t      }\r\n\t      var inDocument = this._isAttached && inDoc(this.$el);\r\n\t      // if we are not in document, no need to check\r\n\t      // for transitions\r\n\t      if (!inDocument) withTransition = false;\r\n\t      var self = this;\r\n\t      var realCb = function realCb() {\r\n\t        if (inDocument) self._callHook('detached');\r\n\t        if (cb) cb();\r\n\t      };\r\n\t      if (this._isFragment) {\r\n\t        removeNodeRange(this._fragmentStart, this._fragmentEnd, this, this._fragment, realCb);\r\n\t      } else {\r\n\t        var op = withTransition === false ? removeWithCb : removeWithTransition;\r\n\t        op(this.$el, this, realCb);\r\n\t      }\r\n\t      return this;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Shared DOM insertion function.\r\n\t     *\r\n\t     * @param {Vue} vm\r\n\t     * @param {Element} target\r\n\t     * @param {Function} [cb]\r\n\t     * @param {Boolean} [withTransition]\r\n\t     * @param {Function} op1 - op for non-transition insert\r\n\t     * @param {Function} op2 - op for transition insert\r\n\t     * @return vm\r\n\t     */\r\n\t\r\n\t    function insert(vm, target, cb, withTransition, op1, op2) {\r\n\t      target = query(target);\r\n\t      var targetIsDetached = !inDoc(target);\r\n\t      var op = withTransition === false || targetIsDetached ? op1 : op2;\r\n\t      var shouldCallHook = !targetIsDetached && !vm._isAttached && !inDoc(vm.$el);\r\n\t      if (vm._isFragment) {\r\n\t        mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {\r\n\t          op(node, target, vm);\r\n\t        });\r\n\t        cb && cb();\r\n\t      } else {\r\n\t        op(vm.$el, target, vm, cb);\r\n\t      }\r\n\t      if (shouldCallHook) {\r\n\t        vm._callHook('attached');\r\n\t      }\r\n\t      return vm;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * Check for selectors\r\n\t     *\r\n\t     * @param {String|Element} el\r\n\t     */\r\n\t\r\n\t    function query(el) {\r\n\t      return typeof el === 'string' ? document.querySelector(el) : el;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * Append operation that takes a callback.\r\n\t     *\r\n\t     * @param {Node} el\r\n\t     * @param {Node} target\r\n\t     * @param {Vue} vm - unused\r\n\t     * @param {Function} [cb]\r\n\t     */\r\n\t\r\n\t    function append(el, target, vm, cb) {\r\n\t      target.appendChild(el);\r\n\t      if (cb) cb();\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * InsertBefore operation that takes a callback.\r\n\t     *\r\n\t     * @param {Node} el\r\n\t     * @param {Node} target\r\n\t     * @param {Vue} vm - unused\r\n\t     * @param {Function} [cb]\r\n\t     */\r\n\t\r\n\t    function beforeWithCb(el, target, vm, cb) {\r\n\t      before(el, target);\r\n\t      if (cb) cb();\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * Remove operation that takes a callback.\r\n\t     *\r\n\t     * @param {Node} el\r\n\t     * @param {Vue} vm - unused\r\n\t     * @param {Function} [cb]\r\n\t     */\r\n\t\r\n\t    function removeWithCb(el, vm, cb) {\r\n\t      remove(el);\r\n\t      if (cb) cb();\r\n\t    }\r\n\t  }\r\n\t\r\n\t  function eventsAPI (Vue) {\r\n\t    /**\r\n\t     * Listen on the given `event` with `fn`.\r\n\t     *\r\n\t     * @param {String} event\r\n\t     * @param {Function} fn\r\n\t     */\r\n\t\r\n\t    Vue.prototype.$on = function (event, fn) {\r\n\t      (this._events[event] || (this._events[event] = [])).push(fn);\r\n\t      modifyListenerCount(this, event, 1);\r\n\t      return this;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Adds an `event` listener that will be invoked a single\r\n\t     * time then automatically removed.\r\n\t     *\r\n\t     * @param {String} event\r\n\t     * @param {Function} fn\r\n\t     */\r\n\t\r\n\t    Vue.prototype.$once = function (event, fn) {\r\n\t      var self = this;\r\n\t      function on() {\r\n\t        self.$off(event, on);\r\n\t        fn.apply(this, arguments);\r\n\t      }\r\n\t      on.fn = fn;\r\n\t      this.$on(event, on);\r\n\t      return this;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Remove the given callback for `event` or all\r\n\t     * registered callbacks.\r\n\t     *\r\n\t     * @param {String} event\r\n\t     * @param {Function} fn\r\n\t     */\r\n\t\r\n\t    Vue.prototype.$off = function (event, fn) {\r\n\t      var cbs;\r\n\t      // all\r\n\t      if (!arguments.length) {\r\n\t        if (this.$parent) {\r\n\t          for (event in this._events) {\r\n\t            cbs = this._events[event];\r\n\t            if (cbs) {\r\n\t              modifyListenerCount(this, event, -cbs.length);\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t        this._events = {};\r\n\t        return this;\r\n\t      }\r\n\t      // specific event\r\n\t      cbs = this._events[event];\r\n\t      if (!cbs) {\r\n\t        return this;\r\n\t      }\r\n\t      if (arguments.length === 1) {\r\n\t        modifyListenerCount(this, event, -cbs.length);\r\n\t        this._events[event] = null;\r\n\t        return this;\r\n\t      }\r\n\t      // specific handler\r\n\t      var cb;\r\n\t      var i = cbs.length;\r\n\t      while (i--) {\r\n\t        cb = cbs[i];\r\n\t        if (cb === fn || cb.fn === fn) {\r\n\t          modifyListenerCount(this, event, -1);\r\n\t          cbs.splice(i, 1);\r\n\t          break;\r\n\t        }\r\n\t      }\r\n\t      return this;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Trigger an event on self.\r\n\t     *\r\n\t     * @param {String|Object} event\r\n\t     * @return {Boolean} shouldPropagate\r\n\t     */\r\n\t\r\n\t    Vue.prototype.$emit = function (event) {\r\n\t      var isSource = typeof event === 'string';\r\n\t      event = isSource ? event : event.name;\r\n\t      var cbs = this._events[event];\r\n\t      var shouldPropagate = isSource || !cbs;\r\n\t      if (cbs) {\r\n\t        cbs = cbs.length > 1 ? toArray(cbs) : cbs;\r\n\t        // this is a somewhat hacky solution to the question raised\r\n\t        // in #2102: for an inline component listener like <comp @test=\"doThis\">,\r\n\t        // the propagation handling is somewhat broken. Therefore we\r\n\t        // need to treat these inline callbacks differently.\r\n\t        var hasParentCbs = isSource && cbs.some(function (cb) {\r\n\t          return cb._fromParent;\r\n\t        });\r\n\t        if (hasParentCbs) {\r\n\t          shouldPropagate = false;\r\n\t        }\r\n\t        var args = toArray(arguments, 1);\r\n\t        for (var i = 0, l = cbs.length; i < l; i++) {\r\n\t          var cb = cbs[i];\r\n\t          var res = cb.apply(this, args);\r\n\t          if (res === true && (!hasParentCbs || cb._fromParent)) {\r\n\t            shouldPropagate = true;\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t      return shouldPropagate;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Recursively broadcast an event to all children instances.\r\n\t     *\r\n\t     * @param {String|Object} event\r\n\t     * @param {...*} additional arguments\r\n\t     */\r\n\t\r\n\t    Vue.prototype.$broadcast = function (event) {\r\n\t      var isSource = typeof event === 'string';\r\n\t      event = isSource ? event : event.name;\r\n\t      // if no child has registered for this event,\r\n\t      // then there's no need to broadcast.\r\n\t      if (!this._eventsCount[event]) return;\r\n\t      var children = this.$children;\r\n\t      var args = toArray(arguments);\r\n\t      if (isSource) {\r\n\t        // use object event to indicate non-source emit\r\n\t        // on children\r\n\t        args[0] = { name: event, source: this };\r\n\t      }\r\n\t      for (var i = 0, l = children.length; i < l; i++) {\r\n\t        var child = children[i];\r\n\t        var shouldPropagate = child.$emit.apply(child, args);\r\n\t        if (shouldPropagate) {\r\n\t          child.$broadcast.apply(child, args);\r\n\t        }\r\n\t      }\r\n\t      return this;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Recursively propagate an event up the parent chain.\r\n\t     *\r\n\t     * @param {String} event\r\n\t     * @param {...*} additional arguments\r\n\t     */\r\n\t\r\n\t    Vue.prototype.$dispatch = function (event) {\r\n\t      var shouldPropagate = this.$emit.apply(this, arguments);\r\n\t      if (!shouldPropagate) return;\r\n\t      var parent = this.$parent;\r\n\t      var args = toArray(arguments);\r\n\t      // use object event to indicate non-source emit\r\n\t      // on parents\r\n\t      args[0] = { name: event, source: this };\r\n\t      while (parent) {\r\n\t        shouldPropagate = parent.$emit.apply(parent, args);\r\n\t        parent = shouldPropagate ? parent.$parent : null;\r\n\t      }\r\n\t      return this;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Modify the listener counts on all parents.\r\n\t     * This bookkeeping allows $broadcast to return early when\r\n\t     * no child has listened to a certain event.\r\n\t     *\r\n\t     * @param {Vue} vm\r\n\t     * @param {String} event\r\n\t     * @param {Number} count\r\n\t     */\r\n\t\r\n\t    var hookRE = /^hook:/;\r\n\t    function modifyListenerCount(vm, event, count) {\r\n\t      var parent = vm.$parent;\r\n\t      // hooks do not get broadcasted so no need\r\n\t      // to do bookkeeping for them\r\n\t      if (!parent || !count || hookRE.test(event)) return;\r\n\t      while (parent) {\r\n\t        parent._eventsCount[event] = (parent._eventsCount[event] || 0) + count;\r\n\t        parent = parent.$parent;\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t\r\n\t  function lifecycleAPI (Vue) {\r\n\t    /**\r\n\t     * Set instance target element and kick off the compilation\r\n\t     * process. The passed in `el` can be a selector string, an\r\n\t     * existing Element, or a DocumentFragment (for block\r\n\t     * instances).\r\n\t     *\r\n\t     * @param {Element|DocumentFragment|string} el\r\n\t     * @public\r\n\t     */\r\n\t\r\n\t    Vue.prototype.$mount = function (el) {\r\n\t      if (this._isCompiled) {\r\n\t        'development' !== 'production' && warn('$mount() should be called only once.', this);\r\n\t        return;\r\n\t      }\r\n\t      el = query(el);\r\n\t      if (!el) {\r\n\t        el = document.createElement('div');\r\n\t      }\r\n\t      this._compile(el);\r\n\t      this._initDOMHooks();\r\n\t      if (inDoc(this.$el)) {\r\n\t        this._callHook('attached');\r\n\t        ready.call(this);\r\n\t      } else {\r\n\t        this.$once('hook:attached', ready);\r\n\t      }\r\n\t      return this;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Mark an instance as ready.\r\n\t     */\r\n\t\r\n\t    function ready() {\r\n\t      this._isAttached = true;\r\n\t      this._isReady = true;\r\n\t      this._callHook('ready');\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * Teardown the instance, simply delegate to the internal\r\n\t     * _destroy.\r\n\t     *\r\n\t     * @param {Boolean} remove\r\n\t     * @param {Boolean} deferCleanup\r\n\t     */\r\n\t\r\n\t    Vue.prototype.$destroy = function (remove, deferCleanup) {\r\n\t      this._destroy(remove, deferCleanup);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Partially compile a piece of DOM and return a\r\n\t     * decompile function.\r\n\t     *\r\n\t     * @param {Element|DocumentFragment} el\r\n\t     * @param {Vue} [host]\r\n\t     * @param {Object} [scope]\r\n\t     * @param {Fragment} [frag]\r\n\t     * @return {Function}\r\n\t     */\r\n\t\r\n\t    Vue.prototype.$compile = function (el, host, scope, frag) {\r\n\t      return compile(el, this.$options, true)(this, el, host, scope, frag);\r\n\t    };\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * The exposed Vue constructor.\r\n\t   *\r\n\t   * API conventions:\r\n\t   * - public API methods/properties are prefixed with `$`\r\n\t   * - internal methods/properties are prefixed with `_`\r\n\t   * - non-prefixed properties are assumed to be proxied user\r\n\t   *   data.\r\n\t   *\r\n\t   * @constructor\r\n\t   * @param {Object} [options]\r\n\t   * @public\r\n\t   */\r\n\t\r\n\t  function Vue(options) {\r\n\t    this._init(options);\r\n\t  }\r\n\t\r\n\t  // install internals\r\n\t  initMixin(Vue);\r\n\t  stateMixin(Vue);\r\n\t  eventsMixin(Vue);\r\n\t  lifecycleMixin(Vue);\r\n\t  miscMixin(Vue);\r\n\t\r\n\t  // install instance APIs\r\n\t  dataAPI(Vue);\r\n\t  domAPI(Vue);\r\n\t  eventsAPI(Vue);\r\n\t  lifecycleAPI(Vue);\r\n\t\r\n\t  var slot = {\r\n\t\r\n\t    priority: SLOT,\r\n\t    params: ['name'],\r\n\t\r\n\t    bind: function bind() {\r\n\t      // this was resolved during component transclusion\r\n\t      var name = this.params.name || 'default';\r\n\t      var content = this.vm._slotContents && this.vm._slotContents[name];\r\n\t      if (!content || !content.hasChildNodes()) {\r\n\t        this.fallback();\r\n\t      } else {\r\n\t        this.compile(content.cloneNode(true), this.vm._context, this.vm);\r\n\t      }\r\n\t    },\r\n\t\r\n\t    compile: function compile(content, context, host) {\r\n\t      if (content && context) {\r\n\t        if (this.el.hasChildNodes() && content.childNodes.length === 1 && content.childNodes[0].nodeType === 1 && content.childNodes[0].hasAttribute('v-if')) {\r\n\t          // if the inserted slot has v-if\r\n\t          // inject fallback content as the v-else\r\n\t          var elseBlock = document.createElement('template');\r\n\t          elseBlock.setAttribute('v-else', '');\r\n\t          elseBlock.innerHTML = this.el.innerHTML;\r\n\t          // the else block should be compiled in child scope\r\n\t          elseBlock._context = this.vm;\r\n\t          content.appendChild(elseBlock);\r\n\t        }\r\n\t        var scope = host ? host._scope : this._scope;\r\n\t        this.unlink = context.$compile(content, host, scope, this._frag);\r\n\t      }\r\n\t      if (content) {\r\n\t        replace(this.el, content);\r\n\t      } else {\r\n\t        remove(this.el);\r\n\t      }\r\n\t    },\r\n\t\r\n\t    fallback: function fallback() {\r\n\t      this.compile(extractContent(this.el, true), this.vm);\r\n\t    },\r\n\t\r\n\t    unbind: function unbind() {\r\n\t      if (this.unlink) {\r\n\t        this.unlink();\r\n\t      }\r\n\t    }\r\n\t  };\r\n\t\r\n\t  var partial = {\r\n\t\r\n\t    priority: PARTIAL,\r\n\t\r\n\t    params: ['name'],\r\n\t\r\n\t    // watch changes to name for dynamic partials\r\n\t    paramWatchers: {\r\n\t      name: function name(value) {\r\n\t        vIf.remove.call(this);\r\n\t        if (value) {\r\n\t          this.insert(value);\r\n\t        }\r\n\t      }\r\n\t    },\r\n\t\r\n\t    bind: function bind() {\r\n\t      this.anchor = createAnchor('v-partial');\r\n\t      replace(this.el, this.anchor);\r\n\t      this.insert(this.params.name);\r\n\t    },\r\n\t\r\n\t    insert: function insert(id) {\r\n\t      var partial = resolveAsset(this.vm.$options, 'partials', id, true);\r\n\t      if (partial) {\r\n\t        this.factory = new FragmentFactory(this.vm, partial);\r\n\t        vIf.insert.call(this);\r\n\t      }\r\n\t    },\r\n\t\r\n\t    unbind: function unbind() {\r\n\t      if (this.frag) {\r\n\t        this.frag.destroy();\r\n\t      }\r\n\t    }\r\n\t  };\r\n\t\r\n\t  var elementDirectives = {\r\n\t    slot: slot,\r\n\t    partial: partial\r\n\t  };\r\n\t\r\n\t  var convertArray = vFor._postProcess;\r\n\t\r\n\t  /**\r\n\t   * Limit filter for arrays\r\n\t   *\r\n\t   * @param {Number} n\r\n\t   * @param {Number} offset (Decimal expected)\r\n\t   */\r\n\t\r\n\t  function limitBy(arr, n, offset) {\r\n\t    offset = offset ? parseInt(offset, 10) : 0;\r\n\t    n = toNumber(n);\r\n\t    return typeof n === 'number' ? arr.slice(offset, offset + n) : arr;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Filter filter for arrays\r\n\t   *\r\n\t   * @param {String} search\r\n\t   * @param {String} [delimiter]\r\n\t   * @param {String} ...dataKeys\r\n\t   */\r\n\t\r\n\t  function filterBy(arr, search, delimiter) {\r\n\t    arr = convertArray(arr);\r\n\t    if (search == null) {\r\n\t      return arr;\r\n\t    }\r\n\t    if (typeof search === 'function') {\r\n\t      return arr.filter(search);\r\n\t    }\r\n\t    // cast to lowercase string\r\n\t    search = ('' + search).toLowerCase();\r\n\t    // allow optional `in` delimiter\r\n\t    // because why not\r\n\t    var n = delimiter === 'in' ? 3 : 2;\r\n\t    // extract and flatten keys\r\n\t    var keys = Array.prototype.concat.apply([], toArray(arguments, n));\r\n\t    var res = [];\r\n\t    var item, key, val, j;\r\n\t    for (var i = 0, l = arr.length; i < l; i++) {\r\n\t      item = arr[i];\r\n\t      val = item && item.$value || item;\r\n\t      j = keys.length;\r\n\t      if (j) {\r\n\t        while (j--) {\r\n\t          key = keys[j];\r\n\t          if (key === '$key' && contains(item.$key, search) || contains(getPath(val, key), search)) {\r\n\t            res.push(item);\r\n\t            break;\r\n\t          }\r\n\t        }\r\n\t      } else if (contains(item, search)) {\r\n\t        res.push(item);\r\n\t      }\r\n\t    }\r\n\t    return res;\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * Filter filter for arrays\r\n\t   *\r\n\t   * @param {String|Array<String>|Function} ...sortKeys\r\n\t   * @param {Number} [order]\r\n\t   */\r\n\t\r\n\t  function orderBy(arr) {\r\n\t    var comparator = null;\r\n\t    var sortKeys = undefined;\r\n\t    arr = convertArray(arr);\r\n\t\r\n\t    // determine order (last argument)\r\n\t    var args = toArray(arguments, 1);\r\n\t    var order = args[args.length - 1];\r\n\t    if (typeof order === 'number') {\r\n\t      order = order < 0 ? -1 : 1;\r\n\t      args = args.length > 1 ? args.slice(0, -1) : args;\r\n\t    } else {\r\n\t      order = 1;\r\n\t    }\r\n\t\r\n\t    // determine sortKeys & comparator\r\n\t    var firstArg = args[0];\r\n\t    if (!firstArg) {\r\n\t      return arr;\r\n\t    } else if (typeof firstArg === 'function') {\r\n\t      // custom comparator\r\n\t      comparator = function (a, b) {\r\n\t        return firstArg(a, b) * order;\r\n\t      };\r\n\t    } else {\r\n\t      // string keys. flatten first\r\n\t      sortKeys = Array.prototype.concat.apply([], args);\r\n\t      comparator = function (a, b, i) {\r\n\t        i = i || 0;\r\n\t        return i >= sortKeys.length - 1 ? baseCompare(a, b, i) : baseCompare(a, b, i) || comparator(a, b, i + 1);\r\n\t      };\r\n\t    }\r\n\t\r\n\t    function baseCompare(a, b, sortKeyIndex) {\r\n\t      var sortKey = sortKeys[sortKeyIndex];\r\n\t      if (sortKey) {\r\n\t        if (sortKey !== '$key') {\r\n\t          if (isObject(a) && '$value' in a) a = a.$value;\r\n\t          if (isObject(b) && '$value' in b) b = b.$value;\r\n\t        }\r\n\t        a = isObject(a) ? getPath(a, sortKey) : a;\r\n\t        b = isObject(b) ? getPath(b, sortKey) : b;\r\n\t      }\r\n\t      return a === b ? 0 : a > b ? order : -order;\r\n\t    }\r\n\t\r\n\t    // sort on a copy to avoid mutating original array\r\n\t    return arr.slice().sort(comparator);\r\n\t  }\r\n\t\r\n\t  /**\r\n\t   * String contain helper\r\n\t   *\r\n\t   * @param {*} val\r\n\t   * @param {String} search\r\n\t   */\r\n\t\r\n\t  function contains(val, search) {\r\n\t    var i;\r\n\t    if (isPlainObject(val)) {\r\n\t      var keys = Object.keys(val);\r\n\t      i = keys.length;\r\n\t      while (i--) {\r\n\t        if (contains(val[keys[i]], search)) {\r\n\t          return true;\r\n\t        }\r\n\t      }\r\n\t    } else if (isArray(val)) {\r\n\t      i = val.length;\r\n\t      while (i--) {\r\n\t        if (contains(val[i], search)) {\r\n\t          return true;\r\n\t        }\r\n\t      }\r\n\t    } else if (val != null) {\r\n\t      return val.toString().toLowerCase().indexOf(search) > -1;\r\n\t    }\r\n\t  }\r\n\t\r\n\t  var digitsRE = /(\\d{3})(?=\\d)/g;\r\n\t\r\n\t  // asset collections must be a plain object.\r\n\t  var filters = {\r\n\t\r\n\t    orderBy: orderBy,\r\n\t    filterBy: filterBy,\r\n\t    limitBy: limitBy,\r\n\t\r\n\t    /**\r\n\t     * Stringify value.\r\n\t     *\r\n\t     * @param {Number} indent\r\n\t     */\r\n\t\r\n\t    json: {\r\n\t      read: function read(value, indent) {\r\n\t        return typeof value === 'string' ? value : JSON.stringify(value, null, arguments.length > 1 ? indent : 2);\r\n\t      },\r\n\t      write: function write(value) {\r\n\t        try {\r\n\t          return JSON.parse(value);\r\n\t        } catch (e) {\r\n\t          return value;\r\n\t        }\r\n\t      }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * 'abc' => 'Abc'\r\n\t     */\r\n\t\r\n\t    capitalize: function capitalize(value) {\r\n\t      if (!value && value !== 0) return '';\r\n\t      value = value.toString();\r\n\t      return value.charAt(0).toUpperCase() + value.slice(1);\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * 'abc' => 'ABC'\r\n\t     */\r\n\t\r\n\t    uppercase: function uppercase(value) {\r\n\t      return value || value === 0 ? value.toString().toUpperCase() : '';\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * 'AbC' => 'abc'\r\n\t     */\r\n\t\r\n\t    lowercase: function lowercase(value) {\r\n\t      return value || value === 0 ? value.toString().toLowerCase() : '';\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * 12345 => $12,345.00\r\n\t     *\r\n\t     * @param {String} sign\r\n\t     * @param {Number} decimals Decimal places\r\n\t     */\r\n\t\r\n\t    currency: function currency(value, _currency, decimals) {\r\n\t      value = parseFloat(value);\r\n\t      if (!isFinite(value) || !value && value !== 0) return '';\r\n\t      _currency = _currency != null ? _currency : '$';\r\n\t      decimals = decimals != null ? decimals : 2;\r\n\t      var stringified = Math.abs(value).toFixed(decimals);\r\n\t      var _int = decimals ? stringified.slice(0, -1 - decimals) : stringified;\r\n\t      var i = _int.length % 3;\r\n\t      var head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? ',' : '') : '';\r\n\t      var _float = decimals ? stringified.slice(-1 - decimals) : '';\r\n\t      var sign = value < 0 ? '-' : '';\r\n\t      return sign + _currency + head + _int.slice(i).replace(digitsRE, '$1,') + _float;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * 'item' => 'items'\r\n\t     *\r\n\t     * @params\r\n\t     *  an array of strings corresponding to\r\n\t     *  the single, double, triple ... forms of the word to\r\n\t     *  be pluralized. When the number to be pluralized\r\n\t     *  exceeds the length of the args, it will use the last\r\n\t     *  entry in the array.\r\n\t     *\r\n\t     *  e.g. ['single', 'double', 'triple', 'multiple']\r\n\t     */\r\n\t\r\n\t    pluralize: function pluralize(value) {\r\n\t      var args = toArray(arguments, 1);\r\n\t      var length = args.length;\r\n\t      if (length > 1) {\r\n\t        var index = value % 10 - 1;\r\n\t        return index in args ? args[index] : args[length - 1];\r\n\t      } else {\r\n\t        return args[0] + (value === 1 ? '' : 's');\r\n\t      }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Debounce a handler function.\r\n\t     *\r\n\t     * @param {Function} handler\r\n\t     * @param {Number} delay = 300\r\n\t     * @return {Function}\r\n\t     */\r\n\t\r\n\t    debounce: function debounce(handler, delay) {\r\n\t      if (!handler) return;\r\n\t      if (!delay) {\r\n\t        delay = 300;\r\n\t      }\r\n\t      return _debounce(handler, delay);\r\n\t    }\r\n\t  };\r\n\t\r\n\t  function installGlobalAPI (Vue) {\r\n\t    /**\r\n\t     * Vue and every constructor that extends Vue has an\r\n\t     * associated options object, which can be accessed during\r\n\t     * compilation steps as `this.constructor.options`.\r\n\t     *\r\n\t     * These can be seen as the default options of every\r\n\t     * Vue instance.\r\n\t     */\r\n\t\r\n\t    Vue.options = {\r\n\t      directives: directives,\r\n\t      elementDirectives: elementDirectives,\r\n\t      filters: filters,\r\n\t      transitions: {},\r\n\t      components: {},\r\n\t      partials: {},\r\n\t      replace: true\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Expose useful internals\r\n\t     */\r\n\t\r\n\t    Vue.util = util;\r\n\t    Vue.config = config;\r\n\t    Vue.set = set;\r\n\t    Vue['delete'] = del;\r\n\t    Vue.nextTick = nextTick;\r\n\t\r\n\t    /**\r\n\t     * The following are exposed for advanced usage / plugins\r\n\t     */\r\n\t\r\n\t    Vue.compiler = compiler;\r\n\t    Vue.FragmentFactory = FragmentFactory;\r\n\t    Vue.internalDirectives = internalDirectives;\r\n\t    Vue.parsers = {\r\n\t      path: path,\r\n\t      text: text,\r\n\t      template: template,\r\n\t      directive: directive,\r\n\t      expression: expression\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Each instance constructor, including Vue, has a unique\r\n\t     * cid. This enables us to create wrapped \"child\r\n\t     * constructors\" for prototypal inheritance and cache them.\r\n\t     */\r\n\t\r\n\t    Vue.cid = 0;\r\n\t    var cid = 1;\r\n\t\r\n\t    /**\r\n\t     * Class inheritance\r\n\t     *\r\n\t     * @param {Object} extendOptions\r\n\t     */\r\n\t\r\n\t    Vue.extend = function (extendOptions) {\r\n\t      extendOptions = extendOptions || {};\r\n\t      var Super = this;\r\n\t      var isFirstExtend = Super.cid === 0;\r\n\t      if (isFirstExtend && extendOptions._Ctor) {\r\n\t        return extendOptions._Ctor;\r\n\t      }\r\n\t      var name = extendOptions.name || Super.options.name;\r\n\t      if (true) {\r\n\t        if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\r\n\t          warn('Invalid component name: \"' + name + '\". Component names ' + 'can only contain alphanumeric characaters and the hyphen.');\r\n\t          name = null;\r\n\t        }\r\n\t      }\r\n\t      var Sub = createClass(name || 'VueComponent');\r\n\t      Sub.prototype = Object.create(Super.prototype);\r\n\t      Sub.prototype.constructor = Sub;\r\n\t      Sub.cid = cid++;\r\n\t      Sub.options = mergeOptions(Super.options, extendOptions);\r\n\t      Sub['super'] = Super;\r\n\t      // allow further extension\r\n\t      Sub.extend = Super.extend;\r\n\t      // create asset registers, so extended classes\r\n\t      // can have their private assets too.\r\n\t      config._assetTypes.forEach(function (type) {\r\n\t        Sub[type] = Super[type];\r\n\t      });\r\n\t      // enable recursive self-lookup\r\n\t      if (name) {\r\n\t        Sub.options.components[name] = Sub;\r\n\t      }\r\n\t      // cache constructor\r\n\t      if (isFirstExtend) {\r\n\t        extendOptions._Ctor = Sub;\r\n\t      }\r\n\t      return Sub;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * A function that returns a sub-class constructor with the\r\n\t     * given name. This gives us much nicer output when\r\n\t     * logging instances in the console.\r\n\t     *\r\n\t     * @param {String} name\r\n\t     * @return {Function}\r\n\t     */\r\n\t\r\n\t    function createClass(name) {\r\n\t      /* eslint-disable no-new-func */\r\n\t      return new Function('return function ' + classify(name) + ' (options) { this._init(options) }')();\r\n\t      /* eslint-enable no-new-func */\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * Plugin system\r\n\t     *\r\n\t     * @param {Object} plugin\r\n\t     */\r\n\t\r\n\t    Vue.use = function (plugin) {\r\n\t      /* istanbul ignore if */\r\n\t      if (plugin.installed) {\r\n\t        return;\r\n\t      }\r\n\t      // additional parameters\r\n\t      var args = toArray(arguments, 1);\r\n\t      args.unshift(this);\r\n\t      if (typeof plugin.install === 'function') {\r\n\t        plugin.install.apply(plugin, args);\r\n\t      } else {\r\n\t        plugin.apply(null, args);\r\n\t      }\r\n\t      plugin.installed = true;\r\n\t      return this;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Apply a global mixin by merging it into the default\r\n\t     * options.\r\n\t     */\r\n\t\r\n\t    Vue.mixin = function (mixin) {\r\n\t      Vue.options = mergeOptions(Vue.options, mixin);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Create asset registration methods with the following\r\n\t     * signature:\r\n\t     *\r\n\t     * @param {String} id\r\n\t     * @param {*} definition\r\n\t     */\r\n\t\r\n\t    config._assetTypes.forEach(function (type) {\r\n\t      Vue[type] = function (id, definition) {\r\n\t        if (!definition) {\r\n\t          return this.options[type + 's'][id];\r\n\t        } else {\r\n\t          /* istanbul ignore if */\r\n\t          if (true) {\r\n\t            if (type === 'component' && (commonTagRE.test(id) || reservedTagRE.test(id))) {\r\n\t              warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);\r\n\t            }\r\n\t          }\r\n\t          if (type === 'component' && isPlainObject(definition)) {\r\n\t            if (!definition.name) {\r\n\t              definition.name = id;\r\n\t            }\r\n\t            definition = Vue.extend(definition);\r\n\t          }\r\n\t          this.options[type + 's'][id] = definition;\r\n\t          return definition;\r\n\t        }\r\n\t      };\r\n\t    });\r\n\t\r\n\t    // expose internal transition API\r\n\t    extend(Vue.transition, transition);\r\n\t  }\r\n\t\r\n\t  installGlobalAPI(Vue);\r\n\t\r\n\t  Vue.version = '1.0.26';\r\n\t\r\n\t  // devtools global hook\r\n\t  /* istanbul ignore next */\r\n\t  setTimeout(function () {\r\n\t    if (config.devtools) {\r\n\t      if (devtools) {\r\n\t        devtools.emit('init', Vue);\r\n\t      } else if ('development' !== 'production' && inBrowser && /Chrome\\/\\d+/.test(window.navigator.userAgent)) {\r\n\t        console.log('Download the Vue Devtools for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\r\n\t      }\r\n\t    }\r\n\t  }, 0);\r\n\t\r\n\t  return Vue;\r\n\t\r\n\t}));\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n\n/***/ 12:\n/*!******************************************************!*\\\n  !*** ./lib/vue-resource/dist/vue-resource.common.js ***!\n  \\******************************************************/\n/***/ function(module, exports) {\n\n\t/*!\r\n\t * vue-resource v0.9.3\r\n\t * https://github.com/vuejs/vue-resource\r\n\t * Released under the MIT License.\r\n\t */\r\n\t\r\n\t'use strict';\r\n\t\r\n\t/**\r\n\t * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)\r\n\t */\r\n\t\r\n\tvar RESOLVED = 0;\r\n\tvar REJECTED = 1;\r\n\tvar PENDING = 2;\r\n\t\r\n\tfunction Promise$2(executor) {\r\n\t\r\n\t    this.state = PENDING;\r\n\t    this.value = undefined;\r\n\t    this.deferred = [];\r\n\t\r\n\t    var promise = this;\r\n\t\r\n\t    try {\r\n\t        executor(function (x) {\r\n\t            promise.resolve(x);\r\n\t        }, function (r) {\r\n\t            promise.reject(r);\r\n\t        });\r\n\t    } catch (e) {\r\n\t        promise.reject(e);\r\n\t    }\r\n\t}\r\n\t\r\n\tPromise$2.reject = function (r) {\r\n\t    return new Promise$2(function (resolve, reject) {\r\n\t        reject(r);\r\n\t    });\r\n\t};\r\n\t\r\n\tPromise$2.resolve = function (x) {\r\n\t    return new Promise$2(function (resolve, reject) {\r\n\t        resolve(x);\r\n\t    });\r\n\t};\r\n\t\r\n\tPromise$2.all = function all(iterable) {\r\n\t    return new Promise$2(function (resolve, reject) {\r\n\t        var count = 0,\r\n\t            result = [];\r\n\t\r\n\t        if (iterable.length === 0) {\r\n\t            resolve(result);\r\n\t        }\r\n\t\r\n\t        function resolver(i) {\r\n\t            return function (x) {\r\n\t                result[i] = x;\r\n\t                count += 1;\r\n\t\r\n\t                if (count === iterable.length) {\r\n\t                    resolve(result);\r\n\t                }\r\n\t            };\r\n\t        }\r\n\t\r\n\t        for (var i = 0; i < iterable.length; i += 1) {\r\n\t            Promise$2.resolve(iterable[i]).then(resolver(i), reject);\r\n\t        }\r\n\t    });\r\n\t};\r\n\t\r\n\tPromise$2.race = function race(iterable) {\r\n\t    return new Promise$2(function (resolve, reject) {\r\n\t        for (var i = 0; i < iterable.length; i += 1) {\r\n\t            Promise$2.resolve(iterable[i]).then(resolve, reject);\r\n\t        }\r\n\t    });\r\n\t};\r\n\t\r\n\tvar p$1 = Promise$2.prototype;\r\n\t\r\n\tp$1.resolve = function resolve(x) {\r\n\t    var promise = this;\r\n\t\r\n\t    if (promise.state === PENDING) {\r\n\t        if (x === promise) {\r\n\t            throw new TypeError('Promise settled with itself.');\r\n\t        }\r\n\t\r\n\t        var called = false;\r\n\t\r\n\t        try {\r\n\t            var then = x && x['then'];\r\n\t\r\n\t            if (x !== null && typeof x === 'object' && typeof then === 'function') {\r\n\t                then.call(x, function (x) {\r\n\t                    if (!called) {\r\n\t                        promise.resolve(x);\r\n\t                    }\r\n\t                    called = true;\r\n\t                }, function (r) {\r\n\t                    if (!called) {\r\n\t                        promise.reject(r);\r\n\t                    }\r\n\t                    called = true;\r\n\t                });\r\n\t                return;\r\n\t            }\r\n\t        } catch (e) {\r\n\t            if (!called) {\r\n\t                promise.reject(e);\r\n\t            }\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        promise.state = RESOLVED;\r\n\t        promise.value = x;\r\n\t        promise.notify();\r\n\t    }\r\n\t};\r\n\t\r\n\tp$1.reject = function reject(reason) {\r\n\t    var promise = this;\r\n\t\r\n\t    if (promise.state === PENDING) {\r\n\t        if (reason === promise) {\r\n\t            throw new TypeError('Promise settled with itself.');\r\n\t        }\r\n\t\r\n\t        promise.state = REJECTED;\r\n\t        promise.value = reason;\r\n\t        promise.notify();\r\n\t    }\r\n\t};\r\n\t\r\n\tp$1.notify = function notify() {\r\n\t    var promise = this;\r\n\t\r\n\t    nextTick(function () {\r\n\t        if (promise.state !== PENDING) {\r\n\t            while (promise.deferred.length) {\r\n\t                var deferred = promise.deferred.shift(),\r\n\t                    onResolved = deferred[0],\r\n\t                    onRejected = deferred[1],\r\n\t                    resolve = deferred[2],\r\n\t                    reject = deferred[3];\r\n\t\r\n\t                try {\r\n\t                    if (promise.state === RESOLVED) {\r\n\t                        if (typeof onResolved === 'function') {\r\n\t                            resolve(onResolved.call(undefined, promise.value));\r\n\t                        } else {\r\n\t                            resolve(promise.value);\r\n\t                        }\r\n\t                    } else if (promise.state === REJECTED) {\r\n\t                        if (typeof onRejected === 'function') {\r\n\t                            resolve(onRejected.call(undefined, promise.value));\r\n\t                        } else {\r\n\t                            reject(promise.value);\r\n\t                        }\r\n\t                    }\r\n\t                } catch (e) {\r\n\t                    reject(e);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    });\r\n\t};\r\n\t\r\n\tp$1.then = function then(onResolved, onRejected) {\r\n\t    var promise = this;\r\n\t\r\n\t    return new Promise$2(function (resolve, reject) {\r\n\t        promise.deferred.push([onResolved, onRejected, resolve, reject]);\r\n\t        promise.notify();\r\n\t    });\r\n\t};\r\n\t\r\n\tp$1.catch = function (onRejected) {\r\n\t    return this.then(undefined, onRejected);\r\n\t};\r\n\t\r\n\tvar PromiseObj = window.Promise || Promise$2;\r\n\t\r\n\tfunction Promise$1(executor, context) {\r\n\t\r\n\t    if (executor instanceof PromiseObj) {\r\n\t        this.promise = executor;\r\n\t    } else {\r\n\t        this.promise = new PromiseObj(executor.bind(context));\r\n\t    }\r\n\t\r\n\t    this.context = context;\r\n\t}\r\n\t\r\n\tPromise$1.all = function (iterable, context) {\r\n\t    return new Promise$1(PromiseObj.all(iterable), context);\r\n\t};\r\n\t\r\n\tPromise$1.resolve = function (value, context) {\r\n\t    return new Promise$1(PromiseObj.resolve(value), context);\r\n\t};\r\n\t\r\n\tPromise$1.reject = function (reason, context) {\r\n\t    return new Promise$1(PromiseObj.reject(reason), context);\r\n\t};\r\n\t\r\n\tPromise$1.race = function (iterable, context) {\r\n\t    return new Promise$1(PromiseObj.race(iterable), context);\r\n\t};\r\n\t\r\n\tvar p = Promise$1.prototype;\r\n\t\r\n\tp.bind = function (context) {\r\n\t    this.context = context;\r\n\t    return this;\r\n\t};\r\n\t\r\n\tp.then = function (fulfilled, rejected) {\r\n\t\r\n\t    if (fulfilled && fulfilled.bind && this.context) {\r\n\t        fulfilled = fulfilled.bind(this.context);\r\n\t    }\r\n\t\r\n\t    if (rejected && rejected.bind && this.context) {\r\n\t        rejected = rejected.bind(this.context);\r\n\t    }\r\n\t\r\n\t    return new Promise$1(this.promise.then(fulfilled, rejected), this.context);\r\n\t};\r\n\t\r\n\tp.catch = function (rejected) {\r\n\t\r\n\t    if (rejected && rejected.bind && this.context) {\r\n\t        rejected = rejected.bind(this.context);\r\n\t    }\r\n\t\r\n\t    return new Promise$1(this.promise.catch(rejected), this.context);\r\n\t};\r\n\t\r\n\tp.finally = function (callback) {\r\n\t\r\n\t    return this.then(function (value) {\r\n\t        callback.call(this);\r\n\t        return value;\r\n\t    }, function (reason) {\r\n\t        callback.call(this);\r\n\t        return PromiseObj.reject(reason);\r\n\t    });\r\n\t};\r\n\t\r\n\tvar debug = false;\r\n\tvar util = {};\r\n\tvar array = [];\r\n\tfunction Util (Vue) {\r\n\t    util = Vue.util;\r\n\t    debug = Vue.config.debug || !Vue.config.silent;\r\n\t}\r\n\t\r\n\tfunction warn(msg) {\r\n\t    if (typeof console !== 'undefined' && debug) {\r\n\t        console.warn('[VueResource warn]: ' + msg);\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction error(msg) {\r\n\t    if (typeof console !== 'undefined') {\r\n\t        console.error(msg);\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction nextTick(cb, ctx) {\r\n\t    return util.nextTick(cb, ctx);\r\n\t}\r\n\t\r\n\tfunction trim(str) {\r\n\t    return str.replace(/^\\s*|\\s*$/g, '');\r\n\t}\r\n\t\r\n\tvar isArray = Array.isArray;\r\n\t\r\n\tfunction isString(val) {\r\n\t    return typeof val === 'string';\r\n\t}\r\n\t\r\n\tfunction isBoolean(val) {\r\n\t    return val === true || val === false;\r\n\t}\r\n\t\r\n\tfunction isFunction(val) {\r\n\t    return typeof val === 'function';\r\n\t}\r\n\t\r\n\tfunction isObject(obj) {\r\n\t    return obj !== null && typeof obj === 'object';\r\n\t}\r\n\t\r\n\tfunction isPlainObject(obj) {\r\n\t    return isObject(obj) && Object.getPrototypeOf(obj) == Object.prototype;\r\n\t}\r\n\t\r\n\tfunction isFormData(obj) {\r\n\t    return typeof FormData !== 'undefined' && obj instanceof FormData;\r\n\t}\r\n\t\r\n\tfunction when(value, fulfilled, rejected) {\r\n\t\r\n\t    var promise = Promise$1.resolve(value);\r\n\t\r\n\t    if (arguments.length < 2) {\r\n\t        return promise;\r\n\t    }\r\n\t\r\n\t    return promise.then(fulfilled, rejected);\r\n\t}\r\n\t\r\n\tfunction options(fn, obj, opts) {\r\n\t\r\n\t    opts = opts || {};\r\n\t\r\n\t    if (isFunction(opts)) {\r\n\t        opts = opts.call(obj);\r\n\t    }\r\n\t\r\n\t    return merge(fn.bind({ $vm: obj, $options: opts }), fn, { $options: opts });\r\n\t}\r\n\t\r\n\tfunction each(obj, iterator) {\r\n\t\r\n\t    var i, key;\r\n\t\r\n\t    if (typeof obj.length == 'number') {\r\n\t        for (i = 0; i < obj.length; i++) {\r\n\t            iterator.call(obj[i], obj[i], i);\r\n\t        }\r\n\t    } else if (isObject(obj)) {\r\n\t        for (key in obj) {\r\n\t            if (obj.hasOwnProperty(key)) {\r\n\t                iterator.call(obj[key], obj[key], key);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    return obj;\r\n\t}\r\n\t\r\n\tvar assign = Object.assign || _assign;\r\n\t\r\n\tfunction merge(target) {\r\n\t\r\n\t    var args = array.slice.call(arguments, 1);\r\n\t\r\n\t    args.forEach(function (source) {\r\n\t        _merge(target, source, true);\r\n\t    });\r\n\t\r\n\t    return target;\r\n\t}\r\n\t\r\n\tfunction defaults(target) {\r\n\t\r\n\t    var args = array.slice.call(arguments, 1);\r\n\t\r\n\t    args.forEach(function (source) {\r\n\t\r\n\t        for (var key in source) {\r\n\t            if (target[key] === undefined) {\r\n\t                target[key] = source[key];\r\n\t            }\r\n\t        }\r\n\t    });\r\n\t\r\n\t    return target;\r\n\t}\r\n\t\r\n\tfunction _assign(target) {\r\n\t\r\n\t    var args = array.slice.call(arguments, 1);\r\n\t\r\n\t    args.forEach(function (source) {\r\n\t        _merge(target, source);\r\n\t    });\r\n\t\r\n\t    return target;\r\n\t}\r\n\t\r\n\tfunction _merge(target, source, deep) {\r\n\t    for (var key in source) {\r\n\t        if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\r\n\t            if (isPlainObject(source[key]) && !isPlainObject(target[key])) {\r\n\t                target[key] = {};\r\n\t            }\r\n\t            if (isArray(source[key]) && !isArray(target[key])) {\r\n\t                target[key] = [];\r\n\t            }\r\n\t            _merge(target[key], source[key], deep);\r\n\t        } else if (source[key] !== undefined) {\r\n\t            target[key] = source[key];\r\n\t        }\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction root (options, next) {\r\n\t\r\n\t    var url = next(options);\r\n\t\r\n\t    if (isString(options.root) && !url.match(/^(https?:)?\\//)) {\r\n\t        url = options.root + '/' + url;\r\n\t    }\r\n\t\r\n\t    return url;\r\n\t}\r\n\t\r\n\tfunction query (options, next) {\r\n\t\r\n\t    var urlParams = Object.keys(Url.options.params),\r\n\t        query = {},\r\n\t        url = next(options);\r\n\t\r\n\t    each(options.params, function (value, key) {\r\n\t        if (urlParams.indexOf(key) === -1) {\r\n\t            query[key] = value;\r\n\t        }\r\n\t    });\r\n\t\r\n\t    query = Url.params(query);\r\n\t\r\n\t    if (query) {\r\n\t        url += (url.indexOf('?') == -1 ? '?' : '&') + query;\r\n\t    }\r\n\t\r\n\t    return url;\r\n\t}\r\n\t\r\n\t/**\r\n\t * URL Template v2.0.6 (https://github.com/bramstein/url-template)\r\n\t */\r\n\t\r\n\tfunction expand(url, params, variables) {\r\n\t\r\n\t    var tmpl = parse(url),\r\n\t        expanded = tmpl.expand(params);\r\n\t\r\n\t    if (variables) {\r\n\t        variables.push.apply(variables, tmpl.vars);\r\n\t    }\r\n\t\r\n\t    return expanded;\r\n\t}\r\n\t\r\n\tfunction parse(template) {\r\n\t\r\n\t    var operators = ['+', '#', '.', '/', ';', '?', '&'],\r\n\t        variables = [];\r\n\t\r\n\t    return {\r\n\t        vars: variables,\r\n\t        expand: function (context) {\r\n\t            return template.replace(/\\{([^\\{\\}]+)\\}|([^\\{\\}]+)/g, function (_, expression, literal) {\r\n\t                if (expression) {\r\n\t\r\n\t                    var operator = null,\r\n\t                        values = [];\r\n\t\r\n\t                    if (operators.indexOf(expression.charAt(0)) !== -1) {\r\n\t                        operator = expression.charAt(0);\r\n\t                        expression = expression.substr(1);\r\n\t                    }\r\n\t\r\n\t                    expression.split(/,/g).forEach(function (variable) {\r\n\t                        var tmp = /([^:\\*]*)(?::(\\d+)|(\\*))?/.exec(variable);\r\n\t                        values.push.apply(values, getValues(context, operator, tmp[1], tmp[2] || tmp[3]));\r\n\t                        variables.push(tmp[1]);\r\n\t                    });\r\n\t\r\n\t                    if (operator && operator !== '+') {\r\n\t\r\n\t                        var separator = ',';\r\n\t\r\n\t                        if (operator === '?') {\r\n\t                            separator = '&';\r\n\t                        } else if (operator !== '#') {\r\n\t                            separator = operator;\r\n\t                        }\r\n\t\r\n\t                        return (values.length !== 0 ? operator : '') + values.join(separator);\r\n\t                    } else {\r\n\t                        return values.join(',');\r\n\t                    }\r\n\t                } else {\r\n\t                    return encodeReserved(literal);\r\n\t                }\r\n\t            });\r\n\t        }\r\n\t    };\r\n\t}\r\n\t\r\n\tfunction getValues(context, operator, key, modifier) {\r\n\t\r\n\t    var value = context[key],\r\n\t        result = [];\r\n\t\r\n\t    if (isDefined(value) && value !== '') {\r\n\t        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\r\n\t            value = value.toString();\r\n\t\r\n\t            if (modifier && modifier !== '*') {\r\n\t                value = value.substring(0, parseInt(modifier, 10));\r\n\t            }\r\n\t\r\n\t            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));\r\n\t        } else {\r\n\t            if (modifier === '*') {\r\n\t                if (Array.isArray(value)) {\r\n\t                    value.filter(isDefined).forEach(function (value) {\r\n\t                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));\r\n\t                    });\r\n\t                } else {\r\n\t                    Object.keys(value).forEach(function (k) {\r\n\t                        if (isDefined(value[k])) {\r\n\t                            result.push(encodeValue(operator, value[k], k));\r\n\t                        }\r\n\t                    });\r\n\t                }\r\n\t            } else {\r\n\t                var tmp = [];\r\n\t\r\n\t                if (Array.isArray(value)) {\r\n\t                    value.filter(isDefined).forEach(function (value) {\r\n\t                        tmp.push(encodeValue(operator, value));\r\n\t                    });\r\n\t                } else {\r\n\t                    Object.keys(value).forEach(function (k) {\r\n\t                        if (isDefined(value[k])) {\r\n\t                            tmp.push(encodeURIComponent(k));\r\n\t                            tmp.push(encodeValue(operator, value[k].toString()));\r\n\t                        }\r\n\t                    });\r\n\t                }\r\n\t\r\n\t                if (isKeyOperator(operator)) {\r\n\t                    result.push(encodeURIComponent(key) + '=' + tmp.join(','));\r\n\t                } else if (tmp.length !== 0) {\r\n\t                    result.push(tmp.join(','));\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    } else {\r\n\t        if (operator === ';') {\r\n\t            result.push(encodeURIComponent(key));\r\n\t        } else if (value === '' && (operator === '&' || operator === '?')) {\r\n\t            result.push(encodeURIComponent(key) + '=');\r\n\t        } else if (value === '') {\r\n\t            result.push('');\r\n\t        }\r\n\t    }\r\n\t\r\n\t    return result;\r\n\t}\r\n\t\r\n\tfunction isDefined(value) {\r\n\t    return value !== undefined && value !== null;\r\n\t}\r\n\t\r\n\tfunction isKeyOperator(operator) {\r\n\t    return operator === ';' || operator === '&' || operator === '?';\r\n\t}\r\n\t\r\n\tfunction encodeValue(operator, value, key) {\r\n\t\r\n\t    value = operator === '+' || operator === '#' ? encodeReserved(value) : encodeURIComponent(value);\r\n\t\r\n\t    if (key) {\r\n\t        return encodeURIComponent(key) + '=' + value;\r\n\t    } else {\r\n\t        return value;\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction encodeReserved(str) {\r\n\t    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {\r\n\t        if (!/%[0-9A-Fa-f]/.test(part)) {\r\n\t            part = encodeURI(part);\r\n\t        }\r\n\t        return part;\r\n\t    }).join('');\r\n\t}\r\n\t\r\n\tfunction template (options) {\r\n\t\r\n\t    var variables = [],\r\n\t        url = expand(options.url, options.params, variables);\r\n\t\r\n\t    variables.forEach(function (key) {\r\n\t        delete options.params[key];\r\n\t    });\r\n\t\r\n\t    return url;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Service for URL templating.\r\n\t */\r\n\t\r\n\tvar ie = document.documentMode;\r\n\tvar el = document.createElement('a');\r\n\t\r\n\tfunction Url(url, params) {\r\n\t\r\n\t    var self = this || {},\r\n\t        options = url,\r\n\t        transform;\r\n\t\r\n\t    if (isString(url)) {\r\n\t        options = { url: url, params: params };\r\n\t    }\r\n\t\r\n\t    options = merge({}, Url.options, self.$options, options);\r\n\t\r\n\t    Url.transforms.forEach(function (handler) {\r\n\t        transform = factory(handler, transform, self.$vm);\r\n\t    });\r\n\t\r\n\t    return transform(options);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Url options.\r\n\t */\r\n\t\r\n\tUrl.options = {\r\n\t    url: '',\r\n\t    root: null,\r\n\t    params: {}\r\n\t};\r\n\t\r\n\t/**\r\n\t * Url transforms.\r\n\t */\r\n\t\r\n\tUrl.transforms = [template, query, root];\r\n\t\r\n\t/**\r\n\t * Encodes a Url parameter string.\r\n\t *\r\n\t * @param {Object} obj\r\n\t */\r\n\t\r\n\tUrl.params = function (obj) {\r\n\t\r\n\t    var params = [],\r\n\t        escape = encodeURIComponent;\r\n\t\r\n\t    params.add = function (key, value) {\r\n\t\r\n\t        if (isFunction(value)) {\r\n\t            value = value();\r\n\t        }\r\n\t\r\n\t        if (value === null) {\r\n\t            value = '';\r\n\t        }\r\n\t\r\n\t        this.push(escape(key) + '=' + escape(value));\r\n\t    };\r\n\t\r\n\t    serialize(params, obj);\r\n\t\r\n\t    return params.join('&').replace(/%20/g, '+');\r\n\t};\r\n\t\r\n\t/**\r\n\t * Parse a URL and return its components.\r\n\t *\r\n\t * @param {String} url\r\n\t */\r\n\t\r\n\tUrl.parse = function (url) {\r\n\t\r\n\t    if (ie) {\r\n\t        el.href = url;\r\n\t        url = el.href;\r\n\t    }\r\n\t\r\n\t    el.href = url;\r\n\t\r\n\t    return {\r\n\t        href: el.href,\r\n\t        protocol: el.protocol ? el.protocol.replace(/:$/, '') : '',\r\n\t        port: el.port,\r\n\t        host: el.host,\r\n\t        hostname: el.hostname,\r\n\t        pathname: el.pathname.charAt(0) === '/' ? el.pathname : '/' + el.pathname,\r\n\t        search: el.search ? el.search.replace(/^\\?/, '') : '',\r\n\t        hash: el.hash ? el.hash.replace(/^#/, '') : ''\r\n\t    };\r\n\t};\r\n\t\r\n\tfunction factory(handler, next, vm) {\r\n\t    return function (options) {\r\n\t        return handler.call(vm, options, next);\r\n\t    };\r\n\t}\r\n\t\r\n\tfunction serialize(params, obj, scope) {\r\n\t\r\n\t    var array = isArray(obj),\r\n\t        plain = isPlainObject(obj),\r\n\t        hash;\r\n\t\r\n\t    each(obj, function (value, key) {\r\n\t\r\n\t        hash = isObject(value) || isArray(value);\r\n\t\r\n\t        if (scope) {\r\n\t            key = scope + '[' + (plain || hash ? key : '') + ']';\r\n\t        }\r\n\t\r\n\t        if (!scope && array) {\r\n\t            params.add(value.name, value.value);\r\n\t        } else if (hash) {\r\n\t            serialize(params, value, key);\r\n\t        } else {\r\n\t            params.add(key, value);\r\n\t        }\r\n\t    });\r\n\t}\r\n\t\r\n\tfunction xdrClient (request) {\r\n\t    return new Promise$1(function (resolve) {\r\n\t\r\n\t        var xdr = new XDomainRequest(),\r\n\t            handler = function (event) {\r\n\t\r\n\t            var response = request.respondWith(xdr.responseText, {\r\n\t                status: xdr.status,\r\n\t                statusText: xdr.statusText\r\n\t            });\r\n\t\r\n\t            resolve(response);\r\n\t        };\r\n\t\r\n\t        request.abort = function () {\r\n\t            return xdr.abort();\r\n\t        };\r\n\t\r\n\t        xdr.open(request.method, request.getUrl(), true);\r\n\t        xdr.timeout = 0;\r\n\t        xdr.onload = handler;\r\n\t        xdr.onerror = handler;\r\n\t        xdr.ontimeout = function () {};\r\n\t        xdr.onprogress = function () {};\r\n\t        xdr.send(request.getBody());\r\n\t    });\r\n\t}\r\n\t\r\n\tvar ORIGIN_URL = Url.parse(location.href);\r\n\tvar SUPPORTS_CORS = 'withCredentials' in new XMLHttpRequest();\r\n\t\r\n\tfunction cors (request, next) {\r\n\t\r\n\t    if (!isBoolean(request.crossOrigin) && crossOrigin(request)) {\r\n\t        request.crossOrigin = true;\r\n\t    }\r\n\t\r\n\t    if (request.crossOrigin) {\r\n\t\r\n\t        if (!SUPPORTS_CORS) {\r\n\t            request.client = xdrClient;\r\n\t        }\r\n\t\r\n\t        delete request.emulateHTTP;\r\n\t    }\r\n\t\r\n\t    next();\r\n\t}\r\n\t\r\n\tfunction crossOrigin(request) {\r\n\t\r\n\t    var requestUrl = Url.parse(Url(request));\r\n\t\r\n\t    return requestUrl.protocol !== ORIGIN_URL.protocol || requestUrl.host !== ORIGIN_URL.host;\r\n\t}\r\n\t\r\n\tfunction body (request, next) {\r\n\t\r\n\t    if (request.emulateJSON && isPlainObject(request.body)) {\r\n\t        request.body = Url.params(request.body);\r\n\t        request.headers['Content-Type'] = 'application/x-www-form-urlencoded';\r\n\t    }\r\n\t\r\n\t    if (isFormData(request.body)) {\r\n\t        delete request.headers['Content-Type'];\r\n\t    }\r\n\t\r\n\t    if (isPlainObject(request.body)) {\r\n\t        request.body = JSON.stringify(request.body);\r\n\t    }\r\n\t\r\n\t    next(function (response) {\r\n\t\r\n\t        var contentType = response.headers['Content-Type'];\r\n\t\r\n\t        if (isString(contentType) && contentType.indexOf('application/json') === 0) {\r\n\t\r\n\t            try {\r\n\t                response.data = response.json();\r\n\t            } catch (e) {\r\n\t                response.data = null;\r\n\t            }\r\n\t        } else {\r\n\t            response.data = response.text();\r\n\t        }\r\n\t    });\r\n\t}\r\n\t\r\n\tfunction jsonpClient (request) {\r\n\t    return new Promise$1(function (resolve) {\r\n\t\r\n\t        var name = request.jsonp || 'callback',\r\n\t            callback = '_jsonp' + Math.random().toString(36).substr(2),\r\n\t            body = null,\r\n\t            handler,\r\n\t            script;\r\n\t\r\n\t        handler = function (event) {\r\n\t\r\n\t            var status = 0;\r\n\t\r\n\t            if (event.type === 'load' && body !== null) {\r\n\t                status = 200;\r\n\t            } else if (event.type === 'error') {\r\n\t                status = 404;\r\n\t            }\r\n\t\r\n\t            resolve(request.respondWith(body, { status: status }));\r\n\t\r\n\t            delete window[callback];\r\n\t            document.body.removeChild(script);\r\n\t        };\r\n\t\r\n\t        request.params[name] = callback;\r\n\t\r\n\t        window[callback] = function (result) {\r\n\t            body = JSON.stringify(result);\r\n\t        };\r\n\t\r\n\t        script = document.createElement('script');\r\n\t        script.src = request.getUrl();\r\n\t        script.type = 'text/javascript';\r\n\t        script.async = true;\r\n\t        script.onload = handler;\r\n\t        script.onerror = handler;\r\n\t\r\n\t        document.body.appendChild(script);\r\n\t    });\r\n\t}\r\n\t\r\n\tfunction jsonp (request, next) {\r\n\t\r\n\t    if (request.method == 'JSONP') {\r\n\t        request.client = jsonpClient;\r\n\t    }\r\n\t\r\n\t    next(function (response) {\r\n\t\r\n\t        if (request.method == 'JSONP') {\r\n\t            response.data = response.json();\r\n\t        }\r\n\t    });\r\n\t}\r\n\t\r\n\tfunction before (request, next) {\r\n\t\r\n\t    if (isFunction(request.before)) {\r\n\t        request.before.call(this, request);\r\n\t    }\r\n\t\r\n\t    next();\r\n\t}\r\n\t\r\n\t/**\r\n\t * HTTP method override Interceptor.\r\n\t */\r\n\t\r\n\tfunction method (request, next) {\r\n\t\r\n\t    if (request.emulateHTTP && /^(PUT|PATCH|DELETE)$/i.test(request.method)) {\r\n\t        request.headers['X-HTTP-Method-Override'] = request.method;\r\n\t        request.method = 'POST';\r\n\t    }\r\n\t\r\n\t    next();\r\n\t}\r\n\t\r\n\tfunction header (request, next) {\r\n\t\r\n\t    request.method = request.method.toUpperCase();\r\n\t    request.headers = assign({}, Http.headers.common, !request.crossOrigin ? Http.headers.custom : {}, Http.headers[request.method.toLowerCase()], request.headers);\r\n\t\r\n\t    next();\r\n\t}\r\n\t\r\n\t/**\r\n\t * Timeout Interceptor.\r\n\t */\r\n\t\r\n\tfunction timeout (request, next) {\r\n\t\r\n\t    var timeout;\r\n\t\r\n\t    if (request.timeout) {\r\n\t        timeout = setTimeout(function () {\r\n\t            request.abort();\r\n\t        }, request.timeout);\r\n\t    }\r\n\t\r\n\t    next(function (response) {\r\n\t\r\n\t        clearTimeout(timeout);\r\n\t    });\r\n\t}\r\n\t\r\n\tfunction xhrClient (request) {\r\n\t    return new Promise$1(function (resolve) {\r\n\t\r\n\t        var xhr = new XMLHttpRequest(),\r\n\t            handler = function (event) {\r\n\t\r\n\t            var response = request.respondWith('response' in xhr ? xhr.response : xhr.responseText, {\r\n\t                status: xhr.status === 1223 ? 204 : xhr.status, // IE9 status bug\r\n\t                statusText: xhr.status === 1223 ? 'No Content' : trim(xhr.statusText),\r\n\t                headers: parseHeaders(xhr.getAllResponseHeaders())\r\n\t            });\r\n\t\r\n\t            resolve(response);\r\n\t        };\r\n\t\r\n\t        request.abort = function () {\r\n\t            return xhr.abort();\r\n\t        };\r\n\t\r\n\t        xhr.open(request.method, request.getUrl(), true);\r\n\t        xhr.timeout = 0;\r\n\t        xhr.onload = handler;\r\n\t        xhr.onerror = handler;\r\n\t\r\n\t        if (request.progress) {\r\n\t            if (request.method === 'GET') {\r\n\t                xhr.addEventListener('progress', request.progress);\r\n\t            } else if (/^(POST|PUT)$/i.test(request.method)) {\r\n\t                xhr.upload.addEventListener('progress', request.progress);\r\n\t            }\r\n\t        }\r\n\t\r\n\t        if (request.credentials === true) {\r\n\t            xhr.withCredentials = true;\r\n\t        }\r\n\t\r\n\t        each(request.headers || {}, function (value, header) {\r\n\t            xhr.setRequestHeader(header, value);\r\n\t        });\r\n\t\r\n\t        xhr.send(request.getBody());\r\n\t    });\r\n\t}\r\n\t\r\n\tfunction parseHeaders(str) {\r\n\t\r\n\t    var headers = {},\r\n\t        value,\r\n\t        name,\r\n\t        i;\r\n\t\r\n\t    each(trim(str).split('\\n'), function (row) {\r\n\t\r\n\t        i = row.indexOf(':');\r\n\t        name = trim(row.slice(0, i));\r\n\t        value = trim(row.slice(i + 1));\r\n\t\r\n\t        if (headers[name]) {\r\n\t\r\n\t            if (isArray(headers[name])) {\r\n\t                headers[name].push(value);\r\n\t            } else {\r\n\t                headers[name] = [headers[name], value];\r\n\t            }\r\n\t        } else {\r\n\t\r\n\t            headers[name] = value;\r\n\t        }\r\n\t    });\r\n\t\r\n\t    return headers;\r\n\t}\r\n\t\r\n\tfunction Client (context) {\r\n\t\r\n\t    var reqHandlers = [sendRequest],\r\n\t        resHandlers = [],\r\n\t        handler;\r\n\t\r\n\t    if (!isObject(context)) {\r\n\t        context = null;\r\n\t    }\r\n\t\r\n\t    function Client(request) {\r\n\t        return new Promise$1(function (resolve) {\r\n\t\r\n\t            function exec() {\r\n\t\r\n\t                handler = reqHandlers.pop();\r\n\t\r\n\t                if (isFunction(handler)) {\r\n\t                    handler.call(context, request, next);\r\n\t                } else {\r\n\t                    warn('Invalid interceptor of type ' + typeof handler + ', must be a function');\r\n\t                    next();\r\n\t                }\r\n\t            }\r\n\t\r\n\t            function next(response) {\r\n\t\r\n\t                if (isFunction(response)) {\r\n\t\r\n\t                    resHandlers.unshift(response);\r\n\t                } else if (isObject(response)) {\r\n\t\r\n\t                    resHandlers.forEach(function (handler) {\r\n\t                        response = when(response, function (response) {\r\n\t                            return handler.call(context, response) || response;\r\n\t                        });\r\n\t                    });\r\n\t\r\n\t                    when(response, resolve);\r\n\t\r\n\t                    return;\r\n\t                }\r\n\t\r\n\t                exec();\r\n\t            }\r\n\t\r\n\t            exec();\r\n\t        }, context);\r\n\t    }\r\n\t\r\n\t    Client.use = function (handler) {\r\n\t        reqHandlers.push(handler);\r\n\t    };\r\n\t\r\n\t    return Client;\r\n\t}\r\n\t\r\n\tfunction sendRequest(request, resolve) {\r\n\t\r\n\t    var client = request.client || xhrClient;\r\n\t\r\n\t    resolve(client(request));\r\n\t}\r\n\t\r\n\tvar classCallCheck = function (instance, Constructor) {\r\n\t  if (!(instance instanceof Constructor)) {\r\n\t    throw new TypeError(\"Cannot call a class as a function\");\r\n\t  }\r\n\t};\r\n\t\r\n\t/**\r\n\t * HTTP Response.\r\n\t */\r\n\t\r\n\tvar Response = function () {\r\n\t    function Response(body, _ref) {\r\n\t        var url = _ref.url;\r\n\t        var headers = _ref.headers;\r\n\t        var status = _ref.status;\r\n\t        var statusText = _ref.statusText;\r\n\t        classCallCheck(this, Response);\r\n\t\r\n\t\r\n\t        this.url = url;\r\n\t        this.body = body;\r\n\t        this.headers = headers || {};\r\n\t        this.status = status || 0;\r\n\t        this.statusText = statusText || '';\r\n\t        this.ok = status >= 200 && status < 300;\r\n\t    }\r\n\t\r\n\t    Response.prototype.text = function text() {\r\n\t        return this.body;\r\n\t    };\r\n\t\r\n\t    Response.prototype.blob = function blob() {\r\n\t        return new Blob([this.body]);\r\n\t    };\r\n\t\r\n\t    Response.prototype.json = function json() {\r\n\t        return JSON.parse(this.body);\r\n\t    };\r\n\t\r\n\t    return Response;\r\n\t}();\r\n\t\r\n\tvar Request = function () {\r\n\t    function Request(options) {\r\n\t        classCallCheck(this, Request);\r\n\t\r\n\t\r\n\t        this.method = 'GET';\r\n\t        this.body = null;\r\n\t        this.params = {};\r\n\t        this.headers = {};\r\n\t\r\n\t        assign(this, options);\r\n\t    }\r\n\t\r\n\t    Request.prototype.getUrl = function getUrl() {\r\n\t        return Url(this);\r\n\t    };\r\n\t\r\n\t    Request.prototype.getBody = function getBody() {\r\n\t        return this.body;\r\n\t    };\r\n\t\r\n\t    Request.prototype.respondWith = function respondWith(body, options) {\r\n\t        return new Response(body, assign(options || {}, { url: this.getUrl() }));\r\n\t    };\r\n\t\r\n\t    return Request;\r\n\t}();\r\n\t\r\n\t/**\r\n\t * Service for sending network requests.\r\n\t */\r\n\t\r\n\tvar CUSTOM_HEADERS = { 'X-Requested-With': 'XMLHttpRequest' };\r\n\tvar COMMON_HEADERS = { 'Accept': 'application/json, text/plain, */*' };\r\n\tvar JSON_CONTENT_TYPE = { 'Content-Type': 'application/json;charset=utf-8' };\r\n\t\r\n\tfunction Http(options) {\r\n\t\r\n\t    var self = this || {},\r\n\t        client = Client(self.$vm);\r\n\t\r\n\t    defaults(options || {}, self.$options, Http.options);\r\n\t\r\n\t    Http.interceptors.forEach(function (handler) {\r\n\t        client.use(handler);\r\n\t    });\r\n\t\r\n\t    return client(new Request(options)).then(function (response) {\r\n\t\r\n\t        return response.ok ? response : Promise$1.reject(response);\r\n\t    }, function (response) {\r\n\t\r\n\t        if (response instanceof Error) {\r\n\t            error(response);\r\n\t        }\r\n\t\r\n\t        return Promise$1.reject(response);\r\n\t    });\r\n\t}\r\n\t\r\n\tHttp.options = {};\r\n\t\r\n\tHttp.headers = {\r\n\t    put: JSON_CONTENT_TYPE,\r\n\t    post: JSON_CONTENT_TYPE,\r\n\t    patch: JSON_CONTENT_TYPE,\r\n\t    delete: JSON_CONTENT_TYPE,\r\n\t    custom: CUSTOM_HEADERS,\r\n\t    common: COMMON_HEADERS\r\n\t};\r\n\t\r\n\tHttp.interceptors = [before, timeout, method, body, jsonp, header, cors];\r\n\t\r\n\t['get', 'delete', 'head', 'jsonp'].forEach(function (method) {\r\n\t\r\n\t    Http[method] = function (url, options) {\r\n\t        return this(assign(options || {}, { url: url, method: method }));\r\n\t    };\r\n\t});\r\n\t\r\n\t['post', 'put', 'patch'].forEach(function (method) {\r\n\t\r\n\t    Http[method] = function (url, body, options) {\r\n\t        return this(assign(options || {}, { url: url, method: method, body: body }));\r\n\t    };\r\n\t});\r\n\t\r\n\tfunction Resource(url, params, actions, options) {\r\n\t\r\n\t    var self = this || {},\r\n\t        resource = {};\r\n\t\r\n\t    actions = assign({}, Resource.actions, actions);\r\n\t\r\n\t    each(actions, function (action, name) {\r\n\t\r\n\t        action = merge({ url: url, params: params || {} }, options, action);\r\n\t\r\n\t        resource[name] = function () {\r\n\t            return (self.$http || Http)(opts(action, arguments));\r\n\t        };\r\n\t    });\r\n\t\r\n\t    return resource;\r\n\t}\r\n\t\r\n\tfunction opts(action, args) {\r\n\t\r\n\t    var options = assign({}, action),\r\n\t        params = {},\r\n\t        body;\r\n\t\r\n\t    switch (args.length) {\r\n\t\r\n\t        case 2:\r\n\t\r\n\t            params = args[0];\r\n\t            body = args[1];\r\n\t\r\n\t            break;\r\n\t\r\n\t        case 1:\r\n\t\r\n\t            if (/^(POST|PUT|PATCH)$/i.test(options.method)) {\r\n\t                body = args[0];\r\n\t            } else {\r\n\t                params = args[0];\r\n\t            }\r\n\t\r\n\t            break;\r\n\t\r\n\t        case 0:\r\n\t\r\n\t            break;\r\n\t\r\n\t        default:\r\n\t\r\n\t            throw 'Expected up to 4 arguments [params, body], got ' + args.length + ' arguments';\r\n\t    }\r\n\t\r\n\t    options.body = body;\r\n\t    options.params = assign({}, options.params, params);\r\n\t\r\n\t    return options;\r\n\t}\r\n\t\r\n\tResource.actions = {\r\n\t\r\n\t    get: { method: 'GET' },\r\n\t    save: { method: 'POST' },\r\n\t    query: { method: 'GET' },\r\n\t    update: { method: 'PUT' },\r\n\t    remove: { method: 'DELETE' },\r\n\t    delete: { method: 'DELETE' }\r\n\t\r\n\t};\r\n\t\r\n\tfunction plugin(Vue) {\r\n\t\r\n\t    if (plugin.installed) {\r\n\t        return;\r\n\t    }\r\n\t\r\n\t    Util(Vue);\r\n\t\r\n\t    Vue.url = Url;\r\n\t    Vue.http = Http;\r\n\t    Vue.resource = Resource;\r\n\t    Vue.Promise = Promise$1;\r\n\t\r\n\t    Object.defineProperties(Vue.prototype, {\r\n\t\r\n\t        $url: {\r\n\t            get: function () {\r\n\t                return options(Vue.url, this, this.$options.url);\r\n\t            }\r\n\t        },\r\n\t\r\n\t        $http: {\r\n\t            get: function () {\r\n\t                return options(Vue.http, this, this.$options.http);\r\n\t            }\r\n\t        },\r\n\t\r\n\t        $resource: {\r\n\t            get: function () {\r\n\t                return Vue.resource.bind(this);\r\n\t            }\r\n\t        },\r\n\t\r\n\t        $promise: {\r\n\t            get: function () {\r\n\t                var _this = this;\r\n\t\r\n\t                return function (executor) {\r\n\t                    return new Vue.Promise(executor, _this);\r\n\t                };\r\n\t            }\r\n\t        }\r\n\t\r\n\t    });\r\n\t}\r\n\t\r\n\tif (typeof window !== 'undefined' && window.Vue) {\r\n\t    window.Vue.use(plugin);\r\n\t}\r\n\t\r\n\tmodule.exports = plugin;\n\n/***/ },\n\n/***/ 13:\n/*!***********************************************!*\\\n  !*** ./lib/vue-router/dist/vue-router.min.js ***!\n  \\***********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\r\n\t * vue-router v0.7.13\r\n\t * (c) 2016 Evan You\r\n\t * Released under the MIT License.\r\n\t */\r\n\t!function(t,e){ true?module.exports=e():\"function\"==typeof define&&define.amd?define(e):t.VueRouter=e()}(this,function(){\"use strict\";function t(t,e,n){this.path=t,this.matcher=e,this.delegate=n}function e(t){this.routes={},this.children={},this.target=t}function n(e,r,i){return function(o,a){var s=e+o;return a?void a(n(s,r,i)):new t(e+o,r,i)}}function r(t,e,n){for(var r=0,i=0,o=t.length;o>i;i++)r+=t[i].path.length;e=e.substr(r);var a={path:e,handler:n};t.push(a)}function i(t,e,n,o){var a=e.routes;for(var s in a)if(a.hasOwnProperty(s)){var h=t.slice();r(h,s,a[s]),e.children[s]?i(h,e.children[s],n,o):n.call(o,h)}}function o(t,r){var o=new e;t(n(\"\",o,this.delegate)),i([],o,function(t){r?r(this,t):this.add(t)},this)}function a(t){B||\"undefined\"==typeof console||console.error(\"[vue-router] \"+t)}function s(t,e){try{return e?decodeURIComponent(t):decodeURI(t)}catch(n){a(\"malformed URI\"+(e?\" component: \":\": \")+t)}}function h(t){return\"[object Array]\"===Object.prototype.toString.call(t)}function c(t){this.string=t}function u(t){this.name=t}function l(t){this.name=t}function p(){}function f(t,e,n){\"/\"===t.charAt(0)&&(t=t.substr(1));var r=t.split(\"/\"),i=[];n.val=\"\";for(var o=0,a=r.length;a>o;o++){var s,h=r[o];(s=h.match(/^:([^\\/]+)$/))?(i.push(new u(s[1])),e.push(s[1]),n.val+=\"3\"):(s=h.match(/^\\*([^\\/]+)$/))?(i.push(new l(s[1])),n.val+=\"2\",e.push(s[1])):\"\"===h?(i.push(new p),n.val+=\"1\"):(i.push(new c(h)),n.val+=\"4\")}return n.val=+n.val,i}function d(t){this.charSpec=t,this.nextStates=[]}function v(t){return t.sort(function(t,e){return e.specificity.val-t.specificity.val})}function g(t,e){for(var n=[],r=0,i=t.length;i>r;r++){var o=t[r];n=n.concat(o.match(e))}return n}function y(t){this.queryParams=t||{}}function m(t,e,n){for(var r=t.handlers,i=t.regex,o=e.match(i),a=1,s=new y(n),h=0,c=r.length;c>h;h++){for(var u=r[h],l=u.names,p={},f=0,d=l.length;d>f;f++)p[l[f]]=o[a++];s.push({handler:u.handler,params:p,isDynamic:!!l.length})}return s}function _(t,e){return e.eachChar(function(e){t=t.put(e)}),t}function w(t){return t=t.replace(/\\+/gm,\"%20\"),s(t,!0)}function b(t){\"undefined\"!=typeof console&&console.error(\"[vue-router] \"+t)}function C(t,e,n){var r=t.match(/(\\?.*)$/);if(r&&(r=r[1],t=t.slice(0,-r.length)),\"?\"===e.charAt(0))return t+e;var i=t.split(\"/\");n&&i[i.length-1]||i.pop();for(var o=e.replace(/^\\//,\"\").split(\"/\"),a=0;a<o.length;a++){var s=o[a];\".\"!==s&&(\"..\"===s?i.pop():i.push(s))}return\"\"!==i[0]&&i.unshift(\"\"),i.join(\"/\")}function R(t){return t&&\"function\"==typeof t.then}function A(t,e){var n=t&&(t.$options||t.options);return n&&n.route&&n.route[e]}function k(t,e){Y?Y.$options.components._=t.component:Y={resolve:X.Vue.prototype._resolveComponent,$options:{components:{_:t.component}}},Y.resolve(\"_\",function(n){t.component=n,e(n)})}function $(t,e,n){return void 0===e&&(e={}),t=t.replace(/:([^\\/]+)/g,function(n,r){var i=e[r];return i||b('param \"'+r+'\" not found when generating path for \"'+t+'\" with params '+JSON.stringify(e)),i||\"\"}),n&&(t+=K(n)),t}function x(t,e,n){var r=t.childVM;if(!r||!e)return!1;if(t.Component!==e.component)return!1;var i=A(r,\"canReuse\");return\"boolean\"==typeof i?i:i?i.call(r,{to:n.to,from:n.from}):!0}function E(t,e,n){var r=t.childVM,i=A(r,\"canDeactivate\");i?e.callHook(i,r,n,{expectBoolean:!0}):n()}function V(t,e,n){k(t,function(t){if(!e.aborted){var r=A(t,\"canActivate\");r?e.callHook(r,null,n,{expectBoolean:!0}):n()}})}function S(t,e,n){var r=t.childVM,i=A(r,\"deactivate\");i?e.callHooks(i,r,n):n()}function P(t,e,n,r,i){var o=e.activateQueue[n];if(!o)return H(t),t._bound&&t.setComponent(null),void(r&&r());var a=t.Component=o.component,s=A(a,\"activate\"),h=A(a,\"data\"),c=A(a,\"waitForData\");t.depth=n,t.activated=!1;var u=void 0,l=!(!h||c);if(i=i&&t.childVM&&t.childVM.constructor===a)u=t.childVM,u.$loadingRouteData=l;else if(H(t),t.unbuild(!0),u=t.build({_meta:{$loadingRouteData:l},created:function(){this._routerView=t}}),t.keepAlive){u.$loadingRouteData=l;var p=u._keepAliveRouterView;p&&(t.childView=p,u._keepAliveRouterView=null)}var f=function(){u.$destroy()},d=function(){if(i)return void(r&&r());var n=e.router;n._rendered||n._transitionOnLoad?t.transition(u):(t.setCurrent?t.setCurrent(u):t.childVM=u,u.$before(t.anchor,null,!1)),r&&r()},v=function(){t.childView&&P(t.childView,e,n+1,null,i||t.keepAlive),d()},g=function(){t.activated=!0,h&&c?T(u,e,h,v,f):(h&&T(u,e,h),v())};s?e.callHooks(s,u,g,{cleanup:f,postActivate:!0}):g()}function O(t,e){var n=t.childVM,r=A(n,\"data\");r&&T(n,e,r)}function T(t,e,n,r,i){t.$loadingRouteData=!0,e.callHooks(n,t,function(){t.$loadingRouteData=!1,t.$emit(\"route-data-loaded\",t),r&&r()},{cleanup:i,postActivate:!0,processData:function(e){var n=[];return j(e)&&Object.keys(e).forEach(function(r){var i=e[r];R(i)?n.push(i.then(function(e){t.$set(r,e)})):t.$set(r,i)}),n.length?n[0].constructor.all(n):void 0}})}function H(t){t.keepAlive&&t.childVM&&t.childView&&(t.childVM._keepAliveRouterView=t.childView),t.childView=null}function j(t){return\"[object Object]\"===Object.prototype.toString.call(t)}function M(t){return\"[object Object]\"===Object.prototype.toString.call(t)}function D(t){return t?Array.prototype.slice.call(t):[]}function q(t){var e=t.util,n=e.extend,r=e.isArray,i=e.defineReactive,o=t.prototype._init;t.prototype._init=function(t){t=t||{};var e=t._parent||t.parent||this,n=e.$router,r=e.$route;n&&(this.$router=n,n._children.push(this),this._defineMeta?this._defineMeta(\"$route\",r):i(this,\"$route\",r)),o.call(this,t)};var a=t.prototype._destroy;t.prototype._destroy=function(){!this._isBeingDestroyed&&this.$router&&this.$router._children.$remove(this),a.apply(this,arguments)};var s=t.config.optionMergeStrategies,h=/^(data|activate|deactivate)$/;s&&(s.route=function(t,e){if(!e)return t;if(!t)return e;var i={};n(i,t);for(var o in e){var a=i[o],s=e[o];a&&h.test(o)?i[o]=(r(a)?a:[a]).concat(s):i[o]=s}return i})}function z(t){var e=t.util,n=t.directive(\"_component\")||t.internalDirectives.component,r=e.extend({},n);e.extend(r,{_isRouterView:!0,bind:function(){var t=this.vm.$route;if(!t)return void b(\"<router-view> can only be used inside a router-enabled app.\");this._isDynamicLiteral=!0,n.bind.call(this);for(var e=void 0,r=this.vm;r;){if(r._routerView){e=r._routerView;break}r=r.$parent}if(e)this.parentView=e,e.childView=this;else{var i=t.router;i._rootView=this}var o=t.router._currentTransition;if(!e&&o.done||e&&e.activated){var a=e?e.depth+1:0;P(this,o,a)}},unbind:function(){this.parentView&&(this.parentView.childView=null),n.unbind.call(this)}}),t.elementDirective(\"router-view\",r)}function Q(t){function e(t){return t.protocol===location.protocol&&t.hostname===location.hostname&&t.port===location.port}function n(t,e,n){if(e=e.trim(),-1===e.indexOf(\" \"))return void n(t,e);for(var r=e.split(/\\s+/),i=0,o=r.length;o>i;i++)n(t,r[i])}var r=t.util,i=r.bind,o=r.isObject,a=r.addClass,s=r.removeClass,h=t.directive(\"on\").priority,c=\"__vue-router-link-update__\",u=0;t.directive(\"link-active\",{priority:9999,bind:function(){for(var t=this,e=String(u++),n=this.el.querySelectorAll(\"[v-link]\"),r=0,i=n.length;i>r;r++){var o=n[r],a=o.getAttribute(c),s=a?a+\",\"+e:e;o.setAttribute(c,s)}this.vm.$on(c,this.cb=function(n,r){n.activeIds.indexOf(e)>-1&&n.updateClasses(r,t.el)})},unbind:function(){this.vm.$off(c,this.cb)}}),t.directive(\"link\",{priority:h-2,bind:function(){var t=this.vm;if(!t.$route)return void b(\"v-link can only be used inside a router-enabled app.\");this.router=t.$route.router,this.unwatch=t.$watch(\"$route\",i(this.onRouteUpdate,this));var e=this.el.getAttribute(c);e&&(this.el.removeAttribute(c),this.activeIds=e.split(\",\")),\"A\"===this.el.tagName&&\"_blank\"===this.el.getAttribute(\"target\")||(this.handler=i(this.onClick,this),this.el.addEventListener(\"click\",this.handler))},update:function(t){this.target=t,o(t)&&(this.append=t.append,this.exact=t.exact,this.prevActiveClass=this.activeClass,this.activeClass=t.activeClass),this.onRouteUpdate(this.vm.$route)},onClick:function(t){if(!(t.metaKey||t.ctrlKey||t.shiftKey||t.defaultPrevented||0!==t.button)){var n=this.target;if(n)t.preventDefault(),this.router.go(n);else{for(var r=t.target;\"A\"!==r.tagName&&r!==this.el;)r=r.parentNode;if(\"A\"===r.tagName&&e(r)){t.preventDefault();var i=r.pathname;this.router.history.root&&(i=i.replace(this.router.history.rootRE,\"\")),this.router.go({path:i,replace:n&&n.replace,append:n&&n.append})}}}},onRouteUpdate:function(t){var e=this.router.stringifyPath(this.target);this.path!==e&&(this.path=e,this.updateActiveMatch(),this.updateHref()),this.activeIds?this.vm.$emit(c,this,t.path):this.updateClasses(t.path,this.el)},updateActiveMatch:function(){this.activeRE=this.path&&!this.exact?new RegExp(\"^\"+this.path.replace(/\\/$/,\"\").replace(at,\"\").replace(ot,\"\\\\$&\")+\"(\\\\/|$)\"):null},updateHref:function(){if(\"A\"===this.el.tagName){var t=this.path,e=this.router,n=\"/\"===t.charAt(0),r=t&&(\"hash\"===e.mode||n)?e.history.formatPath(t,this.append):t;r?this.el.href=r:this.el.removeAttribute(\"href\")}},updateClasses:function(t,e){var r=this.activeClass||this.router._linkActiveClass;this.prevActiveClass&&this.prevActiveClass!==r&&n(e,this.prevActiveClass,s);var i=this.path.replace(at,\"\");t=t.replace(at,\"\"),this.exact?i===t||\"/\"!==i.charAt(i.length-1)&&i===t.replace(it,\"\")?n(e,r,a):n(e,r,s):this.activeRE&&this.activeRE.test(t)?n(e,r,a):n(e,r,s)},unbind:function(){this.el.removeEventListener(\"click\",this.handler),this.unwatch&&this.unwatch()}})}function F(t,e){var n=e.component;ht.util.isPlainObject(n)&&(n=e.component=ht.extend(n)),\"function\"!=typeof n&&(e.component=null,b('invalid component for route \"'+t+'\".'))}var I={};I.classCallCheck=function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")},t.prototype={to:function(t,e){var n=this.delegate;if(n&&n.willAddRoute&&(t=n.willAddRoute(this.matcher.target,t)),this.matcher.add(this.path,t),e){if(0===e.length)throw new Error(\"You must have an argument in the function passed to `to`\");this.matcher.addChild(this.path,t,e,this.delegate)}return this}},e.prototype={add:function(t,e){this.routes[t]=e},addChild:function(t,r,i,o){var a=new e(r);this.children[t]=a;var s=n(t,a,o);o&&o.contextEntered&&o.contextEntered(r,s),i(s)}};var U=[\"/\",\".\",\"*\",\"+\",\"?\",\"|\",\"(\",\")\",\"[\",\"]\",\"{\",\"}\",\"\\\\\"],L=new RegExp(\"(\\\\\"+U.join(\"|\\\\\")+\")\",\"g\"),B=!1;c.prototype={eachChar:function(t){for(var e,n=this.string,r=0,i=n.length;i>r;r++)e=n.charAt(r),t({validChars:e})},regex:function(){return this.string.replace(L,\"\\\\$1\")},generate:function(){return this.string}},u.prototype={eachChar:function(t){t({invalidChars:\"/\",repeat:!0})},regex:function(){return\"([^/]+)\"},generate:function(t){var e=t[this.name];return null==e?\":\"+this.name:e}},l.prototype={eachChar:function(t){t({invalidChars:\"\",repeat:!0})},regex:function(){return\"(.+)\"},generate:function(t){var e=t[this.name];return null==e?\":\"+this.name:e}},p.prototype={eachChar:function(){},regex:function(){return\"\"},generate:function(){return\"\"}},d.prototype={get:function(t){for(var e=this.nextStates,n=0,r=e.length;r>n;n++){var i=e[n],o=i.charSpec.validChars===t.validChars;if(o=o&&i.charSpec.invalidChars===t.invalidChars)return i}},put:function(t){var e;return(e=this.get(t))?e:(e=new d(t),this.nextStates.push(e),t.repeat&&e.nextStates.push(e),e)},match:function(t){for(var e,n,r,i=this.nextStates,o=[],a=0,s=i.length;s>a;a++)e=i[a],n=e.charSpec,\"undefined\"!=typeof(r=n.validChars)?-1!==r.indexOf(t)&&o.push(e):\"undefined\"!=typeof(r=n.invalidChars)&&-1===r.indexOf(t)&&o.push(e);return o}};var N=Object.create||function(t){function e(){}return e.prototype=t,new e};y.prototype=N({splice:Array.prototype.splice,slice:Array.prototype.slice,push:Array.prototype.push,length:0,queryParams:null});var G=function(){this.rootState=new d,this.names={}};G.prototype={add:function(t,e){for(var n,r=this.rootState,i=\"^\",o={},a=[],s=[],h=!0,c=0,u=t.length;u>c;c++){var l=t[c],d=[],v=f(l.path,d,o);s=s.concat(v);for(var g=0,y=v.length;y>g;g++){var m=v[g];m instanceof p||(h=!1,r=r.put({validChars:\"/\"}),i+=\"/\",r=_(r,m),i+=m.regex())}var w={handler:l.handler,names:d};a.push(w)}h&&(r=r.put({validChars:\"/\"}),i+=\"/\"),r.handlers=a,r.regex=new RegExp(i+\"$\"),r.specificity=o,(n=e&&e.as)&&(this.names[n]={segments:s,handlers:a})},handlersFor:function(t){var e=this.names[t],n=[];if(!e)throw new Error(\"There is no route named \"+t);for(var r=0,i=e.handlers.length;i>r;r++)n.push(e.handlers[r]);return n},hasRoute:function(t){return!!this.names[t]},generate:function(t,e){var n=this.names[t],r=\"\";if(!n)throw new Error(\"There is no route named \"+t);for(var i=n.segments,o=0,a=i.length;a>o;o++){var s=i[o];s instanceof p||(r+=\"/\",r+=s.generate(e))}return\"/\"!==r.charAt(0)&&(r=\"/\"+r),e&&e.queryParams&&(r+=this.generateQueryString(e.queryParams)),r},generateQueryString:function(t){var e=[],n=[];for(var r in t)t.hasOwnProperty(r)&&n.push(r);n.sort();for(var i=0,o=n.length;o>i;i++){r=n[i];var a=t[r];if(null!=a){var s=encodeURIComponent(r);if(h(a))for(var c=0,u=a.length;u>c;c++){var l=r+\"[]=\"+encodeURIComponent(a[c]);e.push(l)}else s+=\"=\"+encodeURIComponent(a),e.push(s)}}return 0===e.length?\"\":\"?\"+e.join(\"&\")},parseQueryString:function(t){for(var e=t.split(\"&\"),n={},r=0;r<e.length;r++){var i,o=e[r].split(\"=\"),a=w(o[0]),s=a.length,h=!1;1===o.length?i=\"true\":(s>2&&\"[]\"===a.slice(s-2)&&(h=!0,a=a.slice(0,s-2),n[a]||(n[a]=[])),i=o[1]?w(o[1]):\"\"),h?n[a].push(i):n[a]=i}return n},recognize:function(t,e){B=e;var n,r,i,o,a=[this.rootState],h={},c=!1;if(o=t.indexOf(\"?\"),-1!==o){var u=t.substr(o+1,t.length);t=t.substr(0,o),u&&(h=this.parseQueryString(u))}if(t=s(t)){for(\"/\"!==t.charAt(0)&&(t=\"/\"+t),n=t.length,n>1&&\"/\"===t.charAt(n-1)&&(t=t.substr(0,n-1),c=!0),r=0,i=t.length;i>r&&(a=g(a,t.charAt(r)),a.length);r++);var l=[];for(r=0,i=a.length;i>r;r++)a[r].handlers&&l.push(a[r]);a=v(l);var p=l[0];return p&&p.handlers?(c&&\"(.+)$\"===p.regex.source.slice(-5)&&(t+=\"/\"),m(p,t,h)):void 0}}},G.prototype.map=o;var K=G.prototype.generateQueryString,X={},Y=void 0,J=/#.*$/,W=function(){function t(e){var n=e.root,r=e.onChange;I.classCallCheck(this,t),n&&\"/\"!==n?(\"/\"!==n.charAt(0)&&(n=\"/\"+n),this.root=n.replace(/\\/$/,\"\"),this.rootRE=new RegExp(\"^\\\\\"+this.root)):this.root=null,this.onChange=r;var i=document.querySelector(\"base\");this.base=i&&i.getAttribute(\"href\")}return t.prototype.start=function(){var t=this;this.listener=function(e){var n=location.pathname+location.search;t.root&&(n=n.replace(t.rootRE,\"\")),t.onChange(n,e&&e.state,location.hash)},window.addEventListener(\"popstate\",this.listener),this.listener()},t.prototype.stop=function(){window.removeEventListener(\"popstate\",this.listener)},t.prototype.go=function(t,e,n){var r=this.formatPath(t,n);e?history.replaceState({},\"\",r):(history.replaceState({pos:{x:window.pageXOffset,y:window.pageYOffset}},\"\",location.href),history.pushState({},\"\",r));var i=t.match(J),o=i&&i[0];t=r.replace(J,\"\").replace(this.rootRE,\"\"),this.onChange(t,null,o)},t.prototype.formatPath=function(t,e){return\"/\"===t.charAt(0)?this.root?this.root+\"/\"+t.replace(/^\\//,\"\"):t:C(this.base||location.pathname,t,e)},t}(),Z=function(){function t(e){var n=e.hashbang,r=e.onChange;I.classCallCheck(this,t),this.hashbang=n,this.onChange=r}return t.prototype.start=function(){var t=this;this.listener=function(){var e=location.hash,n=e.replace(/^#!?/,\"\");\"/\"!==n.charAt(0)&&(n=\"/\"+n);var r=t.formatPath(n);if(r!==e)return void location.replace(r);var i=location.search&&e.indexOf(\"?\")>-1?\"&\"+location.search.slice(1):location.search;t.onChange(e.replace(/^#!?/,\"\")+i)},window.addEventListener(\"hashchange\",this.listener),this.listener()},t.prototype.stop=function(){window.removeEventListener(\"hashchange\",this.listener)},t.prototype.go=function(t,e,n){t=this.formatPath(t,n),e?location.replace(t):location.hash=t},t.prototype.formatPath=function(t,e){var n=\"/\"===t.charAt(0),r=\"#\"+(this.hashbang?\"!\":\"\");return n?r+t:r+C(location.hash.replace(/^#!?/,\"\"),t,e)},t}(),tt=function(){function t(e){var n=e.onChange;I.classCallCheck(this,t),this.onChange=n,this.currentPath=\"/\"}return t.prototype.start=function(){this.onChange(\"/\")},t.prototype.stop=function(){},t.prototype.go=function(t,e,n){t=this.currentPath=this.formatPath(t,n),this.onChange(t)},t.prototype.formatPath=function(t,e){return\"/\"===t.charAt(0)?t:C(this.currentPath,t,e)},t}(),et=function(){function t(e,n,r){I.classCallCheck(this,t),this.router=e,this.to=n,this.from=r,this.next=null,this.aborted=!1,this.done=!1}return t.prototype.abort=function(){if(!this.aborted){this.aborted=!0;var t=!this.from.path&&\"/\"===this.to.path;t||this.router.replace(this.from.path||\"/\")}},t.prototype.redirect=function(t){this.aborted||(this.aborted=!0,\"string\"==typeof t?t=$(t,this.to.params,this.to.query):(t.params=t.params||this.to.params,t.query=t.query||this.to.query),this.router.replace(t))},t.prototype.start=function(t){for(var e=this,n=[],r=this.router._rootView;r;)n.unshift(r),r=r.childView;var i=n.slice().reverse(),o=this.activateQueue=D(this.to.matched).map(function(t){return t.handler}),a=void 0,s=void 0;for(a=0;a<i.length&&x(i[a],o[a],e);a++);a>0&&(s=i.slice(0,a),n=i.slice(a).reverse(),o=o.slice(a)),e.runQueue(n,E,function(){e.runQueue(o,V,function(){e.runQueue(n,S,function(){if(e.router._onTransitionValidated(e),s&&s.forEach(function(t){return O(t,e)}),n.length){var r=n[n.length-1],i=s?s.length:0;P(r,e,i,t)}else t()})})})},t.prototype.runQueue=function(t,e,n){function r(o){o>=t.length?n():e(t[o],i,function(){r(o+1)})}var i=this;r(0)},t.prototype.callHook=function(t,e,n){var r=arguments.length<=3||void 0===arguments[3]?{}:arguments[3],i=r.expectBoolean,o=void 0===i?!1:i,a=r.postActivate,s=void 0===a?!1:a,h=r.processData,c=r.cleanup,u=this,l=!1,p=function(){c&&c(),u.abort()},f=function(t){if(s?v():p(),t&&!u.router._suppress)throw b(\"Uncaught error during transition: \"),t instanceof Error?t:new Error(t)},d=function(t){try{f(t)}catch(e){setTimeout(function(){throw e},0)}},v=function(){return l?void b(\"transition.next() should be called only once.\"):(l=!0,u.aborted?void(c&&c()):void(n&&n()))},g=function(e){\"boolean\"==typeof e?e?v():p():R(e)?e.then(function(t){t?v():p()},d):t.length||v()},y=function(t){var e=void 0;try{e=h(t)}catch(n){return f(n)}R(e)?e.then(v,d):v()},m={to:u.to,from:u.from,abort:p,next:h?y:v,redirect:function(){u.redirect.apply(u,arguments)}},_=void 0;try{_=t.call(e,m)}catch(w){return f(w)}o?g(_):R(_)?h?_.then(y,d):_.then(v,d):h&&M(_)?y(_):t.length||v()},t.prototype.callHooks=function(t,e,n,r){var i=this;Array.isArray(t)?this.runQueue(t,function(t,n,o){i.aborted||i.callHook(t,e,o,r)},n):this.callHook(t,e,n,r)},t}(),nt=/^(component|subRoutes|fullPath)$/,rt=function ut(t,e){var n=this;I.classCallCheck(this,ut);var r=e._recognizer.recognize(t);r&&([].forEach.call(r,function(t){for(var e in t.handler)nt.test(e)||(n[e]=t.handler[e])}),this.query=r.queryParams,this.params=[].reduce.call(r,function(t,e){if(e.params)for(var n in e.params)t[n]=e.params[n];return t},{})),this.path=t,this.matched=r||e._notFoundHandler,Object.defineProperty(this,\"router\",{enumerable:!1,value:e}),Object.freeze(this)},it=/\\/$/,ot=/[-.*+?^${}()|[\\]\\/\\\\]/g,at=/\\?.*$/,st={\"abstract\":tt,hash:Z,html5:W},ht=void 0,ct=function(){function t(){var e=this,n=arguments.length<=0||void 0===arguments[0]?{}:arguments[0],r=n.hashbang,i=void 0===r?!0:r,o=n[\"abstract\"],a=void 0===o?!1:o,s=n.history,h=void 0===s?!1:s,c=n.saveScrollPosition,u=void 0===c?!1:c,l=n.transitionOnLoad,p=void 0===l?!1:l,f=n.suppressTransitionError,d=void 0===f?!1:f,v=n.root,g=void 0===v?null:v,y=n.linkActiveClass,m=void 0===y?\"v-link-active\":y;if(I.classCallCheck(this,t),!t.installed)throw new Error(\"Please install the Router with Vue.use() before creating an instance.\");this.app=null,this._children=[],this._recognizer=new G,this._guardRecognizer=new G,this._started=!1,this._startCb=null,this._currentRoute={},this._currentTransition=null,this._previousTransition=null,this._notFoundHandler=null,this._notFoundRedirect=null,this._beforeEachHooks=[],this._afterEachHooks=[],this._rendered=!1,this._transitionOnLoad=p,this._root=g,this._abstract=a,this._hashbang=i;var _=\"undefined\"!=typeof window&&window.history&&window.history.pushState;this._history=h&&_,this._historyFallback=h&&!_;var w=ht.util.inBrowser;this.mode=!w||this._abstract?\"abstract\":this._history?\"html5\":\"hash\";var b=st[this.mode];this.history=new b({root:g,hashbang:this._hashbang,onChange:function(t,n,r){e._match(t,n,r)}}),this._saveScrollPosition=u,this._linkActiveClass=m,this._suppress=d}return t.prototype.map=function(t){for(var e in t)this.on(e,t[e]);return this},t.prototype.on=function(t,e){return\"*\"===t?this._notFound(e):this._addRoute(t,e,[]),this},t.prototype.redirect=function(t){for(var e in t)this._addRedirect(e,t[e]);return this},t.prototype.alias=function(t){for(var e in t)this._addAlias(e,t[e]);return this},t.prototype.beforeEach=function(t){return this._beforeEachHooks.push(t),this},t.prototype.afterEach=function(t){return this._afterEachHooks.push(t),this},t.prototype.go=function(t){var e=!1,n=!1;ht.util.isObject(t)&&(e=t.replace,n=t.append),t=this.stringifyPath(t),t&&this.history.go(t,e,n)},t.prototype.replace=function(t){\"string\"==typeof t&&(t={path:t}),t.replace=!0,this.go(t)},t.prototype.start=function(t,e,n){if(this._started)return void b(\"already started.\");if(this._started=!0,this._startCb=n,!this.app){if(!t||!e)throw new Error(\"Must start vue-router with a component and a root container.\");if(t instanceof ht)throw new Error(\"Must start vue-router with a component, not a Vue instance.\");this._appContainer=e;var r=this._appConstructor=\"function\"==typeof t?t:ht.extend(t);r.options.name=r.options.name||\"RouterApp\"}if(this._historyFallback){var i=window.location,o=new W({root:this._root}),a=o.root?i.pathname.replace(o.rootRE,\"\"):i.pathname;if(a&&\"/\"!==a)return void i.assign((o.root||\"\")+\"/\"+this.history.formatPath(a)+i.search)}this.history.start()},t.prototype.stop=function(){this.history.stop(),this._started=!1},t.prototype.stringifyPath=function(t){var e=\"\";if(t&&\"object\"==typeof t){if(t.name){var n=ht.util.extend,r=this._currentTransition&&this._currentTransition.to.params,i=t.params||{},o=r?n(n({},r),i):i;e=encodeURI(this._recognizer.generate(t.name,o))}else t.path&&(e=encodeURI(t.path));if(t.query){var a=this._recognizer.generateQueryString(t.query);e+=e.indexOf(\"?\")>-1?\"&\"+a.slice(1):a}}else e=encodeURI(t?t+\"\":\"\");return e},t.prototype._addRoute=function(t,e,n){if(F(t,e),e.path=t,e.fullPath=(n.reduce(function(t,e){return t+e.path},\"\")+t).replace(\"//\",\"/\"),n.push({path:t,handler:e}),this._recognizer.add(n,{as:e.name}),e.subRoutes)for(var r in e.subRoutes)this._addRoute(r,e.subRoutes[r],n.slice())},t.prototype._notFound=function(t){F(\"*\",t),this._notFoundHandler=[{handler:t}]},t.prototype._addRedirect=function(t,e){\"*\"===t?this._notFoundRedirect=e:this._addGuard(t,e,this.replace)},t.prototype._addAlias=function(t,e){this._addGuard(t,e,this._match)},t.prototype._addGuard=function(t,e,n){var r=this;this._guardRecognizer.add([{path:t,handler:function(t,i){var o=$(e,t.params,i);n.call(r,o)}}])},t.prototype._checkGuard=function(t){var e=this._guardRecognizer.recognize(t,!0);return e?(e[0].handler(e[0],e.queryParams),!0):this._notFoundRedirect&&(e=this._recognizer.recognize(t),!e)?(this.replace(this._notFoundRedirect),!0):void 0},t.prototype._match=function(t,e,n){var r=this;if(!this._checkGuard(t)){var i=this._currentRoute,o=this._currentTransition;if(o){if(o.to.path===t)return;if(i.path===t)return o.aborted=!0,void(this._currentTransition=this._prevTransition);o.aborted=!0}var a=new rt(t,this),s=new et(this,a,i);this._prevTransition=o,this._currentTransition=s,this.app||!function(){var t=r;r.app=new r._appConstructor({el:r._appContainer,created:function(){this.$router=t},_meta:{$route:a}})}();var h=this._beforeEachHooks,c=function(){s.start(function(){r._postTransition(a,e,n)})};h.length?s.runQueue(h,function(t,e,n){s===r._currentTransition&&s.callHook(t,null,n,{expectBoolean:!0})},c):c(),!this._rendered&&this._startCb&&this._startCb.call(null),this._rendered=!0}},t.prototype._onTransitionValidated=function(t){var e=this._currentRoute=t.to;this.app.$route!==e&&(this.app.$route=e,this._children.forEach(function(t){t.$route=e})),this._afterEachHooks.length&&this._afterEachHooks.forEach(function(e){return e.call(null,{to:t.to,from:t.from})}),this._currentTransition.done=!0},t.prototype._postTransition=function(t,e,n){var r=e&&e.pos;r&&this._saveScrollPosition?ht.nextTick(function(){window.scrollTo(r.x,r.y)}):n&&ht.nextTick(function(){var t=document.getElementById(n.slice(1));t&&window.scrollTo(window.scrollX,t.offsetTop)})},t}();return ct.installed=!1,ct.install=function(t){return ct.installed?void b(\"already installed.\"):(ht=t,q(ht),z(ht),Q(ht),X.Vue=ht,void(ct.installed=!0))},\"undefined\"!=typeof window&&window.Vue&&window.Vue.use(ct),ct});\n\n/***/ },\n\n/***/ 14:\n/*!****************************************!*\\\n  !*** ./lib/vue-touch/vue-touch.min.js ***!\n  \\****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t!function(){function e(e){return e.charAt(0).toUpperCase()+e.slice(1)}function t(e){var t=e.direction;if(\"string\"==typeof t){var i=\"DIRECTION_\"+t.toUpperCase();o.indexOf(t)>-1&&r.hasOwnProperty(i)?e.direction=r[i]:console.warn(\"[vue-touch] invalid direction: \"+t)}}var i={},r= true?__webpack_require__(/*! hammerjs */ 7):window.Hammer,n=[\"tap\",\"pan\",\"pinch\",\"press\",\"rotate\",\"swipe\"],o=[\"up\",\"down\",\"left\",\"right\",\"horizontal\",\"vertical\",\"all\"],a={};if(!r)throw new Error(\"[vue-touch] cannot locate Hammer.js.\");i.config={},i.install=function(o){o.directive(\"touch\",{isFn:!0,acceptStatement:!0,priority:o.directive(\"on\").priority,bind:function(){this.el.hammer||(this.el.hammer=new r.Manager(this.el));var o=this.mc=this.el.hammer,s=this.arg;s||console.warn(\"[vue-touch] event type argument is required.\");var h,c;if(a[s]){var u=a[s];h=u.type,c=new(r[e(h)])(u),c.recognizeWith(o.recognizers),o.add(c)}else{for(var d=0;d<n.length;d++)if(0===s.indexOf(n[d])){h=n[d];break}if(!h)return void console.warn(\"[vue-touch] invalid event type: \"+s);c=o.get(h),c||(c=new(r[e(h)]),c.recognizeWith(o.recognizers),o.add(c));var f=i.config[h];f&&(t(f),c.set(f));var l=this.el.hammerOptions&&this.el.hammerOptions[h];l&&(t(l),c.set(l))}this.recognizer=c},update:function(e){var t=this.mc,i=this.arg;this.handler&&t.off(i,this.handler),\"function\"!=typeof e?console.warn(\"[vue-touch] invalid handler function for v-touch: \"+this.arg+'=\"'+this.descriptor.raw):t.on(i,this.handler=e)},unbind:function(){this.mc.off(this.arg,this.handler),Object.keys(this.mc.handlers).length||(this.mc.destroy(),this.el.hammer=null)}}),o.directive(\"touch-options\",{priority:o.directive(\"on\").priority+1,update:function(e){var t=this.el.hammerOptions||(this.el.hammerOptions={});this.arg?t[this.arg]=e:console.warn(\"[vue-touch] recognizer type argument for v-touch-options is required.\")}})},i.registerCustomEvent=function(e,t){t.event=e,a[e]=t}, true?module.exports=i:\"function\"==typeof define&&define.amd?define([],function(){return i}):window.Vue&&(window.VueTouch=i,Vue.use(i))}();\r\n\n\n/***/ },\n\n/***/ 15:\n/*!***********************************!*\\\n  !*** ./lib/vuex/dist/vuex.min.js ***!\n  \\***********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\r\n\t * Vuex v0.8.2\r\n\t * (c) 2016 Evan You\r\n\t * Released under the MIT License.\r\n\t */\r\n\t!function(t,e){ true?module.exports=e():\"function\"==typeof define&&define.amd?define(e):t.Vuex=e()}(this,function(){\"use strict\";function t(t){return t.reduce(function(t,e){return Object.keys(e).forEach(function(n){var o=t[n];o?Array.isArray(o)?o.push(e[n]):t[n]=[t[n],e[n]]:t[n]=e[n]}),t},{})}function e(t){if(Array.isArray(t))return t.map(e);if(t&&\"object\"===(\"undefined\"==typeof t?\"undefined\":a(t))){for(var n={},o=Object.keys(t),i=0,r=o.length;i<r;i++){var s=o[i];n[s]=e(t[s])}return n}return t}function n(t){if(!f){var e=function(){},n=t.$watch(e,e);f=t._watchers[0].constructor,n()}return f}function o(t){return d||(d=t._data.__ob__.dep.constructor),d}function i(t){function e(){var t=this.$options,e=t.store,n=t.vuex;if(e?this.$store=e:t.parent&&t.parent.$store&&(this.$store=t.parent.$store),n){this.$store||console.warn(\"[vuex] store not injected. make sure to provide the store option in your root component.\");var o=n.state,i=n.actions,a=n.getters;if(o&&!a&&(console.warn(\"[vuex] vuex.state option will been deprecated in 1.0. Use vuex.getters instead.\"),a=o),a){t.computed=t.computed||{};for(var u in a)r(this,u,a[u])}if(i){t.methods=t.methods||{};for(var c in i)t.methods[c]=s(this.$store,i[c],c)}}}function i(){throw new Error(\"vuex getter properties are read-only.\")}function r(t,e,n){\"function\"!=typeof n?console.warn(\"[vuex] Getter bound to key 'vuex.getters.\"+e+\"' is not a function.\"):Object.defineProperty(t,e,{enumerable:!0,configurable:!0,get:a(t.$store,n),set:i})}function a(t,e){var i=t._getterCacheId;if(e[i])return e[i];var r=t._vm,a=n(r),s=o(r),u=new a(r,function(t){return e(t.state)},null,{lazy:!0}),c=function(){return u.dirty&&u.evaluate(),s.target&&u.depend(),u.value};return e[i]=c,c}function s(t,e,n){return\"function\"!=typeof e&&console.warn(\"[vuex] Action bound to key 'vuex.actions.\"+n+\"' is not a function.\"),function(){for(var n=arguments.length,o=Array(n),i=0;i<n;i++)o[i]=arguments[i];return e.call.apply(e,[this,t].concat(o))}}var u=Number(t.version.split(\".\")[0]);if(u>=2){var c=t.config._lifecycleHooks.indexOf(\"init\")>-1;t.mixin(c?{init:e}:{beforeCreate:e})}else!function(){var n=t.prototype._init;t.prototype._init=function(){var t=arguments.length<=0||void 0===arguments[0]?{}:arguments[0];t.init=t.init?[e].concat(t.init):e,n.call(this,t)}}();var f=t.config.optionMergeStrategies.computed;t.config.optionMergeStrategies.vuex=function(t,e){return t?e?{getters:f(t.getters,e.getters),state:f(t.state,e.state),actions:f(t.actions,e.actions)}:t:e}}function r(t){return p?void console.warn(\"[vuex] already installed. Vue.use(Vuex) should be called only once.\"):(p=t,void i(p))}var a=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol?\"symbol\":typeof t},s=function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")},u=function(){function t(t,e){for(var n=0;n<e.length;n++){var o=e[n];o.enumerable=o.enumerable||!1,o.configurable=!0,\"value\"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o)}}return function(e,n,o){return n&&t(e.prototype,n),o&&t(e,o),e}}(),c=function(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++)n[e]=t[e];return n}return Array.from(t)},f=void 0,d=void 0,h=\"undefined\"!=typeof window&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__,l={onInit:function(t,e){h&&(h.emit(\"vuex:init\",e),h.on(\"vuex:travel-to-state\",function(t){e._dispatching=!0,e._vm.state=t,e._dispatching=!1}))},onMutation:function(t,e){h&&h.emit(\"vuex:mutation\",t,e)}},p=void 0,v=0,y=function(){function o(){var t=this,e=arguments.length<=0||void 0===arguments[0]?{}:arguments[0],n=e.state,i=void 0===n?{}:n,r=e.mutations,a=void 0===r?{}:r,u=e.modules,c=void 0===u?{}:u,f=e.middlewares,d=void 0===f?[]:f,h=e.strict,l=void 0!==h&&h;s(this,o),this._getterCacheId=\"vuex_store_\"+v++,this._dispatching=!1,this._rootMutations=this._mutations=a,this._modules=c;var y=this.dispatch;if(this.dispatch=function(){for(var e=arguments.length,n=Array(e),o=0;o<e;o++)n[o]=arguments[o];y.apply(t,n)},!p)throw new Error(\"[vuex] must call Vue.use(Vuex) before creating a store instance.\");var _=p.config.silent;p.config.silent=!0,this._vm=new p({data:{state:i}}),p.config.silent=_,this._setupModuleState(i,c),this._setupModuleMutations(c),this._setupMiddlewares(d,i),l&&this._setupMutationCheck()}return u(o,[{key:\"dispatch\",value:function(t){for(var e=arguments.length,n=Array(e>1?e-1:0),o=1;o<e;o++)n[o-1]=arguments[o];var i=!1;\"object\"===(\"undefined\"==typeof t?\"undefined\":a(t))&&t.type&&1===arguments.length&&(n=[t.payload],t.silent&&(i=!0),t=t.type);var r=this._mutations[t],s=this.state;r?(this._dispatching=!0,Array.isArray(r)?r.forEach(function(t){return t.apply(void 0,[s].concat(c(n)))}):r.apply(void 0,[s].concat(c(n))),this._dispatching=!1,i||this._applyMiddlewares(t,n)):console.warn(\"[vuex] Unknown mutation: \"+t)}},{key:\"watch\",value:function(t,e,n){var o=this;return\"function\"!=typeof t?void console.error(\"Vuex store.watch only accepts function.\"):this._vm.$watch(function(){return t(o.state)},e,n)}},{key:\"hotUpdate\",value:function(){var t=arguments.length<=0||void 0===arguments[0]?{}:arguments[0],e=t.mutations,n=t.modules;this._rootMutations=this._mutations=e||this._rootMutations,this._setupModuleMutations(n||this._modules)}},{key:\"_setupModuleState\",value:function(t,e){Object.keys(e).forEach(function(n){p.set(t,n,e[n].state||{})})}},{key:\"_setupModuleMutations\",value:function(e){var n=this._modules,o=[this._rootMutations];Object.keys(e).forEach(function(t){n[t]=e[t]}),Object.keys(n).forEach(function(t){var e=n[t];if(e&&e.mutations){var i={};Object.keys(e.mutations).forEach(function(n){var o=e.mutations[n];i[n]=function(e){for(var n=arguments.length,i=Array(n>1?n-1:0),r=1;r<n;r++)i[r-1]=arguments[r];o.apply(void 0,[e[t]].concat(i))}}),o.push(i)}}),this._mutations=t(o)}},{key:\"_setupMutationCheck\",value:function(){var t=this,e=n(this._vm);new e(this._vm,\"state\",function(){if(!t._dispatching)throw new Error(\"[vuex] Do not mutate vuex store state outside mutation handlers.\")},{deep:!0,sync:!0})}},{key:\"_setupMiddlewares\",value:function(t,n){var o=this;this._middlewares=[l].concat(t),this._needSnapshots=t.some(function(t){return t.snapshot}),this._needSnapshots&&console.log(\"[vuex] One or more of your middlewares are taking state snapshots for each mutation. Make sure to use them only during development.\");var i=this._prevSnapshot=this._needSnapshots?e(n):null;this._middlewares.forEach(function(t){t.onInit&&t.onInit(t.snapshot?i:n,o)})}},{key:\"_applyMiddlewares\",value:function(t,n){var o=this,i=this.state,r=this._prevSnapshot,a=void 0,s=void 0;this._needSnapshots&&(a=this._prevSnapshot=e(i),s=e(n)),this._middlewares.forEach(function(e){e.onMutation&&(e.snapshot?e.onMutation({type:t,payload:s},a,r,o):e.onMutation({type:t,payload:n},i,o))})}},{key:\"state\",get:function(){return this._vm.state},set:function(t){throw new Error(\"[vuex] Vuex root state is read only.\")}}]),o}();\"undefined\"!=typeof window&&window.Vue&&r(window.Vue);var _={Store:y,install:r};return _});\n\n/***/ },\n\n/***/ 16:\n/*!*****************************************************************************************************************************************************!*\\\n  !*** ./~/babel-loader?presets[]=es2015&plugins[]=transform-runtime&comments=false!./~/vue-loader/lib/selector.js?type=script&index=0!./src/app.vue ***!\n  \\*****************************************************************************************************************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _store = __webpack_require__(/*! ./vuex/store.js */ 70);\n\t\n\tvar _store2 = _interopRequireDefault(_store);\n\t\n\tvar _webviewtestShare = __webpack_require__(/*! ./js/webviewtestShare.js */ 2);\n\t\n\tvar _webviewtestShare2 = _interopRequireDefault(_webviewtestShare);\n\t\n\tvar _shareInfo = __webpack_require__(/*! ./js/shareInfo.js */ 5);\n\t\n\tvar _shareInfo2 = _interopRequireDefault(_shareInfo);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar GetQueryString = function GetQueryString(name) {\n\t\tvar reg = new RegExp(\"(^|&)\" + name + \"=([^&]*)(&|$)\", \"i\");\n\t\tvar r = window.location.search.substr(1).match(reg);\n\t\tif (r != null) return r[2];\n\t\treturn null;\n\t};\n\t\n\tmodule.exports = {\n\t\tstore: _store2.default,\n\t\tdata: function data() {\n\t\t\treturn {\n\t\t\t\tshowDialog: false,\n\t\t\t\tmsg: ''\n\t\t\t};\n\t\t},\n\t\tmethods: {\n\t\t\tSSS: function SSS() {\n\t\t\t\tthis.showDialog = !this.showDialog;\n\t\t\t},\n\t\t\thideDialog: function hideDialog() {\n\t\t\t\tundefined.showDialog = false;\n\t\t\t}\n\t\n\t\t},\n\t\tevents: {\n\t\t\t'showDialog': function showDialog(message) {\n\t\t\t\tthis.showDialog = true;\n\t\t\t\tthis.msg = message;\n\t\t\t\tvar self = this;\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tself.showDialog = false;\n\t\t\t\t}, 900);\n\t\t\t}\n\t\t},\n\t\tcreated: function created() {\n\t\t\tvar data = {\n\t\t\t\tuid: GetQueryString('uid'),\n\t\t\t\turl: window.location.href\n\t\t\t};\n\t\n\t\t\tthis.$http.post('../user-info.csp', data, {\n\t\t\t\temulateJSON: true\n\t\t\t}).then(function (response) {\n\t\t\t\tvar obj = response.json();\n\t\t\t\tvar u = navigator.userAgent;\n\t\t\t\tvar isAndroid = u.indexOf('Android') > -1 || u.indexOf('Linux') > -1;\n\t\t\t\tvar isIOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/);\n\t\t\t\tif (isAndroid) {\n\t\t\t\t\tobj.ymMoney = obj.ymMoneyAdr;\n\t\t\t\t} else if (isIOS) {\n\t\t\t\t\tobj.ymMoney = obj.ymMoneyAdr + obj.ymMoneyIph;\n\t\t\t\t} else {\n\t\t\t\t\tobj.ymMoney = obj.ymMoneyAdr + obj.ymMoneyIph;\n\t\t\t\t}\n\t\n\t\t\t\t_store2.default.dispatch('GETINFO', obj);\n\t\t\t}, function (response) {\n\t\t\t\tconsole.log(\"error\");\n\t\t\t});\n\t\n\t\t\t_store2.default.dispatch('GETUID', GetQueryString('uid'));\n\t\t},\n\t\tready: function ready() {\n\t\t\t_webviewtestShare2.default.test(1);\n\t\t\t_shareInfo2.default.share();\n\t\t}\n\t};\n\n/***/ },\n\n/***/ 27:\n/*!**************************************************************************************************************************************************************************************************************************************************!*\\\n  !*** ./~/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"extract\":true,\"remove\":true}!./~/vue-style-loader!./~/css-loader!./~/vue-loader/lib/style-rewriter.js!./~/sass-loader!./~/vue-loader/lib/selector.js?type=style&index=0!./src/app.vue ***!\n  \\**************************************************************************************************************************************************************************************************************************************************/\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ },\n\n/***/ 42:\n/*!**********************************************************************************************!*\\\n  !*** ./~/vue-html-loader!./~/vue-loader/lib/selector.js?type=template&index=0!./src/app.vue ***!\n  \\**********************************************************************************************/\n/***/ function(module, exports) {\n\n\tmodule.exports = \" <div id=main> <router-view transition=change> </router-view> <div class=dialog transition=bounce v-show=showDialog> {{msg}} </div> </div> \";\n\n/***/ },\n\n/***/ 53:\n/*!******************************************************!*\\\n  !*** ./~/vue-infinite-scroll/vue-infinite-scroll.js ***!\n  \\******************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function (global, factory) {\n\t   true ? factory(exports) :\n\t  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t  (factory((global.infiniteScroll = global.infiniteScroll || {})));\n\t}(this, function (exports) { 'use strict';\n\t\n\t  var throttle = function throttle(fn, delay) {\n\t    var now, lastExec, timer, context, args; //eslint-disable-line\n\t\n\t    var execute = function execute() {\n\t      fn.apply(context, args);\n\t      lastExec = now;\n\t    };\n\t\n\t    return function () {\n\t      context = this;\n\t      args = arguments;\n\t\n\t      now = Date.now();\n\t\n\t      if (timer) {\n\t        clearTimeout(timer);\n\t        timer = null;\n\t      }\n\t\n\t      if (lastExec) {\n\t        var diff = delay - (now - lastExec);\n\t        if (diff < 0) {\n\t          execute();\n\t        } else {\n\t          timer = setTimeout(function () {\n\t            execute();\n\t          }, diff);\n\t        }\n\t      } else {\n\t        execute();\n\t      }\n\t    };\n\t  };\n\t\n\t  var getScrollTop = function getScrollTop(element) {\n\t    if (element === window) {\n\t      return Math.max(window.pageYOffset || 0, document.documentElement.scrollTop);\n\t    }\n\t\n\t    return element.scrollTop;\n\t  };\n\t\n\t  var getComputedStyle = document.defaultView.getComputedStyle;\n\t\n\t  var getScrollEventTarget = function getScrollEventTarget(element) {\n\t    var currentNode = element;\n\t    // bugfix, see http://w3help.org/zh-cn/causes/SD9013 and http://stackoverflow.com/questions/17016740/onscroll-function-is-not-working-for-chrome\n\t    while (currentNode && currentNode.tagName !== 'HTML' && currentNode.tagName !== 'BODY' && currentNode.nodeType === 1) {\n\t      var overflowY = getComputedStyle(currentNode).overflowY;\n\t      if (overflowY === 'scroll' || overflowY === 'auto') {\n\t        return currentNode;\n\t      }\n\t      currentNode = currentNode.parentNode;\n\t    }\n\t    return window;\n\t  };\n\t\n\t  var getVisibleHeight = function getVisibleHeight(element) {\n\t    if (element === window) {\n\t      return document.documentElement.clientHeight;\n\t    }\n\t\n\t    return element.clientHeight;\n\t  };\n\t\n\t  var getElementTop = function getElementTop(element) {\n\t    if (element === window) {\n\t      return getScrollTop(window);\n\t    }\n\t    return element.getBoundingClientRect().top + getScrollTop(window);\n\t  };\n\t\n\t  var isAttached = function isAttached(element) {\n\t    var currentNode = element.parentNode;\n\t    while (currentNode) {\n\t      if (currentNode.tagName === 'HTML') {\n\t        return true;\n\t      }\n\t      if (currentNode.nodeType === 11) {\n\t        return false;\n\t      }\n\t      currentNode = currentNode.parentNode;\n\t    }\n\t    return false;\n\t  };\n\t\n\t  var infiniteScroll = {\n\t    doBind: function doBind() {\n\t      if (this.binded) return; // eslint-disable-line\n\t      this.binded = true;\n\t\n\t      var directive = this;\n\t      var element = directive.el;\n\t\n\t      directive.scrollEventTarget = getScrollEventTarget(element);\n\t      directive.scrollListener = throttle(directive.doCheck.bind(directive), 200);\n\t      directive.scrollEventTarget.addEventListener('scroll', directive.scrollListener);\n\t\n\t      var disabledExpr = element.getAttribute('infinite-scroll-disabled');\n\t      var disabled = false;\n\t\n\t      if (disabledExpr) {\n\t        this.vm.$watch(disabledExpr, function (value) {\n\t          directive.disabled = value;\n\t          if (!value && directive.immediateCheck) {\n\t            directive.doCheck();\n\t          }\n\t        });\n\t        disabled = Boolean(directive.vm.$get(disabledExpr));\n\t      }\n\t      directive.disabled = disabled;\n\t\n\t      var distanceExpr = element.getAttribute('infinite-scroll-distance');\n\t      var distance = 0;\n\t      if (distanceExpr) {\n\t        distance = Number(directive.vm.$get(distanceExpr));\n\t        if (isNaN(distance)) {\n\t          distance = 0;\n\t        }\n\t      }\n\t      directive.distance = distance;\n\t\n\t      var immediateCheckExpr = element.getAttribute('infinite-scroll-immediate-check');\n\t      var immediateCheck = true;\n\t      if (immediateCheckExpr) {\n\t        immediateCheck = Boolean(directive.vm.$get(immediateCheckExpr));\n\t      }\n\t      directive.immediateCheck = immediateCheck;\n\t\n\t      if (immediateCheck) {\n\t        directive.doCheck();\n\t      }\n\t\n\t      var eventName = element.getAttribute('infinite-scroll-listen-for-event');\n\t      if (eventName) {\n\t        directive.vm.$on(eventName, function () {\n\t          directive.doCheck();\n\t        });\n\t      }\n\t    },\n\t\n\t    doCheck: function doCheck(force) {\n\t      var scrollEventTarget = this.scrollEventTarget;\n\t      var element = this.el;\n\t      var distance = this.distance;\n\t\n\t      if (force !== true && this.disabled) return; //eslint-disable-line\n\t      var viewportScrollTop = getScrollTop(scrollEventTarget);\n\t      var viewportBottom = viewportScrollTop + getVisibleHeight(scrollEventTarget);\n\t\n\t      var shouldTrigger = false;\n\t\n\t      if (scrollEventTarget === element) {\n\t        shouldTrigger = scrollEventTarget.scrollHeight - viewportBottom <= distance;\n\t      } else {\n\t        var elementBottom = getElementTop(element) - getElementTop(scrollEventTarget) + element.offsetHeight + viewportScrollTop;\n\t\n\t        shouldTrigger = viewportBottom + distance >= elementBottom;\n\t      }\n\t\n\t      if (shouldTrigger && this.expression) {\n\t        this.vm.$get(this.expression);\n\t      }\n\t    },\n\t\n\t    bind: function bind() {\n\t      var directive = this;\n\t      var element = this.el;\n\t\n\t      directive.vm.$on('hook:ready', function () {\n\t        if (isAttached(element)) {\n\t          directive.doBind();\n\t        }\n\t      });\n\t\n\t      this.bindTryCount = 0;\n\t\n\t      var tryBind = function tryBind() {\n\t        if (directive.bindTryCount > 10) return; //eslint-disable-line\n\t        directive.bindTryCount++;\n\t        if (isAttached(element)) {\n\t          directive.doBind();\n\t        } else {\n\t          setTimeout(tryBind, 50);\n\t        }\n\t      };\n\t\n\t      tryBind();\n\t    },\n\t\n\t    unbind: function unbind() {\n\t      this.scrollEventTarget.removeEventListener('scroll', this.scrollListener);\n\t    }\n\t  };\n\t\n\t  if (window.Vue) {\n\t    window.infiniteScroll = infiniteScroll;\n\t    Vue.use(install);\n\t  }\n\t\n\t  function install(Vue) {\n\t    Vue.directive('infiniteScroll', infiniteScroll);\n\t  }\n\t\n\t  exports.install = install;\n\t  exports.infiniteScroll = infiniteScroll;\n\t\n\t}));\n\n/***/ },\n\n/***/ 54:\n/*!*********************!*\\\n  !*** ./src/app.vue ***!\n  \\*********************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __vue_script__, __vue_template__\n\t__webpack_require__(/*! !./../~/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"extract\":true,\"remove\":true}!vue-style-loader!css-loader!./../~/vue-loader/lib/style-rewriter.js!sass-loader!./../~/vue-loader/lib/selector.js?type=style&index=0!./app.vue */ 27)\n\t__vue_script__ = __webpack_require__(/*! !babel-loader?presets[]=es2015&plugins[]=transform-runtime&comments=false!./../~/vue-loader/lib/selector.js?type=script&index=0!./app.vue */ 16)\n\t__vue_template__ = __webpack_require__(/*! !vue-html-loader!./../~/vue-loader/lib/selector.js?type=template&index=0!./app.vue */ 42)\n\tmodule.exports = __vue_script__ || {}\n\tif (module.exports.__esModule) module.exports = module.exports.default\n\tif (__vue_template__) {\n\t(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n\t}\n\n\n/***/ },\n\n/***/ 69:\n/*!*********************!*\\\n  !*** ./src/main.js ***!\n  \\*********************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t//vue\r\n\tvar Vue = __webpack_require__(/*! vue */ 8)\r\n\t//\r\n\tvar VueRouter = __webpack_require__(/*! vue-router */ 13);\r\n\t//ajax,\r\n\tvar VueResource = __webpack_require__(/*! vue-resource */ 12);\r\n\t//\r\n\tvar VueTouch = __webpack_require__(/*! vue-touch */ 14); \r\n\tvar hammerjs = __webpack_require__(/*! hammerjs */ 7)\r\n\t\r\n\tvar app = __webpack_require__(/*! ./app.vue */ 54);\r\n\t\r\n\tvar infiniteScroll =  __webpack_require__(/*! vue-infinite-scroll */ 53);\r\n\t//\r\n\tVue.use(VueRouter);\r\n\tVue.use(VueResource);\r\n\tVue.use(VueTouch);\r\n\t\r\n\tVue.use(infiniteScroll);\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t// router\r\n\tvar router = new VueRouter({\r\n\t    // hashbangtrue#!\r\n\t    hashbang: true,\r\n\t    history: false,\r\n\t    saveScrollPosition: false,\r\n\t    transitionOnLoad: true\r\n\t});\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t//\r\n\trouter.map({\r\n\t    //  '/':{                    //\r\n\t    //     component: function (resolve) {\r\n\t    //        require(['./vue/home.vue'],resolve)\r\n\t    //      }\r\n\t    // },\r\n\t    '/home':{\r\n\t        name : 'home',                    //\r\n\t        component: function (resolve) {\r\n\t           __webpack_require__.e/* require */(0, function(__webpack_require__) { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__(/*! ./vue/home.vue */ 58)]; (resolve.apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));}.bind(this))\r\n\t         }\r\n\t    },\r\n\t    '/myshop':{\r\n\t        name: 'myshop',\r\n\t        component: function(resolve) {\r\n\t            __webpack_require__.e/* require */(5, function(__webpack_require__) { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__(/*! ./vue/myshop.vue */ 60)]; (resolve.apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));}.bind(this))//\r\n\t        }\r\n\t    },\r\n\t    '/mysign':{\r\n\t        name: 'mysign',\r\n\t        component: function(resolve){\r\n\t            __webpack_require__.e/* require */(2, function(__webpack_require__) { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__(/*! ./vue/mysign.vue */ 61)]; (resolve.apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));}.bind(this))//\r\n\t        }\r\n\t    },\r\n\t    '/goodDetail':{\r\n\t      name:'goodDetail',\r\n\t      component:function(resolve){\r\n\t            __webpack_require__.e/* require */(1, function(__webpack_require__) { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__(/*! ./vue/goodDetail.vue */ 56)]; (resolve.apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));}.bind(this))\r\n\t      }\r\n\t    },\r\n\t    '/orderDetail':{\r\n\t      component:function(resolve){\r\n\t            __webpack_require__.e/* require */(7, function(__webpack_require__) { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__(/*! ./vue/orderDetail.vue */ 62)]; (resolve.apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));}.bind(this))\r\n\t      }\r\n\t    },\r\n\t    '/infoSure':{\r\n\t      component:function(resolve){\r\n\t            __webpack_require__.e/* require */(4, function(__webpack_require__) { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__(/*! ./vue/infoSure.vue */ 59)]; (resolve.apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));}.bind(this))\r\n\t      }\r\n\t    },\r\n\t    '/saveAddr':{\r\n\t      component:function(resolve){\r\n\t            __webpack_require__.e/* require */(3, function(__webpack_require__) { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__(/*! ./vue/saveAddr.vue */ 64)]; (resolve.apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));}.bind(this))\r\n\t      }\r\n\t    },\r\n\t    '/playRule':{\r\n\t      component:function(resolve){\r\n\t            __webpack_require__.e/* require */(6, function(__webpack_require__) { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__(/*! ./vue/playRule.vue */ 63)]; (resolve.apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));}.bind(this))\r\n\t      }\r\n\t    }\r\n\t});\r\n\t\r\n\trouter.redirect({\r\n\t  '*':'/home'\r\n\t})\r\n\t\r\n\t\r\n\t// router.beforeEach(function(transition){\r\n\t  \r\n\t// })\r\n\t\r\n\t\r\n\t//\r\n\trouter.afterEach(function (transition) {\r\n\t  console.log(': ' + transition.to.path)\r\n\t\r\n\t  var isGoodDetail = transition.to.path.indexOf('/goodDetail') \r\n\t  if (isGoodDetail>=0) {\r\n\t    document.body.scrollTop = 0;\r\n\t  }else{\r\n\t\r\n\t  }\r\n\t  \r\n\t});\r\n\t// \r\n\trouter.start(app,\"#app\");\n\n/***/ },\n\n/***/ 70:\n/*!***************************!*\\\n  !*** ./src/vuex/store.js ***!\n  \\***************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Vue = __webpack_require__(/*! vue */ 8);\r\n\tvar Vuex= __webpack_require__(/*! vuex */ 15);\r\n\t\r\n\t\r\n\t\r\n\tVue.use(Vuex);\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\tmodule.exports =  new Vuex.Store({\r\n\t  state:{\r\n\t  \tuserInfo:{\r\n\t          // success:true,\r\n\t          // ymMoney:1000,\r\n\t          // points:1230,\r\n\t          // continus:3,\r\n\t          // canSign:1\r\n\t        },\r\n\t    goodsInfo:{\r\n\t\r\n\t    },\r\n\t    uid:{\r\n\t\r\n\t    },\r\n\t    address:{\r\n\t\r\n\t    }\r\n\t  },\r\n\t  mutations:{\r\n\t  \tGETINFO:function(state,obj){\r\n\t  \t\tstate.userInfo = obj\r\n\t  \t},\r\n\t    SETGOODINFO:function(state,obj){\r\n\t      state.goodsInfo = obj\r\n\t    },\r\n\t    GETUID:function(state,str){\r\n\t      state.uid = str\r\n\t    },\r\n\t    SETADDRESS:function(state,obj){\r\n\t      state.address = obj\r\n\t    }\r\n\t  }\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t})\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** build.js\n **/","module.exports = {\r\n\t say:function(){\r\n\t \talert(1)\r\n\t },\r\n\t test:function(show){\r\n\r\n          var u = navigator.userAgent;\r\n          var isAndroid = u.indexOf('Android') > -1 || u.indexOf('Linux') > -1;\r\n          var isIOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/);//ios\r\n          //01\r\n          var isHide =   show===0;\r\n\r\n          if (isAndroid) {\r\n            if (window.WebViewJavascriptBridge) {\r\n              window.WebViewJavascriptBridge.callHandler(\r\n                'hideShareBtn',\r\n                {'isHide':isHide},\r\n                function (responseData) {\r\n                 console.log(responseData)\r\n\r\n                }\r\n              )\r\n            } else {\r\n              document.addEventListener(\r\n                'WebViewJavascriptBridgeReady'\r\n                , function () {\r\n                  window.WebViewJavascriptBridge.callHandler(\r\n                     'hideShareBtn',\r\n                     {'isHide':isHide},\r\n                    function (responseData) {\r\n                      console.log(responseData)\r\n \r\n                    }\r\n                  )\r\n                },\r\n                false\r\n              )\r\n            }\r\n          } else if(isIOS) {\r\n\r\n\r\n\r\n\r\n                   // script\r\n                var hasBuildScript=document.getElementById('IOS_shareBtn')\r\n\r\n                if (hasBuildScript) {\r\n                    document.body.removeChild(hasBuildScript)\r\n                    var script = document.createElement('script');\r\n                        script.id = 'IOS_shareBtn';\r\n                        script.innerHTML='try{window.webkit.messageHandlers.hideShareBtnOC.postMessage({isHide: '+isHide+'});}catch(e){}'\r\n\r\n                    document.body.appendChild(script)\r\n                }else{\r\n\r\n                   var script = document.createElement('script');\r\n                       script.id = 'IOS_shareBtn';\r\n                       script.innerHTML='try{window.webkit.messageHandlers.hideShareBtnOC.postMessage({isHide: '+isHide+'});}catch(e){}'\r\n\r\n                   document.body.appendChild(script)\r\n                }\r\n\r\n           \r\n           \r\n\r\n\r\n           \r\n\r\n          \r\n            \r\n\r\n          } else {\r\n\r\n\r\n\r\n          \tconsole.log('pc')\r\n          }\r\n\r\n    }\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/js/webviewtestShare.js\n ** module id = 2\n ** module chunks = 9\n **/","module.exports = {\r\n  say:function(){\r\n    \r\n    document.body.style.background=\"#000\"\r\n  },\r\n\tshare:function(){\r\n\t\tvar u = navigator.userAgent;\r\n        var isAndroid = u.indexOf('Android') > -1 || u.indexOf('Linux') > -1;\r\n        var isIOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/);\r\n\r\n\r\n        var GetQueryString = function (name) {\r\n        var reg = new RegExp(\"(^|&)\" + name + \"=([^&]*)(&|$)\", \"i\");\r\n        var r = window.location.search.substr(1).match(reg);\r\n        if (r != null) return (r[2]);\r\n        return null;\r\n        };\r\n\r\n        if (isAndroid) {\r\n\r\n\r\n           function connectWebViewJavascriptBridge(callback) {\r\n            if (window.WebViewJavascriptBridge) {\r\n                callback(WebViewJavascriptBridge)\r\n            } else {\r\n                document.addEventListener(\r\n                    'WebViewJavascriptBridgeReady'\r\n                    , function() {\r\n                        callback(WebViewJavascriptBridge)\r\n                    },\r\n                    false\r\n                );\r\n            }\r\n        }\r\n\r\n        connectWebViewJavascriptBridge(function(bridge) {\r\n\r\n             bridge.init(function(message, responseCallback) {\r\n\r\n                responseCallback(data);\r\n            });\r\n\r\n            bridge.registerHandler(\"getShareInfo\", function(data, responseCallback) {\r\n                var url = window.location.href \r\n                var repStr = GetQueryString('uid')\r\n                var str = url.replace(repStr,'')    \r\n                var responseData = {\r\n                  'title':'',\r\n                  'brief':'~',\r\n                  'shareUrl':str\r\n                };\r\n                responseCallback(responseData);\r\n            });\r\n        })\r\n        }else if (isIOS){\r\n     \r\n            // script\r\n            \r\n                var url = window.location.href;\r\n                var repStr = GetQueryString('uid')\r\n                var str = url.replace(repStr,'')    \r\n                var responseData = {\r\n                  title:'',\r\n                  brief:'~',\r\n                  shareUrl:str\r\n                };\r\n\r\n            var hasBuildScript=document.getElementById('IOS_shareInfo')\r\n\r\n\r\n\r\n                 if (hasBuildScript) {\r\n\r\n                    document.body.removeChild(hasBuildScript)\r\n                    var script = document.createElement('script');\r\n                        script.id = 'IOS_shareInfo';\r\n                        script.innerHTML='try{window.webkit.messageHandlers.getShareInfoOC.postMessage({title:\"'+responseData.title+'\",brief:\"'+responseData.brief+'\",shareUrl:\"'+responseData.shareUrl+'\"});}catch(e){}'\r\n\r\n                        document.body.appendChild(script)\r\n                    }else{\r\n\r\n                       var script = document.createElement('script');\r\n                           script.id = 'IOS_shareInfo';\r\n                           script.innerHTML='try{window.webkit.messageHandlers.getShareInfoOC.postMessage({title:\"'+responseData.title+'\",brief:\"'+responseData.brief+'\",shareUrl:\"'+responseData.shareUrl+'\"});}catch(e){}'\r\n\r\n                       document.body.appendChild(script)\r\n                    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n        } else {\r\n        \tconsole.log('pc')\r\n        }\r\n\t}\r\n\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/js/shareInfo.js\n ** module id = 5\n ** module chunks = 9\n **/","/*! Hammer.JS - v2.0.7 - 2016-04-22\r\n * http://hammerjs.github.io/\r\n *\r\n * Copyright (c) 2016 Jorik Tangelder;\r\n * Licensed under the MIT license */\r\n!function(a,b,c,d){\"use strict\";function e(a,b,c){return setTimeout(j(a,c),b)}function f(a,b,c){return Array.isArray(a)?(g(a,c[b],c),!0):!1}function g(a,b,c){var e;if(a)if(a.forEach)a.forEach(b,c);else if(a.length!==d)for(e=0;e<a.length;)b.call(c,a[e],e,a),e++;else for(e in a)a.hasOwnProperty(e)&&b.call(c,a[e],e,a)}function h(b,c,d){var e=\"DEPRECATED METHOD: \"+c+\"\\n\"+d+\" AT \\n\";return function(){var c=new Error(\"get-stack-trace\"),d=c&&c.stack?c.stack.replace(/^[^\\(]+?[\\n$]/gm,\"\").replace(/^\\s+at\\s+/gm,\"\").replace(/^Object.<anonymous>\\s*\\(/gm,\"{anonymous}()@\"):\"Unknown Stack Trace\",f=a.console&&(a.console.warn||a.console.log);return f&&f.call(a.console,e,d),b.apply(this,arguments)}}function i(a,b,c){var d,e=b.prototype;d=a.prototype=Object.create(e),d.constructor=a,d._super=e,c&&la(d,c)}function j(a,b){return function(){return a.apply(b,arguments)}}function k(a,b){return typeof a==oa?a.apply(b?b[0]||d:d,b):a}function l(a,b){return a===d?b:a}function m(a,b,c){g(q(b),function(b){a.addEventListener(b,c,!1)})}function n(a,b,c){g(q(b),function(b){a.removeEventListener(b,c,!1)})}function o(a,b){for(;a;){if(a==b)return!0;a=a.parentNode}return!1}function p(a,b){return a.indexOf(b)>-1}function q(a){return a.trim().split(/\\s+/g)}function r(a,b,c){if(a.indexOf&&!c)return a.indexOf(b);for(var d=0;d<a.length;){if(c&&a[d][c]==b||!c&&a[d]===b)return d;d++}return-1}function s(a){return Array.prototype.slice.call(a,0)}function t(a,b,c){for(var d=[],e=[],f=0;f<a.length;){var g=b?a[f][b]:a[f];r(e,g)<0&&d.push(a[f]),e[f]=g,f++}return c&&(d=b?d.sort(function(a,c){return a[b]>c[b]}):d.sort()),d}function u(a,b){for(var c,e,f=b[0].toUpperCase()+b.slice(1),g=0;g<ma.length;){if(c=ma[g],e=c?c+f:b,e in a)return e;g++}return d}function v(){return ua++}function w(b){var c=b.ownerDocument||b;return c.defaultView||c.parentWindow||a}function x(a,b){var c=this;this.manager=a,this.callback=b,this.element=a.element,this.target=a.options.inputTarget,this.domHandler=function(b){k(a.options.enable,[a])&&c.handler(b)},this.init()}function y(a){var b,c=a.options.inputClass;return new(b=c?c:xa?M:ya?P:wa?R:L)(a,z)}function z(a,b,c){var d=c.pointers.length,e=c.changedPointers.length,f=b&Ea&&d-e===0,g=b&(Ga|Ha)&&d-e===0;c.isFirst=!!f,c.isFinal=!!g,f&&(a.session={}),c.eventType=b,A(a,c),a.emit(\"hammer.input\",c),a.recognize(c),a.session.prevInput=c}function A(a,b){var c=a.session,d=b.pointers,e=d.length;c.firstInput||(c.firstInput=D(b)),e>1&&!c.firstMultiple?c.firstMultiple=D(b):1===e&&(c.firstMultiple=!1);var f=c.firstInput,g=c.firstMultiple,h=g?g.center:f.center,i=b.center=E(d);b.timeStamp=ra(),b.deltaTime=b.timeStamp-f.timeStamp,b.angle=I(h,i),b.distance=H(h,i),B(c,b),b.offsetDirection=G(b.deltaX,b.deltaY);var j=F(b.deltaTime,b.deltaX,b.deltaY);b.overallVelocityX=j.x,b.overallVelocityY=j.y,b.overallVelocity=qa(j.x)>qa(j.y)?j.x:j.y,b.scale=g?K(g.pointers,d):1,b.rotation=g?J(g.pointers,d):0,b.maxPointers=c.prevInput?b.pointers.length>c.prevInput.maxPointers?b.pointers.length:c.prevInput.maxPointers:b.pointers.length,C(c,b);var k=a.element;o(b.srcEvent.target,k)&&(k=b.srcEvent.target),b.target=k}function B(a,b){var c=b.center,d=a.offsetDelta||{},e=a.prevDelta||{},f=a.prevInput||{};b.eventType!==Ea&&f.eventType!==Ga||(e=a.prevDelta={x:f.deltaX||0,y:f.deltaY||0},d=a.offsetDelta={x:c.x,y:c.y}),b.deltaX=e.x+(c.x-d.x),b.deltaY=e.y+(c.y-d.y)}function C(a,b){var c,e,f,g,h=a.lastInterval||b,i=b.timeStamp-h.timeStamp;if(b.eventType!=Ha&&(i>Da||h.velocity===d)){var j=b.deltaX-h.deltaX,k=b.deltaY-h.deltaY,l=F(i,j,k);e=l.x,f=l.y,c=qa(l.x)>qa(l.y)?l.x:l.y,g=G(j,k),a.lastInterval=b}else c=h.velocity,e=h.velocityX,f=h.velocityY,g=h.direction;b.velocity=c,b.velocityX=e,b.velocityY=f,b.direction=g}function D(a){for(var b=[],c=0;c<a.pointers.length;)b[c]={clientX:pa(a.pointers[c].clientX),clientY:pa(a.pointers[c].clientY)},c++;return{timeStamp:ra(),pointers:b,center:E(b),deltaX:a.deltaX,deltaY:a.deltaY}}function E(a){var b=a.length;if(1===b)return{x:pa(a[0].clientX),y:pa(a[0].clientY)};for(var c=0,d=0,e=0;b>e;)c+=a[e].clientX,d+=a[e].clientY,e++;return{x:pa(c/b),y:pa(d/b)}}function F(a,b,c){return{x:b/a||0,y:c/a||0}}function G(a,b){return a===b?Ia:qa(a)>=qa(b)?0>a?Ja:Ka:0>b?La:Ma}function H(a,b,c){c||(c=Qa);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return Math.sqrt(d*d+e*e)}function I(a,b,c){c||(c=Qa);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return 180*Math.atan2(e,d)/Math.PI}function J(a,b){return I(b[1],b[0],Ra)+I(a[1],a[0],Ra)}function K(a,b){return H(b[0],b[1],Ra)/H(a[0],a[1],Ra)}function L(){this.evEl=Ta,this.evWin=Ua,this.pressed=!1,x.apply(this,arguments)}function M(){this.evEl=Xa,this.evWin=Ya,x.apply(this,arguments),this.store=this.manager.session.pointerEvents=[]}function N(){this.evTarget=$a,this.evWin=_a,this.started=!1,x.apply(this,arguments)}function O(a,b){var c=s(a.touches),d=s(a.changedTouches);return b&(Ga|Ha)&&(c=t(c.concat(d),\"identifier\",!0)),[c,d]}function P(){this.evTarget=bb,this.targetIds={},x.apply(this,arguments)}function Q(a,b){var c=s(a.touches),d=this.targetIds;if(b&(Ea|Fa)&&1===c.length)return d[c[0].identifier]=!0,[c,c];var e,f,g=s(a.changedTouches),h=[],i=this.target;if(f=c.filter(function(a){return o(a.target,i)}),b===Ea)for(e=0;e<f.length;)d[f[e].identifier]=!0,e++;for(e=0;e<g.length;)d[g[e].identifier]&&h.push(g[e]),b&(Ga|Ha)&&delete d[g[e].identifier],e++;return h.length?[t(f.concat(h),\"identifier\",!0),h]:void 0}function R(){x.apply(this,arguments);var a=j(this.handler,this);this.touch=new P(this.manager,a),this.mouse=new L(this.manager,a),this.primaryTouch=null,this.lastTouches=[]}function S(a,b){a&Ea?(this.primaryTouch=b.changedPointers[0].identifier,T.call(this,b)):a&(Ga|Ha)&&T.call(this,b)}function T(a){var b=a.changedPointers[0];if(b.identifier===this.primaryTouch){var c={x:b.clientX,y:b.clientY};this.lastTouches.push(c);var d=this.lastTouches,e=function(){var a=d.indexOf(c);a>-1&&d.splice(a,1)};setTimeout(e,cb)}}function U(a){for(var b=a.srcEvent.clientX,c=a.srcEvent.clientY,d=0;d<this.lastTouches.length;d++){var e=this.lastTouches[d],f=Math.abs(b-e.x),g=Math.abs(c-e.y);if(db>=f&&db>=g)return!0}return!1}function V(a,b){this.manager=a,this.set(b)}function W(a){if(p(a,jb))return jb;var b=p(a,kb),c=p(a,lb);return b&&c?jb:b||c?b?kb:lb:p(a,ib)?ib:hb}function X(){if(!fb)return!1;var b={},c=a.CSS&&a.CSS.supports;return[\"auto\",\"manipulation\",\"pan-y\",\"pan-x\",\"pan-x pan-y\",\"none\"].forEach(function(d){b[d]=c?a.CSS.supports(\"touch-action\",d):!0}),b}function Y(a){this.options=la({},this.defaults,a||{}),this.id=v(),this.manager=null,this.options.enable=l(this.options.enable,!0),this.state=nb,this.simultaneous={},this.requireFail=[]}function Z(a){return a&sb?\"cancel\":a&qb?\"end\":a&pb?\"move\":a&ob?\"start\":\"\"}function $(a){return a==Ma?\"down\":a==La?\"up\":a==Ja?\"left\":a==Ka?\"right\":\"\"}function _(a,b){var c=b.manager;return c?c.get(a):a}function aa(){Y.apply(this,arguments)}function ba(){aa.apply(this,arguments),this.pX=null,this.pY=null}function ca(){aa.apply(this,arguments)}function da(){Y.apply(this,arguments),this._timer=null,this._input=null}function ea(){aa.apply(this,arguments)}function fa(){aa.apply(this,arguments)}function ga(){Y.apply(this,arguments),this.pTime=!1,this.pCenter=!1,this._timer=null,this._input=null,this.count=0}function ha(a,b){return b=b||{},b.recognizers=l(b.recognizers,ha.defaults.preset),new ia(a,b)}function ia(a,b){this.options=la({},ha.defaults,b||{}),this.options.inputTarget=this.options.inputTarget||a,this.handlers={},this.session={},this.recognizers=[],this.oldCssProps={},this.element=a,this.input=y(this),this.touchAction=new V(this,this.options.touchAction),ja(this,!0),g(this.options.recognizers,function(a){var b=this.add(new a[0](a[1]));a[2]&&b.recognizeWith(a[2]),a[3]&&b.requireFailure(a[3])},this)}function ja(a,b){var c=a.element;if(c.style){var d;g(a.options.cssProps,function(e,f){d=u(c.style,f),b?(a.oldCssProps[d]=c.style[d],c.style[d]=e):c.style[d]=a.oldCssProps[d]||\"\"}),b||(a.oldCssProps={})}}function ka(a,c){var d=b.createEvent(\"Event\");d.initEvent(a,!0,!0),d.gesture=c,c.target.dispatchEvent(d)}var la,ma=[\"\",\"webkit\",\"Moz\",\"MS\",\"ms\",\"o\"],na=b.createElement(\"div\"),oa=\"function\",pa=Math.round,qa=Math.abs,ra=Date.now;la=\"function\"!=typeof Object.assign?function(a){if(a===d||null===a)throw new TypeError(\"Cannot convert undefined or null to object\");for(var b=Object(a),c=1;c<arguments.length;c++){var e=arguments[c];if(e!==d&&null!==e)for(var f in e)e.hasOwnProperty(f)&&(b[f]=e[f])}return b}:Object.assign;var sa=h(function(a,b,c){for(var e=Object.keys(b),f=0;f<e.length;)(!c||c&&a[e[f]]===d)&&(a[e[f]]=b[e[f]]),f++;return a},\"extend\",\"Use `assign`.\"),ta=h(function(a,b){return sa(a,b,!0)},\"merge\",\"Use `assign`.\"),ua=1,va=/mobile|tablet|ip(ad|hone|od)|android/i,wa=\"ontouchstart\"in a,xa=u(a,\"PointerEvent\")!==d,ya=wa&&va.test(navigator.userAgent),za=\"touch\",Aa=\"pen\",Ba=\"mouse\",Ca=\"kinect\",Da=25,Ea=1,Fa=2,Ga=4,Ha=8,Ia=1,Ja=2,Ka=4,La=8,Ma=16,Na=Ja|Ka,Oa=La|Ma,Pa=Na|Oa,Qa=[\"x\",\"y\"],Ra=[\"clientX\",\"clientY\"];x.prototype={handler:function(){},init:function(){this.evEl&&m(this.element,this.evEl,this.domHandler),this.evTarget&&m(this.target,this.evTarget,this.domHandler),this.evWin&&m(w(this.element),this.evWin,this.domHandler)},destroy:function(){this.evEl&&n(this.element,this.evEl,this.domHandler),this.evTarget&&n(this.target,this.evTarget,this.domHandler),this.evWin&&n(w(this.element),this.evWin,this.domHandler)}};var Sa={mousedown:Ea,mousemove:Fa,mouseup:Ga},Ta=\"mousedown\",Ua=\"mousemove mouseup\";i(L,x,{handler:function(a){var b=Sa[a.type];b&Ea&&0===a.button&&(this.pressed=!0),b&Fa&&1!==a.which&&(b=Ga),this.pressed&&(b&Ga&&(this.pressed=!1),this.callback(this.manager,b,{pointers:[a],changedPointers:[a],pointerType:Ba,srcEvent:a}))}});var Va={pointerdown:Ea,pointermove:Fa,pointerup:Ga,pointercancel:Ha,pointerout:Ha},Wa={2:za,3:Aa,4:Ba,5:Ca},Xa=\"pointerdown\",Ya=\"pointermove pointerup pointercancel\";a.MSPointerEvent&&!a.PointerEvent&&(Xa=\"MSPointerDown\",Ya=\"MSPointerMove MSPointerUp MSPointerCancel\"),i(M,x,{handler:function(a){var b=this.store,c=!1,d=a.type.toLowerCase().replace(\"ms\",\"\"),e=Va[d],f=Wa[a.pointerType]||a.pointerType,g=f==za,h=r(b,a.pointerId,\"pointerId\");e&Ea&&(0===a.button||g)?0>h&&(b.push(a),h=b.length-1):e&(Ga|Ha)&&(c=!0),0>h||(b[h]=a,this.callback(this.manager,e,{pointers:b,changedPointers:[a],pointerType:f,srcEvent:a}),c&&b.splice(h,1))}});var Za={touchstart:Ea,touchmove:Fa,touchend:Ga,touchcancel:Ha},$a=\"touchstart\",_a=\"touchstart touchmove touchend touchcancel\";i(N,x,{handler:function(a){var b=Za[a.type];if(b===Ea&&(this.started=!0),this.started){var c=O.call(this,a,b);b&(Ga|Ha)&&c[0].length-c[1].length===0&&(this.started=!1),this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:za,srcEvent:a})}}});var ab={touchstart:Ea,touchmove:Fa,touchend:Ga,touchcancel:Ha},bb=\"touchstart touchmove touchend touchcancel\";i(P,x,{handler:function(a){var b=ab[a.type],c=Q.call(this,a,b);c&&this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:za,srcEvent:a})}});var cb=2500,db=25;i(R,x,{handler:function(a,b,c){var d=c.pointerType==za,e=c.pointerType==Ba;if(!(e&&c.sourceCapabilities&&c.sourceCapabilities.firesTouchEvents)){if(d)S.call(this,b,c);else if(e&&U.call(this,c))return;this.callback(a,b,c)}},destroy:function(){this.touch.destroy(),this.mouse.destroy()}});var eb=u(na.style,\"touchAction\"),fb=eb!==d,gb=\"compute\",hb=\"auto\",ib=\"manipulation\",jb=\"none\",kb=\"pan-x\",lb=\"pan-y\",mb=X();V.prototype={set:function(a){a==gb&&(a=this.compute()),fb&&this.manager.element.style&&mb[a]&&(this.manager.element.style[eb]=a),this.actions=a.toLowerCase().trim()},update:function(){this.set(this.manager.options.touchAction)},compute:function(){var a=[];return g(this.manager.recognizers,function(b){k(b.options.enable,[b])&&(a=a.concat(b.getTouchAction()))}),W(a.join(\" \"))},preventDefaults:function(a){var b=a.srcEvent,c=a.offsetDirection;if(this.manager.session.prevented)return void b.preventDefault();var d=this.actions,e=p(d,jb)&&!mb[jb],f=p(d,lb)&&!mb[lb],g=p(d,kb)&&!mb[kb];if(e){var h=1===a.pointers.length,i=a.distance<2,j=a.deltaTime<250;if(h&&i&&j)return}return g&&f?void 0:e||f&&c&Na||g&&c&Oa?this.preventSrc(b):void 0},preventSrc:function(a){this.manager.session.prevented=!0,a.preventDefault()}};var nb=1,ob=2,pb=4,qb=8,rb=qb,sb=16,tb=32;Y.prototype={defaults:{},set:function(a){return la(this.options,a),this.manager&&this.manager.touchAction.update(),this},recognizeWith:function(a){if(f(a,\"recognizeWith\",this))return this;var b=this.simultaneous;return a=_(a,this),b[a.id]||(b[a.id]=a,a.recognizeWith(this)),this},dropRecognizeWith:function(a){return f(a,\"dropRecognizeWith\",this)?this:(a=_(a,this),delete this.simultaneous[a.id],this)},requireFailure:function(a){if(f(a,\"requireFailure\",this))return this;var b=this.requireFail;return a=_(a,this),-1===r(b,a)&&(b.push(a),a.requireFailure(this)),this},dropRequireFailure:function(a){if(f(a,\"dropRequireFailure\",this))return this;a=_(a,this);var b=r(this.requireFail,a);return b>-1&&this.requireFail.splice(b,1),this},hasRequireFailures:function(){return this.requireFail.length>0},canRecognizeWith:function(a){return!!this.simultaneous[a.id]},emit:function(a){function b(b){c.manager.emit(b,a)}var c=this,d=this.state;qb>d&&b(c.options.event+Z(d)),b(c.options.event),a.additionalEvent&&b(a.additionalEvent),d>=qb&&b(c.options.event+Z(d))},tryEmit:function(a){return this.canEmit()?this.emit(a):void(this.state=tb)},canEmit:function(){for(var a=0;a<this.requireFail.length;){if(!(this.requireFail[a].state&(tb|nb)))return!1;a++}return!0},recognize:function(a){var b=la({},a);return k(this.options.enable,[this,b])?(this.state&(rb|sb|tb)&&(this.state=nb),this.state=this.process(b),void(this.state&(ob|pb|qb|sb)&&this.tryEmit(b))):(this.reset(),void(this.state=tb))},process:function(a){},getTouchAction:function(){},reset:function(){}},i(aa,Y,{defaults:{pointers:1},attrTest:function(a){var b=this.options.pointers;return 0===b||a.pointers.length===b},process:function(a){var b=this.state,c=a.eventType,d=b&(ob|pb),e=this.attrTest(a);return d&&(c&Ha||!e)?b|sb:d||e?c&Ga?b|qb:b&ob?b|pb:ob:tb}}),i(ba,aa,{defaults:{event:\"pan\",threshold:10,pointers:1,direction:Pa},getTouchAction:function(){var a=this.options.direction,b=[];return a&Na&&b.push(lb),a&Oa&&b.push(kb),b},directionTest:function(a){var b=this.options,c=!0,d=a.distance,e=a.direction,f=a.deltaX,g=a.deltaY;return e&b.direction||(b.direction&Na?(e=0===f?Ia:0>f?Ja:Ka,c=f!=this.pX,d=Math.abs(a.deltaX)):(e=0===g?Ia:0>g?La:Ma,c=g!=this.pY,d=Math.abs(a.deltaY))),a.direction=e,c&&d>b.threshold&&e&b.direction},attrTest:function(a){return aa.prototype.attrTest.call(this,a)&&(this.state&ob||!(this.state&ob)&&this.directionTest(a))},emit:function(a){this.pX=a.deltaX,this.pY=a.deltaY;var b=$(a.direction);b&&(a.additionalEvent=this.options.event+b),this._super.emit.call(this,a)}}),i(ca,aa,{defaults:{event:\"pinch\",threshold:0,pointers:2},getTouchAction:function(){return[jb]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.scale-1)>this.options.threshold||this.state&ob)},emit:function(a){if(1!==a.scale){var b=a.scale<1?\"in\":\"out\";a.additionalEvent=this.options.event+b}this._super.emit.call(this,a)}}),i(da,Y,{defaults:{event:\"press\",pointers:1,time:251,threshold:9},getTouchAction:function(){return[hb]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime>b.time;if(this._input=a,!d||!c||a.eventType&(Ga|Ha)&&!f)this.reset();else if(a.eventType&Ea)this.reset(),this._timer=e(function(){this.state=rb,this.tryEmit()},b.time,this);else if(a.eventType&Ga)return rb;return tb},reset:function(){clearTimeout(this._timer)},emit:function(a){this.state===rb&&(a&&a.eventType&Ga?this.manager.emit(this.options.event+\"up\",a):(this._input.timeStamp=ra(),this.manager.emit(this.options.event,this._input)))}}),i(ea,aa,{defaults:{event:\"rotate\",threshold:0,pointers:2},getTouchAction:function(){return[jb]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.rotation)>this.options.threshold||this.state&ob)}}),i(fa,aa,{defaults:{event:\"swipe\",threshold:10,velocity:.3,direction:Na|Oa,pointers:1},getTouchAction:function(){return ba.prototype.getTouchAction.call(this)},attrTest:function(a){var b,c=this.options.direction;return c&(Na|Oa)?b=a.overallVelocity:c&Na?b=a.overallVelocityX:c&Oa&&(b=a.overallVelocityY),this._super.attrTest.call(this,a)&&c&a.offsetDirection&&a.distance>this.options.threshold&&a.maxPointers==this.options.pointers&&qa(b)>this.options.velocity&&a.eventType&Ga},emit:function(a){var b=$(a.offsetDirection);b&&this.manager.emit(this.options.event+b,a),this.manager.emit(this.options.event,a)}}),i(ga,Y,{defaults:{event:\"tap\",pointers:1,taps:1,interval:300,time:250,threshold:9,posThreshold:10},getTouchAction:function(){return[ib]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime<b.time;if(this.reset(),a.eventType&Ea&&0===this.count)return this.failTimeout();if(d&&f&&c){if(a.eventType!=Ga)return this.failTimeout();var g=this.pTime?a.timeStamp-this.pTime<b.interval:!0,h=!this.pCenter||H(this.pCenter,a.center)<b.posThreshold;this.pTime=a.timeStamp,this.pCenter=a.center,h&&g?this.count+=1:this.count=1,this._input=a;var i=this.count%b.taps;if(0===i)return this.hasRequireFailures()?(this._timer=e(function(){this.state=rb,this.tryEmit()},b.interval,this),ob):rb}return tb},failTimeout:function(){return this._timer=e(function(){this.state=tb},this.options.interval,this),tb},reset:function(){clearTimeout(this._timer)},emit:function(){this.state==rb&&(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))}}),ha.VERSION=\"2.0.7\",ha.defaults={domEvents:!1,touchAction:gb,enable:!0,inputTarget:null,inputClass:null,preset:[[ea,{enable:!1}],[ca,{enable:!1},[\"rotate\"]],[fa,{direction:Na}],[ba,{direction:Na},[\"swipe\"]],[ga],[ga,{event:\"doubletap\",taps:2},[\"tap\"]],[da]],cssProps:{userSelect:\"none\",touchSelect:\"none\",touchCallout:\"none\",contentZooming:\"none\",userDrag:\"none\",tapHighlightColor:\"rgba(0,0,0,0)\"}};var ub=1,vb=2;ia.prototype={set:function(a){return la(this.options,a),a.touchAction&&this.touchAction.update(),a.inputTarget&&(this.input.destroy(),this.input.target=a.inputTarget,this.input.init()),this},stop:function(a){this.session.stopped=a?vb:ub},recognize:function(a){var b=this.session;if(!b.stopped){this.touchAction.preventDefaults(a);var c,d=this.recognizers,e=b.curRecognizer;(!e||e&&e.state&rb)&&(e=b.curRecognizer=null);for(var f=0;f<d.length;)c=d[f],b.stopped===vb||e&&c!=e&&!c.canRecognizeWith(e)?c.reset():c.recognize(a),!e&&c.state&(ob|pb|qb)&&(e=b.curRecognizer=c),f++}},get:function(a){if(a instanceof Y)return a;for(var b=this.recognizers,c=0;c<b.length;c++)if(b[c].options.event==a)return b[c];return null},add:function(a){if(f(a,\"add\",this))return this;var b=this.get(a.options.event);return b&&this.remove(b),this.recognizers.push(a),a.manager=this,this.touchAction.update(),a},remove:function(a){if(f(a,\"remove\",this))return this;if(a=this.get(a)){var b=this.recognizers,c=r(b,a);-1!==c&&(b.splice(c,1),this.touchAction.update())}return this},on:function(a,b){if(a!==d&&b!==d){var c=this.handlers;return g(q(a),function(a){c[a]=c[a]||[],c[a].push(b)}),this}},off:function(a,b){if(a!==d){var c=this.handlers;return g(q(a),function(a){b?c[a]&&c[a].splice(r(c[a],b),1):delete c[a]}),this}},emit:function(a,b){this.options.domEvents&&ka(a,b);var c=this.handlers[a]&&this.handlers[a].slice();if(c&&c.length){b.type=a,b.preventDefault=function(){b.srcEvent.preventDefault()};for(var d=0;d<c.length;)c[d](b),d++}},destroy:function(){this.element&&ja(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null}},la(ha,{INPUT_START:Ea,INPUT_MOVE:Fa,INPUT_END:Ga,INPUT_CANCEL:Ha,STATE_POSSIBLE:nb,STATE_BEGAN:ob,STATE_CHANGED:pb,STATE_ENDED:qb,STATE_RECOGNIZED:rb,STATE_CANCELLED:sb,STATE_FAILED:tb,DIRECTION_NONE:Ia,DIRECTION_LEFT:Ja,DIRECTION_RIGHT:Ka,DIRECTION_UP:La,DIRECTION_DOWN:Ma,DIRECTION_HORIZONTAL:Na,DIRECTION_VERTICAL:Oa,DIRECTION_ALL:Pa,Manager:ia,Input:x,TouchAction:V,TouchInput:P,MouseInput:L,PointerEventInput:M,TouchMouseInput:R,SingleTouchInput:N,Recognizer:Y,AttrRecognizer:aa,Tap:ga,Pan:ba,Swipe:fa,Pinch:ca,Rotate:ea,Press:da,on:m,off:n,each:g,merge:ta,extend:sa,assign:la,inherit:i,bindFn:j,prefixed:u});var wb=\"undefined\"!=typeof a?a:\"undefined\"!=typeof self?self:{};wb.Hammer=ha,\"function\"==typeof define&&define.amd?define(function(){return ha}):\"undefined\"!=typeof module&&module.exports?module.exports=ha:a[c]=ha}(window,document,\"Hammer\");\r\n//# sourceMappingURL=hammer.min.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/hammerjs/hammer.min.js\n ** module id = 7\n ** module chunks = 9\n **/","/*!\r\n * Vue.js v1.0.26\r\n * (c) 2016 Evan You\r\n * Released under the MIT License.\r\n */\r\n(function (global, factory) {\r\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\r\n  typeof define === 'function' && define.amd ? define(factory) :\r\n  (global.Vue = factory());\r\n}(this, function () { 'use strict';\r\n\r\n  function set(obj, key, val) {\r\n    if (hasOwn(obj, key)) {\r\n      obj[key] = val;\r\n      return;\r\n    }\r\n    if (obj._isVue) {\r\n      set(obj._data, key, val);\r\n      return;\r\n    }\r\n    var ob = obj.__ob__;\r\n    if (!ob) {\r\n      obj[key] = val;\r\n      return;\r\n    }\r\n    ob.convert(key, val);\r\n    ob.dep.notify();\r\n    if (ob.vms) {\r\n      var i = ob.vms.length;\r\n      while (i--) {\r\n        var vm = ob.vms[i];\r\n        vm._proxy(key);\r\n        vm._digest();\r\n      }\r\n    }\r\n    return val;\r\n  }\r\n\r\n  /**\r\n   * Delete a property and trigger change if necessary.\r\n   *\r\n   * @param {Object} obj\r\n   * @param {String} key\r\n   */\r\n\r\n  function del(obj, key) {\r\n    if (!hasOwn(obj, key)) {\r\n      return;\r\n    }\r\n    delete obj[key];\r\n    var ob = obj.__ob__;\r\n    if (!ob) {\r\n      if (obj._isVue) {\r\n        delete obj._data[key];\r\n        obj._digest();\r\n      }\r\n      return;\r\n    }\r\n    ob.dep.notify();\r\n    if (ob.vms) {\r\n      var i = ob.vms.length;\r\n      while (i--) {\r\n        var vm = ob.vms[i];\r\n        vm._unproxy(key);\r\n        vm._digest();\r\n      }\r\n    }\r\n  }\r\n\r\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\r\n  /**\r\n   * Check whether the object has the property.\r\n   *\r\n   * @param {Object} obj\r\n   * @param {String} key\r\n   * @return {Boolean}\r\n   */\r\n\r\n  function hasOwn(obj, key) {\r\n    return hasOwnProperty.call(obj, key);\r\n  }\r\n\r\n  /**\r\n   * Check if an expression is a literal value.\r\n   *\r\n   * @param {String} exp\r\n   * @return {Boolean}\r\n   */\r\n\r\n  var literalValueRE = /^\\s?(true|false|-?[\\d\\.]+|'[^']*'|\"[^\"]*\")\\s?$/;\r\n\r\n  function isLiteral(exp) {\r\n    return literalValueRE.test(exp);\r\n  }\r\n\r\n  /**\r\n   * Check if a string starts with $ or _\r\n   *\r\n   * @param {String} str\r\n   * @return {Boolean}\r\n   */\r\n\r\n  function isReserved(str) {\r\n    var c = (str + '').charCodeAt(0);\r\n    return c === 0x24 || c === 0x5F;\r\n  }\r\n\r\n  /**\r\n   * Guard text output, make sure undefined outputs\r\n   * empty string\r\n   *\r\n   * @param {*} value\r\n   * @return {String}\r\n   */\r\n\r\n  function _toString(value) {\r\n    return value == null ? '' : value.toString();\r\n  }\r\n\r\n  /**\r\n   * Check and convert possible numeric strings to numbers\r\n   * before setting back to data\r\n   *\r\n   * @param {*} value\r\n   * @return {*|Number}\r\n   */\r\n\r\n  function toNumber(value) {\r\n    if (typeof value !== 'string') {\r\n      return value;\r\n    } else {\r\n      var parsed = Number(value);\r\n      return isNaN(parsed) ? value : parsed;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert string boolean literals into real booleans.\r\n   *\r\n   * @param {*} value\r\n   * @return {*|Boolean}\r\n   */\r\n\r\n  function toBoolean(value) {\r\n    return value === 'true' ? true : value === 'false' ? false : value;\r\n  }\r\n\r\n  /**\r\n   * Strip quotes from a string\r\n   *\r\n   * @param {String} str\r\n   * @return {String | false}\r\n   */\r\n\r\n  function stripQuotes(str) {\r\n    var a = str.charCodeAt(0);\r\n    var b = str.charCodeAt(str.length - 1);\r\n    return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;\r\n  }\r\n\r\n  /**\r\n   * Camelize a hyphen-delmited string.\r\n   *\r\n   * @param {String} str\r\n   * @return {String}\r\n   */\r\n\r\n  var camelizeRE = /-(\\w)/g;\r\n\r\n  function camelize(str) {\r\n    return str.replace(camelizeRE, toUpper);\r\n  }\r\n\r\n  function toUpper(_, c) {\r\n    return c ? c.toUpperCase() : '';\r\n  }\r\n\r\n  /**\r\n   * Hyphenate a camelCase string.\r\n   *\r\n   * @param {String} str\r\n   * @return {String}\r\n   */\r\n\r\n  var hyphenateRE = /([a-z\\d])([A-Z])/g;\r\n\r\n  function hyphenate(str) {\r\n    return str.replace(hyphenateRE, '$1-$2').toLowerCase();\r\n  }\r\n\r\n  /**\r\n   * Converts hyphen/underscore/slash delimitered names into\r\n   * camelized classNames.\r\n   *\r\n   * e.g. my-component => MyComponent\r\n   *      some_else    => SomeElse\r\n   *      some/comp    => SomeComp\r\n   *\r\n   * @param {String} str\r\n   * @return {String}\r\n   */\r\n\r\n  var classifyRE = /(?:^|[-_\\/])(\\w)/g;\r\n\r\n  function classify(str) {\r\n    return str.replace(classifyRE, toUpper);\r\n  }\r\n\r\n  /**\r\n   * Simple bind, faster than native\r\n   *\r\n   * @param {Function} fn\r\n   * @param {Object} ctx\r\n   * @return {Function}\r\n   */\r\n\r\n  function bind(fn, ctx) {\r\n    return function (a) {\r\n      var l = arguments.length;\r\n      return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Convert an Array-like object to a real Array.\r\n   *\r\n   * @param {Array-like} list\r\n   * @param {Number} [start] - start index\r\n   * @return {Array}\r\n   */\r\n\r\n  function toArray(list, start) {\r\n    start = start || 0;\r\n    var i = list.length - start;\r\n    var ret = new Array(i);\r\n    while (i--) {\r\n      ret[i] = list[i + start];\r\n    }\r\n    return ret;\r\n  }\r\n\r\n  /**\r\n   * Mix properties into target object.\r\n   *\r\n   * @param {Object} to\r\n   * @param {Object} from\r\n   */\r\n\r\n  function extend(to, from) {\r\n    var keys = Object.keys(from);\r\n    var i = keys.length;\r\n    while (i--) {\r\n      to[keys[i]] = from[keys[i]];\r\n    }\r\n    return to;\r\n  }\r\n\r\n  /**\r\n   * Quick object check - this is primarily used to tell\r\n   * Objects from primitive values when we know the value\r\n   * is a JSON-compliant type.\r\n   *\r\n   * @param {*} obj\r\n   * @return {Boolean}\r\n   */\r\n\r\n  function isObject(obj) {\r\n    return obj !== null && typeof obj === 'object';\r\n  }\r\n\r\n  /**\r\n   * Strict object type check. Only returns true\r\n   * for plain JavaScript objects.\r\n   *\r\n   * @param {*} obj\r\n   * @return {Boolean}\r\n   */\r\n\r\n  var toString = Object.prototype.toString;\r\n  var OBJECT_STRING = '[object Object]';\r\n\r\n  function isPlainObject(obj) {\r\n    return toString.call(obj) === OBJECT_STRING;\r\n  }\r\n\r\n  /**\r\n   * Array type check.\r\n   *\r\n   * @param {*} obj\r\n   * @return {Boolean}\r\n   */\r\n\r\n  var isArray = Array.isArray;\r\n\r\n  /**\r\n   * Define a property.\r\n   *\r\n   * @param {Object} obj\r\n   * @param {String} key\r\n   * @param {*} val\r\n   * @param {Boolean} [enumerable]\r\n   */\r\n\r\n  function def(obj, key, val, enumerable) {\r\n    Object.defineProperty(obj, key, {\r\n      value: val,\r\n      enumerable: !!enumerable,\r\n      writable: true,\r\n      configurable: true\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Debounce a function so it only gets called after the\r\n   * input stops arriving after the given wait period.\r\n   *\r\n   * @param {Function} func\r\n   * @param {Number} wait\r\n   * @return {Function} - the debounced function\r\n   */\r\n\r\n  function _debounce(func, wait) {\r\n    var timeout, args, context, timestamp, result;\r\n    var later = function later() {\r\n      var last = Date.now() - timestamp;\r\n      if (last < wait && last >= 0) {\r\n        timeout = setTimeout(later, wait - last);\r\n      } else {\r\n        timeout = null;\r\n        result = func.apply(context, args);\r\n        if (!timeout) context = args = null;\r\n      }\r\n    };\r\n    return function () {\r\n      context = this;\r\n      args = arguments;\r\n      timestamp = Date.now();\r\n      if (!timeout) {\r\n        timeout = setTimeout(later, wait);\r\n      }\r\n      return result;\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Manual indexOf because it's slightly faster than\r\n   * native.\r\n   *\r\n   * @param {Array} arr\r\n   * @param {*} obj\r\n   */\r\n\r\n  function indexOf(arr, obj) {\r\n    var i = arr.length;\r\n    while (i--) {\r\n      if (arr[i] === obj) return i;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Make a cancellable version of an async callback.\r\n   *\r\n   * @param {Function} fn\r\n   * @return {Function}\r\n   */\r\n\r\n  function cancellable(fn) {\r\n    var cb = function cb() {\r\n      if (!cb.cancelled) {\r\n        return fn.apply(this, arguments);\r\n      }\r\n    };\r\n    cb.cancel = function () {\r\n      cb.cancelled = true;\r\n    };\r\n    return cb;\r\n  }\r\n\r\n  /**\r\n   * Check if two values are loosely equal - that is,\r\n   * if they are plain objects, do they have the same shape?\r\n   *\r\n   * @param {*} a\r\n   * @param {*} b\r\n   * @return {Boolean}\r\n   */\r\n\r\n  function looseEqual(a, b) {\r\n    /* eslint-disable eqeqeq */\r\n    return a == b || (isObject(a) && isObject(b) ? JSON.stringify(a) === JSON.stringify(b) : false);\r\n    /* eslint-enable eqeqeq */\r\n  }\r\n\r\n  var hasProto = ('__proto__' in {});\r\n\r\n  // Browser environment sniffing\r\n  var inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';\r\n\r\n  // detect devtools\r\n  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\r\n\r\n  // UA sniffing for working around browser-specific quirks\r\n  var UA = inBrowser && window.navigator.userAgent.toLowerCase();\r\n  var isIE = UA && UA.indexOf('trident') > 0;\r\n  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;\r\n  var isAndroid = UA && UA.indexOf('android') > 0;\r\n  var isIos = UA && /(iphone|ipad|ipod|ios)/i.test(UA);\r\n  var iosVersionMatch = isIos && UA.match(/os ([\\d_]+)/);\r\n  var iosVersion = iosVersionMatch && iosVersionMatch[1].split('_');\r\n\r\n  // detecting iOS UIWebView by indexedDB\r\n  var hasMutationObserverBug = iosVersion && Number(iosVersion[0]) >= 9 && Number(iosVersion[1]) >= 3 && !window.indexedDB;\r\n\r\n  var transitionProp = undefined;\r\n  var transitionEndEvent = undefined;\r\n  var animationProp = undefined;\r\n  var animationEndEvent = undefined;\r\n\r\n  // Transition property/event sniffing\r\n  if (inBrowser && !isIE9) {\r\n    var isWebkitTrans = window.ontransitionend === undefined && window.onwebkittransitionend !== undefined;\r\n    var isWebkitAnim = window.onanimationend === undefined && window.onwebkitanimationend !== undefined;\r\n    transitionProp = isWebkitTrans ? 'WebkitTransition' : 'transition';\r\n    transitionEndEvent = isWebkitTrans ? 'webkitTransitionEnd' : 'transitionend';\r\n    animationProp = isWebkitAnim ? 'WebkitAnimation' : 'animation';\r\n    animationEndEvent = isWebkitAnim ? 'webkitAnimationEnd' : 'animationend';\r\n  }\r\n\r\n  /**\r\n   * Defer a task to execute it asynchronously. Ideally this\r\n   * should be executed as a microtask, so we leverage\r\n   * MutationObserver if it's available, and fallback to\r\n   * setTimeout(0).\r\n   *\r\n   * @param {Function} cb\r\n   * @param {Object} ctx\r\n   */\r\n\r\n  var nextTick = (function () {\r\n    var callbacks = [];\r\n    var pending = false;\r\n    var timerFunc;\r\n    function nextTickHandler() {\r\n      pending = false;\r\n      var copies = callbacks.slice(0);\r\n      callbacks = [];\r\n      for (var i = 0; i < copies.length; i++) {\r\n        copies[i]();\r\n      }\r\n    }\r\n\r\n    /* istanbul ignore if */\r\n    if (typeof MutationObserver !== 'undefined' && !hasMutationObserverBug) {\r\n      var counter = 1;\r\n      var observer = new MutationObserver(nextTickHandler);\r\n      var textNode = document.createTextNode(counter);\r\n      observer.observe(textNode, {\r\n        characterData: true\r\n      });\r\n      timerFunc = function () {\r\n        counter = (counter + 1) % 2;\r\n        textNode.data = counter;\r\n      };\r\n    } else {\r\n      // webpack attempts to inject a shim for setImmediate\r\n      // if it is used as a global, so we have to work around that to\r\n      // avoid bundling unnecessary code.\r\n      var context = inBrowser ? window : typeof global !== 'undefined' ? global : {};\r\n      timerFunc = context.setImmediate || setTimeout;\r\n    }\r\n    return function (cb, ctx) {\r\n      var func = ctx ? function () {\r\n        cb.call(ctx);\r\n      } : cb;\r\n      callbacks.push(func);\r\n      if (pending) return;\r\n      pending = true;\r\n      timerFunc(nextTickHandler, 0);\r\n    };\r\n  })();\r\n\r\n  var _Set = undefined;\r\n  /* istanbul ignore if */\r\n  if (typeof Set !== 'undefined' && Set.toString().match(/native code/)) {\r\n    // use native Set when available.\r\n    _Set = Set;\r\n  } else {\r\n    // a non-standard Set polyfill that only works with primitive keys.\r\n    _Set = function () {\r\n      this.set = Object.create(null);\r\n    };\r\n    _Set.prototype.has = function (key) {\r\n      return this.set[key] !== undefined;\r\n    };\r\n    _Set.prototype.add = function (key) {\r\n      this.set[key] = 1;\r\n    };\r\n    _Set.prototype.clear = function () {\r\n      this.set = Object.create(null);\r\n    };\r\n  }\r\n\r\n  function Cache(limit) {\r\n    this.size = 0;\r\n    this.limit = limit;\r\n    this.head = this.tail = undefined;\r\n    this._keymap = Object.create(null);\r\n  }\r\n\r\n  var p = Cache.prototype;\r\n\r\n  /**\r\n   * Put <value> into the cache associated with <key>.\r\n   * Returns the entry which was removed to make room for\r\n   * the new entry. Otherwise undefined is returned.\r\n   * (i.e. if there was enough room already).\r\n   *\r\n   * @param {String} key\r\n   * @param {*} value\r\n   * @return {Entry|undefined}\r\n   */\r\n\r\n  p.put = function (key, value) {\r\n    var removed;\r\n\r\n    var entry = this.get(key, true);\r\n    if (!entry) {\r\n      if (this.size === this.limit) {\r\n        removed = this.shift();\r\n      }\r\n      entry = {\r\n        key: key\r\n      };\r\n      this._keymap[key] = entry;\r\n      if (this.tail) {\r\n        this.tail.newer = entry;\r\n        entry.older = this.tail;\r\n      } else {\r\n        this.head = entry;\r\n      }\r\n      this.tail = entry;\r\n      this.size++;\r\n    }\r\n    entry.value = value;\r\n\r\n    return removed;\r\n  };\r\n\r\n  /**\r\n   * Purge the least recently used (oldest) entry from the\r\n   * cache. Returns the removed entry or undefined if the\r\n   * cache was empty.\r\n   */\r\n\r\n  p.shift = function () {\r\n    var entry = this.head;\r\n    if (entry) {\r\n      this.head = this.head.newer;\r\n      this.head.older = undefined;\r\n      entry.newer = entry.older = undefined;\r\n      this._keymap[entry.key] = undefined;\r\n      this.size--;\r\n    }\r\n    return entry;\r\n  };\r\n\r\n  /**\r\n   * Get and register recent use of <key>. Returns the value\r\n   * associated with <key> or undefined if not in cache.\r\n   *\r\n   * @param {String} key\r\n   * @param {Boolean} returnEntry\r\n   * @return {Entry|*}\r\n   */\r\n\r\n  p.get = function (key, returnEntry) {\r\n    var entry = this._keymap[key];\r\n    if (entry === undefined) return;\r\n    if (entry === this.tail) {\r\n      return returnEntry ? entry : entry.value;\r\n    }\r\n    // HEAD--------------TAIL\r\n    //   <.older   .newer>\r\n    //  <--- add direction --\r\n    //   A  B  C  <D>  E\r\n    if (entry.newer) {\r\n      if (entry === this.head) {\r\n        this.head = entry.newer;\r\n      }\r\n      entry.newer.older = entry.older; // C <-- E.\r\n    }\r\n    if (entry.older) {\r\n      entry.older.newer = entry.newer; // C. --> E\r\n    }\r\n    entry.newer = undefined; // D --x\r\n    entry.older = this.tail; // D. --> E\r\n    if (this.tail) {\r\n      this.tail.newer = entry; // E. <-- D\r\n    }\r\n    this.tail = entry;\r\n    return returnEntry ? entry : entry.value;\r\n  };\r\n\r\n  var cache$1 = new Cache(1000);\r\n  var filterTokenRE = /[^\\s'\"]+|'[^']*'|\"[^\"]*\"/g;\r\n  var reservedArgRE = /^in$|^-?\\d+/;\r\n\r\n  /**\r\n   * Parser state\r\n   */\r\n\r\n  var str;\r\n  var dir;\r\n  var c;\r\n  var prev;\r\n  var i;\r\n  var l;\r\n  var lastFilterIndex;\r\n  var inSingle;\r\n  var inDouble;\r\n  var curly;\r\n  var square;\r\n  var paren;\r\n  /**\r\n   * Push a filter to the current directive object\r\n   */\r\n\r\n  function pushFilter() {\r\n    var exp = str.slice(lastFilterIndex, i).trim();\r\n    var filter;\r\n    if (exp) {\r\n      filter = {};\r\n      var tokens = exp.match(filterTokenRE);\r\n      filter.name = tokens[0];\r\n      if (tokens.length > 1) {\r\n        filter.args = tokens.slice(1).map(processFilterArg);\r\n      }\r\n    }\r\n    if (filter) {\r\n      (dir.filters = dir.filters || []).push(filter);\r\n    }\r\n    lastFilterIndex = i + 1;\r\n  }\r\n\r\n  /**\r\n   * Check if an argument is dynamic and strip quotes.\r\n   *\r\n   * @param {String} arg\r\n   * @return {Object}\r\n   */\r\n\r\n  function processFilterArg(arg) {\r\n    if (reservedArgRE.test(arg)) {\r\n      return {\r\n        value: toNumber(arg),\r\n        dynamic: false\r\n      };\r\n    } else {\r\n      var stripped = stripQuotes(arg);\r\n      var dynamic = stripped === arg;\r\n      return {\r\n        value: dynamic ? arg : stripped,\r\n        dynamic: dynamic\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse a directive value and extract the expression\r\n   * and its filters into a descriptor.\r\n   *\r\n   * Example:\r\n   *\r\n   * \"a + 1 | uppercase\" will yield:\r\n   * {\r\n   *   expression: 'a + 1',\r\n   *   filters: [\r\n   *     { name: 'uppercase', args: null }\r\n   *   ]\r\n   * }\r\n   *\r\n   * @param {String} s\r\n   * @return {Object}\r\n   */\r\n\r\n  function parseDirective(s) {\r\n    var hit = cache$1.get(s);\r\n    if (hit) {\r\n      return hit;\r\n    }\r\n\r\n    // reset parser state\r\n    str = s;\r\n    inSingle = inDouble = false;\r\n    curly = square = paren = 0;\r\n    lastFilterIndex = 0;\r\n    dir = {};\r\n\r\n    for (i = 0, l = str.length; i < l; i++) {\r\n      prev = c;\r\n      c = str.charCodeAt(i);\r\n      if (inSingle) {\r\n        // check single quote\r\n        if (c === 0x27 && prev !== 0x5C) inSingle = !inSingle;\r\n      } else if (inDouble) {\r\n        // check double quote\r\n        if (c === 0x22 && prev !== 0x5C) inDouble = !inDouble;\r\n      } else if (c === 0x7C && // pipe\r\n      str.charCodeAt(i + 1) !== 0x7C && str.charCodeAt(i - 1) !== 0x7C) {\r\n        if (dir.expression == null) {\r\n          // first filter, end of expression\r\n          lastFilterIndex = i + 1;\r\n          dir.expression = str.slice(0, i).trim();\r\n        } else {\r\n          // already has filter\r\n          pushFilter();\r\n        }\r\n      } else {\r\n        switch (c) {\r\n          case 0x22:\r\n            inDouble = true;break; // \"\r\n          case 0x27:\r\n            inSingle = true;break; // '\r\n          case 0x28:\r\n            paren++;break; // (\r\n          case 0x29:\r\n            paren--;break; // )\r\n          case 0x5B:\r\n            square++;break; // [\r\n          case 0x5D:\r\n            square--;break; // ]\r\n          case 0x7B:\r\n            curly++;break; // {\r\n          case 0x7D:\r\n            curly--;break; // }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (dir.expression == null) {\r\n      dir.expression = str.slice(0, i).trim();\r\n    } else if (lastFilterIndex !== 0) {\r\n      pushFilter();\r\n    }\r\n\r\n    cache$1.put(s, dir);\r\n    return dir;\r\n  }\r\n\r\nvar directive = Object.freeze({\r\n    parseDirective: parseDirective\r\n  });\r\n\r\n  var regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\r\n  var cache = undefined;\r\n  var tagRE = undefined;\r\n  var htmlRE = undefined;\r\n  /**\r\n   * Escape a string so it can be used in a RegExp\r\n   * constructor.\r\n   *\r\n   * @param {String} str\r\n   */\r\n\r\n  function escapeRegex(str) {\r\n    return str.replace(regexEscapeRE, '\\\\$&');\r\n  }\r\n\r\n  function compileRegex() {\r\n    var open = escapeRegex(config.delimiters[0]);\r\n    var close = escapeRegex(config.delimiters[1]);\r\n    var unsafeOpen = escapeRegex(config.unsafeDelimiters[0]);\r\n    var unsafeClose = escapeRegex(config.unsafeDelimiters[1]);\r\n    tagRE = new RegExp(unsafeOpen + '((?:.|\\\\n)+?)' + unsafeClose + '|' + open + '((?:.|\\\\n)+?)' + close, 'g');\r\n    htmlRE = new RegExp('^' + unsafeOpen + '((?:.|\\\\n)+?)' + unsafeClose + '$');\r\n    // reset cache\r\n    cache = new Cache(1000);\r\n  }\r\n\r\n  /**\r\n   * Parse a template text string into an array of tokens.\r\n   *\r\n   * @param {String} text\r\n   * @return {Array<Object> | null}\r\n   *               - {String} type\r\n   *               - {String} value\r\n   *               - {Boolean} [html]\r\n   *               - {Boolean} [oneTime]\r\n   */\r\n\r\n  function parseText(text) {\r\n    if (!cache) {\r\n      compileRegex();\r\n    }\r\n    var hit = cache.get(text);\r\n    if (hit) {\r\n      return hit;\r\n    }\r\n    if (!tagRE.test(text)) {\r\n      return null;\r\n    }\r\n    var tokens = [];\r\n    var lastIndex = tagRE.lastIndex = 0;\r\n    var match, index, html, value, first, oneTime;\r\n    /* eslint-disable no-cond-assign */\r\n    while (match = tagRE.exec(text)) {\r\n      /* eslint-enable no-cond-assign */\r\n      index = match.index;\r\n      // push text token\r\n      if (index > lastIndex) {\r\n        tokens.push({\r\n          value: text.slice(lastIndex, index)\r\n        });\r\n      }\r\n      // tag token\r\n      html = htmlRE.test(match[0]);\r\n      value = html ? match[1] : match[2];\r\n      first = value.charCodeAt(0);\r\n      oneTime = first === 42; // *\r\n      value = oneTime ? value.slice(1) : value;\r\n      tokens.push({\r\n        tag: true,\r\n        value: value.trim(),\r\n        html: html,\r\n        oneTime: oneTime\r\n      });\r\n      lastIndex = index + match[0].length;\r\n    }\r\n    if (lastIndex < text.length) {\r\n      tokens.push({\r\n        value: text.slice(lastIndex)\r\n      });\r\n    }\r\n    cache.put(text, tokens);\r\n    return tokens;\r\n  }\r\n\r\n  /**\r\n   * Format a list of tokens into an expression.\r\n   * e.g. tokens parsed from 'a {{b}} c' can be serialized\r\n   * into one single expression as '\"a \" + b + \" c\"'.\r\n   *\r\n   * @param {Array} tokens\r\n   * @param {Vue} [vm]\r\n   * @return {String}\r\n   */\r\n\r\n  function tokensToExp(tokens, vm) {\r\n    if (tokens.length > 1) {\r\n      return tokens.map(function (token) {\r\n        return formatToken(token, vm);\r\n      }).join('+');\r\n    } else {\r\n      return formatToken(tokens[0], vm, true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Format a single token.\r\n   *\r\n   * @param {Object} token\r\n   * @param {Vue} [vm]\r\n   * @param {Boolean} [single]\r\n   * @return {String}\r\n   */\r\n\r\n  function formatToken(token, vm, single) {\r\n    return token.tag ? token.oneTime && vm ? '\"' + vm.$eval(token.value) + '\"' : inlineFilters(token.value, single) : '\"' + token.value + '\"';\r\n  }\r\n\r\n  /**\r\n   * For an attribute with multiple interpolation tags,\r\n   * e.g. attr=\"some-{{thing | filter}}\", in order to combine\r\n   * the whole thing into a single watchable expression, we\r\n   * have to inline those filters. This function does exactly\r\n   * that. This is a bit hacky but it avoids heavy changes\r\n   * to directive parser and watcher mechanism.\r\n   *\r\n   * @param {String} exp\r\n   * @param {Boolean} single\r\n   * @return {String}\r\n   */\r\n\r\n  var filterRE = /[^|]\\|[^|]/;\r\n  function inlineFilters(exp, single) {\r\n    if (!filterRE.test(exp)) {\r\n      return single ? exp : '(' + exp + ')';\r\n    } else {\r\n      var dir = parseDirective(exp);\r\n      if (!dir.filters) {\r\n        return '(' + exp + ')';\r\n      } else {\r\n        return 'this._applyFilters(' + dir.expression + // value\r\n        ',null,' + // oldValue (null for read)\r\n        JSON.stringify(dir.filters) + // filter descriptors\r\n        ',false)'; // write?\r\n      }\r\n    }\r\n  }\r\n\r\nvar text = Object.freeze({\r\n    compileRegex: compileRegex,\r\n    parseText: parseText,\r\n    tokensToExp: tokensToExp\r\n  });\r\n\r\n  var delimiters = ['{{', '}}'];\r\n  var unsafeDelimiters = ['{{{', '}}}'];\r\n\r\n  var config = Object.defineProperties({\r\n\r\n    /**\r\n     * Whether to print debug messages.\r\n     * Also enables stack trace for warnings.\r\n     *\r\n     * @type {Boolean}\r\n     */\r\n\r\n    debug: false,\r\n\r\n    /**\r\n     * Whether to suppress warnings.\r\n     *\r\n     * @type {Boolean}\r\n     */\r\n\r\n    silent: false,\r\n\r\n    /**\r\n     * Whether to use async rendering.\r\n     */\r\n\r\n    async: true,\r\n\r\n    /**\r\n     * Whether to warn against errors caught when evaluating\r\n     * expressions.\r\n     */\r\n\r\n    warnExpressionErrors: true,\r\n\r\n    /**\r\n     * Whether to allow devtools inspection.\r\n     * Disabled by default in production builds.\r\n     */\r\n\r\n    devtools: 'development' !== 'production',\r\n\r\n    /**\r\n     * Internal flag to indicate the delimiters have been\r\n     * changed.\r\n     *\r\n     * @type {Boolean}\r\n     */\r\n\r\n    _delimitersChanged: true,\r\n\r\n    /**\r\n     * List of asset types that a component can own.\r\n     *\r\n     * @type {Array}\r\n     */\r\n\r\n    _assetTypes: ['component', 'directive', 'elementDirective', 'filter', 'transition', 'partial'],\r\n\r\n    /**\r\n     * prop binding modes\r\n     */\r\n\r\n    _propBindingModes: {\r\n      ONE_WAY: 0,\r\n      TWO_WAY: 1,\r\n      ONE_TIME: 2\r\n    },\r\n\r\n    /**\r\n     * Max circular updates allowed in a batcher flush cycle.\r\n     */\r\n\r\n    _maxUpdateCount: 100\r\n\r\n  }, {\r\n    delimiters: { /**\r\n                   * Interpolation delimiters. Changing these would trigger\r\n                   * the text parser to re-compile the regular expressions.\r\n                   *\r\n                   * @type {Array<String>}\r\n                   */\r\n\r\n      get: function get() {\r\n        return delimiters;\r\n      },\r\n      set: function set(val) {\r\n        delimiters = val;\r\n        compileRegex();\r\n      },\r\n      configurable: true,\r\n      enumerable: true\r\n    },\r\n    unsafeDelimiters: {\r\n      get: function get() {\r\n        return unsafeDelimiters;\r\n      },\r\n      set: function set(val) {\r\n        unsafeDelimiters = val;\r\n        compileRegex();\r\n      },\r\n      configurable: true,\r\n      enumerable: true\r\n    }\r\n  });\r\n\r\n  var warn = undefined;\r\n  var formatComponentName = undefined;\r\n\r\n  if ('development' !== 'production') {\r\n    (function () {\r\n      var hasConsole = typeof console !== 'undefined';\r\n\r\n      warn = function (msg, vm) {\r\n        if (hasConsole && !config.silent) {\r\n          console.error('[Vue warn]: ' + msg + (vm ? formatComponentName(vm) : ''));\r\n        }\r\n      };\r\n\r\n      formatComponentName = function (vm) {\r\n        var name = vm._isVue ? vm.$options.name : vm.name;\r\n        return name ? ' (found in component: <' + hyphenate(name) + '>)' : '';\r\n      };\r\n    })();\r\n  }\r\n\r\n  /**\r\n   * Append with transition.\r\n   *\r\n   * @param {Element} el\r\n   * @param {Element} target\r\n   * @param {Vue} vm\r\n   * @param {Function} [cb]\r\n   */\r\n\r\n  function appendWithTransition(el, target, vm, cb) {\r\n    applyTransition(el, 1, function () {\r\n      target.appendChild(el);\r\n    }, vm, cb);\r\n  }\r\n\r\n  /**\r\n   * InsertBefore with transition.\r\n   *\r\n   * @param {Element} el\r\n   * @param {Element} target\r\n   * @param {Vue} vm\r\n   * @param {Function} [cb]\r\n   */\r\n\r\n  function beforeWithTransition(el, target, vm, cb) {\r\n    applyTransition(el, 1, function () {\r\n      before(el, target);\r\n    }, vm, cb);\r\n  }\r\n\r\n  /**\r\n   * Remove with transition.\r\n   *\r\n   * @param {Element} el\r\n   * @param {Vue} vm\r\n   * @param {Function} [cb]\r\n   */\r\n\r\n  function removeWithTransition(el, vm, cb) {\r\n    applyTransition(el, -1, function () {\r\n      remove(el);\r\n    }, vm, cb);\r\n  }\r\n\r\n  /**\r\n   * Apply transitions with an operation callback.\r\n   *\r\n   * @param {Element} el\r\n   * @param {Number} direction\r\n   *                  1: enter\r\n   *                 -1: leave\r\n   * @param {Function} op - the actual DOM operation\r\n   * @param {Vue} vm\r\n   * @param {Function} [cb]\r\n   */\r\n\r\n  function applyTransition(el, direction, op, vm, cb) {\r\n    var transition = el.__v_trans;\r\n    if (!transition ||\r\n    // skip if there are no js hooks and CSS transition is\r\n    // not supported\r\n    !transition.hooks && !transitionEndEvent ||\r\n    // skip transitions for initial compile\r\n    !vm._isCompiled ||\r\n    // if the vm is being manipulated by a parent directive\r\n    // during the parent's compilation phase, skip the\r\n    // animation.\r\n    vm.$parent && !vm.$parent._isCompiled) {\r\n      op();\r\n      if (cb) cb();\r\n      return;\r\n    }\r\n    var action = direction > 0 ? 'enter' : 'leave';\r\n    transition[action](op, cb);\r\n  }\r\n\r\nvar transition = Object.freeze({\r\n    appendWithTransition: appendWithTransition,\r\n    beforeWithTransition: beforeWithTransition,\r\n    removeWithTransition: removeWithTransition,\r\n    applyTransition: applyTransition\r\n  });\r\n\r\n  /**\r\n   * Query an element selector if it's not an element already.\r\n   *\r\n   * @param {String|Element} el\r\n   * @return {Element}\r\n   */\r\n\r\n  function query(el) {\r\n    if (typeof el === 'string') {\r\n      var selector = el;\r\n      el = document.querySelector(el);\r\n      if (!el) {\r\n        'development' !== 'production' && warn('Cannot find element: ' + selector);\r\n      }\r\n    }\r\n    return el;\r\n  }\r\n\r\n  /**\r\n   * Check if a node is in the document.\r\n   * Note: document.documentElement.contains should work here\r\n   * but always returns false for comment nodes in phantomjs,\r\n   * making unit tests difficult. This is fixed by doing the\r\n   * contains() check on the node's parentNode instead of\r\n   * the node itself.\r\n   *\r\n   * @param {Node} node\r\n   * @return {Boolean}\r\n   */\r\n\r\n  function inDoc(node) {\r\n    if (!node) return false;\r\n    var doc = node.ownerDocument.documentElement;\r\n    var parent = node.parentNode;\r\n    return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));\r\n  }\r\n\r\n  /**\r\n   * Get and remove an attribute from a node.\r\n   *\r\n   * @param {Node} node\r\n   * @param {String} _attr\r\n   */\r\n\r\n  function getAttr(node, _attr) {\r\n    var val = node.getAttribute(_attr);\r\n    if (val !== null) {\r\n      node.removeAttribute(_attr);\r\n    }\r\n    return val;\r\n  }\r\n\r\n  /**\r\n   * Get an attribute with colon or v-bind: prefix.\r\n   *\r\n   * @param {Node} node\r\n   * @param {String} name\r\n   * @return {String|null}\r\n   */\r\n\r\n  function getBindAttr(node, name) {\r\n    var val = getAttr(node, ':' + name);\r\n    if (val === null) {\r\n      val = getAttr(node, 'v-bind:' + name);\r\n    }\r\n    return val;\r\n  }\r\n\r\n  /**\r\n   * Check the presence of a bind attribute.\r\n   *\r\n   * @param {Node} node\r\n   * @param {String} name\r\n   * @return {Boolean}\r\n   */\r\n\r\n  function hasBindAttr(node, name) {\r\n    return node.hasAttribute(name) || node.hasAttribute(':' + name) || node.hasAttribute('v-bind:' + name);\r\n  }\r\n\r\n  /**\r\n   * Insert el before target\r\n   *\r\n   * @param {Element} el\r\n   * @param {Element} target\r\n   */\r\n\r\n  function before(el, target) {\r\n    target.parentNode.insertBefore(el, target);\r\n  }\r\n\r\n  /**\r\n   * Insert el after target\r\n   *\r\n   * @param {Element} el\r\n   * @param {Element} target\r\n   */\r\n\r\n  function after(el, target) {\r\n    if (target.nextSibling) {\r\n      before(el, target.nextSibling);\r\n    } else {\r\n      target.parentNode.appendChild(el);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove el from DOM\r\n   *\r\n   * @param {Element} el\r\n   */\r\n\r\n  function remove(el) {\r\n    el.parentNode.removeChild(el);\r\n  }\r\n\r\n  /**\r\n   * Prepend el to target\r\n   *\r\n   * @param {Element} el\r\n   * @param {Element} target\r\n   */\r\n\r\n  function prepend(el, target) {\r\n    if (target.firstChild) {\r\n      before(el, target.firstChild);\r\n    } else {\r\n      target.appendChild(el);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Replace target with el\r\n   *\r\n   * @param {Element} target\r\n   * @param {Element} el\r\n   */\r\n\r\n  function replace(target, el) {\r\n    var parent = target.parentNode;\r\n    if (parent) {\r\n      parent.replaceChild(el, target);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add event listener shorthand.\r\n   *\r\n   * @param {Element} el\r\n   * @param {String} event\r\n   * @param {Function} cb\r\n   * @param {Boolean} [useCapture]\r\n   */\r\n\r\n  function on(el, event, cb, useCapture) {\r\n    el.addEventListener(event, cb, useCapture);\r\n  }\r\n\r\n  /**\r\n   * Remove event listener shorthand.\r\n   *\r\n   * @param {Element} el\r\n   * @param {String} event\r\n   * @param {Function} cb\r\n   */\r\n\r\n  function off(el, event, cb) {\r\n    el.removeEventListener(event, cb);\r\n  }\r\n\r\n  /**\r\n   * For IE9 compat: when both class and :class are present\r\n   * getAttribute('class') returns wrong value...\r\n   *\r\n   * @param {Element} el\r\n   * @return {String}\r\n   */\r\n\r\n  function getClass(el) {\r\n    var classname = el.className;\r\n    if (typeof classname === 'object') {\r\n      classname = classname.baseVal || '';\r\n    }\r\n    return classname;\r\n  }\r\n\r\n  /**\r\n   * In IE9, setAttribute('class') will result in empty class\r\n   * if the element also has the :class attribute; However in\r\n   * PhantomJS, setting `className` does not work on SVG elements...\r\n   * So we have to do a conditional check here.\r\n   *\r\n   * @param {Element} el\r\n   * @param {String} cls\r\n   */\r\n\r\n  function setClass(el, cls) {\r\n    /* istanbul ignore if */\r\n    if (isIE9 && !/svg$/.test(el.namespaceURI)) {\r\n      el.className = cls;\r\n    } else {\r\n      el.setAttribute('class', cls);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add class with compatibility for IE & SVG\r\n   *\r\n   * @param {Element} el\r\n   * @param {String} cls\r\n   */\r\n\r\n  function addClass(el, cls) {\r\n    if (el.classList) {\r\n      el.classList.add(cls);\r\n    } else {\r\n      var cur = ' ' + getClass(el) + ' ';\r\n      if (cur.indexOf(' ' + cls + ' ') < 0) {\r\n        setClass(el, (cur + cls).trim());\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove class with compatibility for IE & SVG\r\n   *\r\n   * @param {Element} el\r\n   * @param {String} cls\r\n   */\r\n\r\n  function removeClass(el, cls) {\r\n    if (el.classList) {\r\n      el.classList.remove(cls);\r\n    } else {\r\n      var cur = ' ' + getClass(el) + ' ';\r\n      var tar = ' ' + cls + ' ';\r\n      while (cur.indexOf(tar) >= 0) {\r\n        cur = cur.replace(tar, ' ');\r\n      }\r\n      setClass(el, cur.trim());\r\n    }\r\n    if (!el.className) {\r\n      el.removeAttribute('class');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract raw content inside an element into a temporary\r\n   * container div\r\n   *\r\n   * @param {Element} el\r\n   * @param {Boolean} asFragment\r\n   * @return {Element|DocumentFragment}\r\n   */\r\n\r\n  function extractContent(el, asFragment) {\r\n    var child;\r\n    var rawContent;\r\n    /* istanbul ignore if */\r\n    if (isTemplate(el) && isFragment(el.content)) {\r\n      el = el.content;\r\n    }\r\n    if (el.hasChildNodes()) {\r\n      trimNode(el);\r\n      rawContent = asFragment ? document.createDocumentFragment() : document.createElement('div');\r\n      /* eslint-disable no-cond-assign */\r\n      while (child = el.firstChild) {\r\n        /* eslint-enable no-cond-assign */\r\n        rawContent.appendChild(child);\r\n      }\r\n    }\r\n    return rawContent;\r\n  }\r\n\r\n  /**\r\n   * Trim possible empty head/tail text and comment\r\n   * nodes inside a parent.\r\n   *\r\n   * @param {Node} node\r\n   */\r\n\r\n  function trimNode(node) {\r\n    var child;\r\n    /* eslint-disable no-sequences */\r\n    while ((child = node.firstChild, isTrimmable(child))) {\r\n      node.removeChild(child);\r\n    }\r\n    while ((child = node.lastChild, isTrimmable(child))) {\r\n      node.removeChild(child);\r\n    }\r\n    /* eslint-enable no-sequences */\r\n  }\r\n\r\n  function isTrimmable(node) {\r\n    return node && (node.nodeType === 3 && !node.data.trim() || node.nodeType === 8);\r\n  }\r\n\r\n  /**\r\n   * Check if an element is a template tag.\r\n   * Note if the template appears inside an SVG its tagName\r\n   * will be in lowercase.\r\n   *\r\n   * @param {Element} el\r\n   */\r\n\r\n  function isTemplate(el) {\r\n    return el.tagName && el.tagName.toLowerCase() === 'template';\r\n  }\r\n\r\n  /**\r\n   * Create an \"anchor\" for performing dom insertion/removals.\r\n   * This is used in a number of scenarios:\r\n   * - fragment instance\r\n   * - v-html\r\n   * - v-if\r\n   * - v-for\r\n   * - component\r\n   *\r\n   * @param {String} content\r\n   * @param {Boolean} persist - IE trashes empty textNodes on\r\n   *                            cloneNode(true), so in certain\r\n   *                            cases the anchor needs to be\r\n   *                            non-empty to be persisted in\r\n   *                            templates.\r\n   * @return {Comment|Text}\r\n   */\r\n\r\n  function createAnchor(content, persist) {\r\n    var anchor = config.debug ? document.createComment(content) : document.createTextNode(persist ? ' ' : '');\r\n    anchor.__v_anchor = true;\r\n    return anchor;\r\n  }\r\n\r\n  /**\r\n   * Find a component ref attribute that starts with $.\r\n   *\r\n   * @param {Element} node\r\n   * @return {String|undefined}\r\n   */\r\n\r\n  var refRE = /^v-ref:/;\r\n\r\n  function findRef(node) {\r\n    if (node.hasAttributes()) {\r\n      var attrs = node.attributes;\r\n      for (var i = 0, l = attrs.length; i < l; i++) {\r\n        var name = attrs[i].name;\r\n        if (refRE.test(name)) {\r\n          return camelize(name.replace(refRE, ''));\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Map a function to a range of nodes .\r\n   *\r\n   * @param {Node} node\r\n   * @param {Node} end\r\n   * @param {Function} op\r\n   */\r\n\r\n  function mapNodeRange(node, end, op) {\r\n    var next;\r\n    while (node !== end) {\r\n      next = node.nextSibling;\r\n      op(node);\r\n      node = next;\r\n    }\r\n    op(end);\r\n  }\r\n\r\n  /**\r\n   * Remove a range of nodes with transition, store\r\n   * the nodes in a fragment with correct ordering,\r\n   * and call callback when done.\r\n   *\r\n   * @param {Node} start\r\n   * @param {Node} end\r\n   * @param {Vue} vm\r\n   * @param {DocumentFragment} frag\r\n   * @param {Function} cb\r\n   */\r\n\r\n  function removeNodeRange(start, end, vm, frag, cb) {\r\n    var done = false;\r\n    var removed = 0;\r\n    var nodes = [];\r\n    mapNodeRange(start, end, function (node) {\r\n      if (node === end) done = true;\r\n      nodes.push(node);\r\n      removeWithTransition(node, vm, onRemoved);\r\n    });\r\n    function onRemoved() {\r\n      removed++;\r\n      if (done && removed >= nodes.length) {\r\n        for (var i = 0; i < nodes.length; i++) {\r\n          frag.appendChild(nodes[i]);\r\n        }\r\n        cb && cb();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a node is a DocumentFragment.\r\n   *\r\n   * @param {Node} node\r\n   * @return {Boolean}\r\n   */\r\n\r\n  function isFragment(node) {\r\n    return node && node.nodeType === 11;\r\n  }\r\n\r\n  /**\r\n   * Get outerHTML of elements, taking care\r\n   * of SVG elements in IE as well.\r\n   *\r\n   * @param {Element} el\r\n   * @return {String}\r\n   */\r\n\r\n  function getOuterHTML(el) {\r\n    if (el.outerHTML) {\r\n      return el.outerHTML;\r\n    } else {\r\n      var container = document.createElement('div');\r\n      container.appendChild(el.cloneNode(true));\r\n      return container.innerHTML;\r\n    }\r\n  }\r\n\r\n  var commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i;\r\n  var reservedTagRE = /^(slot|partial|component)$/i;\r\n\r\n  var isUnknownElement = undefined;\r\n  if ('development' !== 'production') {\r\n    isUnknownElement = function (el, tag) {\r\n      if (tag.indexOf('-') > -1) {\r\n        // http://stackoverflow.com/a/28210364/1070244\r\n        return el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\r\n      } else {\r\n        return (/HTMLUnknownElement/.test(el.toString()) &&\r\n          // Chrome returns unknown for several HTML5 elements.\r\n          // https://code.google.com/p/chromium/issues/detail?id=540526\r\n          // Firefox returns unknown for some \"Interactive elements.\"\r\n          !/^(data|time|rtc|rb|details|dialog|summary)$/.test(tag)\r\n        );\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if an element is a component, if yes return its\r\n   * component id.\r\n   *\r\n   * @param {Element} el\r\n   * @param {Object} options\r\n   * @return {Object|undefined}\r\n   */\r\n\r\n  function checkComponentAttr(el, options) {\r\n    var tag = el.tagName.toLowerCase();\r\n    var hasAttrs = el.hasAttributes();\r\n    if (!commonTagRE.test(tag) && !reservedTagRE.test(tag)) {\r\n      if (resolveAsset(options, 'components', tag)) {\r\n        return { id: tag };\r\n      } else {\r\n        var is = hasAttrs && getIsBinding(el, options);\r\n        if (is) {\r\n          return is;\r\n        } else if ('development' !== 'production') {\r\n          var expectedTag = options._componentNameMap && options._componentNameMap[tag];\r\n          if (expectedTag) {\r\n            warn('Unknown custom element: <' + tag + '> - ' + 'did you mean <' + expectedTag + '>? ' + 'HTML is case-insensitive, remember to use kebab-case in templates.');\r\n          } else if (isUnknownElement(el, tag)) {\r\n            warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.');\r\n          }\r\n        }\r\n      }\r\n    } else if (hasAttrs) {\r\n      return getIsBinding(el, options);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get \"is\" binding from an element.\r\n   *\r\n   * @param {Element} el\r\n   * @param {Object} options\r\n   * @return {Object|undefined}\r\n   */\r\n\r\n  function getIsBinding(el, options) {\r\n    // dynamic syntax\r\n    var exp = el.getAttribute('is');\r\n    if (exp != null) {\r\n      if (resolveAsset(options, 'components', exp)) {\r\n        el.removeAttribute('is');\r\n        return { id: exp };\r\n      }\r\n    } else {\r\n      exp = getBindAttr(el, 'is');\r\n      if (exp != null) {\r\n        return { id: exp, dynamic: true };\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Option overwriting strategies are functions that handle\r\n   * how to merge a parent option value and a child option\r\n   * value into the final value.\r\n   *\r\n   * All strategy functions follow the same signature:\r\n   *\r\n   * @param {*} parentVal\r\n   * @param {*} childVal\r\n   * @param {Vue} [vm]\r\n   */\r\n\r\n  var strats = config.optionMergeStrategies = Object.create(null);\r\n\r\n  /**\r\n   * Helper that recursively merges two data objects together.\r\n   */\r\n\r\n  function mergeData(to, from) {\r\n    var key, toVal, fromVal;\r\n    for (key in from) {\r\n      toVal = to[key];\r\n      fromVal = from[key];\r\n      if (!hasOwn(to, key)) {\r\n        set(to, key, fromVal);\r\n      } else if (isObject(toVal) && isObject(fromVal)) {\r\n        mergeData(toVal, fromVal);\r\n      }\r\n    }\r\n    return to;\r\n  }\r\n\r\n  /**\r\n   * Data\r\n   */\r\n\r\n  strats.data = function (parentVal, childVal, vm) {\r\n    if (!vm) {\r\n      // in a Vue.extend merge, both should be functions\r\n      if (!childVal) {\r\n        return parentVal;\r\n      }\r\n      if (typeof childVal !== 'function') {\r\n        'development' !== 'production' && warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\r\n        return parentVal;\r\n      }\r\n      if (!parentVal) {\r\n        return childVal;\r\n      }\r\n      // when parentVal & childVal are both present,\r\n      // we need to return a function that returns the\r\n      // merged result of both functions... no need to\r\n      // check if parentVal is a function here because\r\n      // it has to be a function to pass previous merges.\r\n      return function mergedDataFn() {\r\n        return mergeData(childVal.call(this), parentVal.call(this));\r\n      };\r\n    } else if (parentVal || childVal) {\r\n      return function mergedInstanceDataFn() {\r\n        // instance merge\r\n        var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;\r\n        var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;\r\n        if (instanceData) {\r\n          return mergeData(instanceData, defaultData);\r\n        } else {\r\n          return defaultData;\r\n        }\r\n      };\r\n    }\r\n  };\r\n\r\n  /**\r\n   * El\r\n   */\r\n\r\n  strats.el = function (parentVal, childVal, vm) {\r\n    if (!vm && childVal && typeof childVal !== 'function') {\r\n      'development' !== 'production' && warn('The \"el\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\r\n      return;\r\n    }\r\n    var ret = childVal || parentVal;\r\n    // invoke the element factory if this is instance merge\r\n    return vm && typeof ret === 'function' ? ret.call(vm) : ret;\r\n  };\r\n\r\n  /**\r\n   * Hooks and param attributes are merged as arrays.\r\n   */\r\n\r\n  strats.init = strats.created = strats.ready = strats.attached = strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy = strats.destroyed = strats.activate = function (parentVal, childVal) {\r\n    return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;\r\n  };\r\n\r\n  /**\r\n   * Assets\r\n   *\r\n   * When a vm is present (instance creation), we need to do\r\n   * a three-way merge between constructor options, instance\r\n   * options and parent options.\r\n   */\r\n\r\n  function mergeAssets(parentVal, childVal) {\r\n    var res = Object.create(parentVal || null);\r\n    return childVal ? extend(res, guardArrayAssets(childVal)) : res;\r\n  }\r\n\r\n  config._assetTypes.forEach(function (type) {\r\n    strats[type + 's'] = mergeAssets;\r\n  });\r\n\r\n  /**\r\n   * Events & Watchers.\r\n   *\r\n   * Events & watchers hashes should not overwrite one\r\n   * another, so we merge them as arrays.\r\n   */\r\n\r\n  strats.watch = strats.events = function (parentVal, childVal) {\r\n    if (!childVal) return parentVal;\r\n    if (!parentVal) return childVal;\r\n    var ret = {};\r\n    extend(ret, parentVal);\r\n    for (var key in childVal) {\r\n      var parent = ret[key];\r\n      var child = childVal[key];\r\n      if (parent && !isArray(parent)) {\r\n        parent = [parent];\r\n      }\r\n      ret[key] = parent ? parent.concat(child) : [child];\r\n    }\r\n    return ret;\r\n  };\r\n\r\n  /**\r\n   * Other object hashes.\r\n   */\r\n\r\n  strats.props = strats.methods = strats.computed = function (parentVal, childVal) {\r\n    if (!childVal) return parentVal;\r\n    if (!parentVal) return childVal;\r\n    var ret = Object.create(null);\r\n    extend(ret, parentVal);\r\n    extend(ret, childVal);\r\n    return ret;\r\n  };\r\n\r\n  /**\r\n   * Default strategy.\r\n   */\r\n\r\n  var defaultStrat = function defaultStrat(parentVal, childVal) {\r\n    return childVal === undefined ? parentVal : childVal;\r\n  };\r\n\r\n  /**\r\n   * Make sure component options get converted to actual\r\n   * constructors.\r\n   *\r\n   * @param {Object} options\r\n   */\r\n\r\n  function guardComponents(options) {\r\n    if (options.components) {\r\n      var components = options.components = guardArrayAssets(options.components);\r\n      var ids = Object.keys(components);\r\n      var def;\r\n      if ('development' !== 'production') {\r\n        var map = options._componentNameMap = {};\r\n      }\r\n      for (var i = 0, l = ids.length; i < l; i++) {\r\n        var key = ids[i];\r\n        if (commonTagRE.test(key) || reservedTagRE.test(key)) {\r\n          'development' !== 'production' && warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);\r\n          continue;\r\n        }\r\n        // record a all lowercase <-> kebab-case mapping for\r\n        // possible custom element case error warning\r\n        if ('development' !== 'production') {\r\n          map[key.replace(/-/g, '').toLowerCase()] = hyphenate(key);\r\n        }\r\n        def = components[key];\r\n        if (isPlainObject(def)) {\r\n          components[key] = Vue.extend(def);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure all props option syntax are normalized into the\r\n   * Object-based format.\r\n   *\r\n   * @param {Object} options\r\n   */\r\n\r\n  function guardProps(options) {\r\n    var props = options.props;\r\n    var i, val;\r\n    if (isArray(props)) {\r\n      options.props = {};\r\n      i = props.length;\r\n      while (i--) {\r\n        val = props[i];\r\n        if (typeof val === 'string') {\r\n          options.props[val] = null;\r\n        } else if (val.name) {\r\n          options.props[val.name] = val;\r\n        }\r\n      }\r\n    } else if (isPlainObject(props)) {\r\n      var keys = Object.keys(props);\r\n      i = keys.length;\r\n      while (i--) {\r\n        val = props[keys[i]];\r\n        if (typeof val === 'function') {\r\n          props[keys[i]] = { type: val };\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Guard an Array-format assets option and converted it\r\n   * into the key-value Object format.\r\n   *\r\n   * @param {Object|Array} assets\r\n   * @return {Object}\r\n   */\r\n\r\n  function guardArrayAssets(assets) {\r\n    if (isArray(assets)) {\r\n      var res = {};\r\n      var i = assets.length;\r\n      var asset;\r\n      while (i--) {\r\n        asset = assets[i];\r\n        var id = typeof asset === 'function' ? asset.options && asset.options.name || asset.id : asset.name || asset.id;\r\n        if (!id) {\r\n          'development' !== 'production' && warn('Array-syntax assets must provide a \"name\" or \"id\" field.');\r\n        } else {\r\n          res[id] = asset;\r\n        }\r\n      }\r\n      return res;\r\n    }\r\n    return assets;\r\n  }\r\n\r\n  /**\r\n   * Merge two option objects into a new one.\r\n   * Core utility used in both instantiation and inheritance.\r\n   *\r\n   * @param {Object} parent\r\n   * @param {Object} child\r\n   * @param {Vue} [vm] - if vm is present, indicates this is\r\n   *                     an instantiation merge.\r\n   */\r\n\r\n  function mergeOptions(parent, child, vm) {\r\n    guardComponents(child);\r\n    guardProps(child);\r\n    if ('development' !== 'production') {\r\n      if (child.propsData && !vm) {\r\n        warn('propsData can only be used as an instantiation option.');\r\n      }\r\n    }\r\n    var options = {};\r\n    var key;\r\n    if (child['extends']) {\r\n      parent = typeof child['extends'] === 'function' ? mergeOptions(parent, child['extends'].options, vm) : mergeOptions(parent, child['extends'], vm);\r\n    }\r\n    if (child.mixins) {\r\n      for (var i = 0, l = child.mixins.length; i < l; i++) {\r\n        var mixin = child.mixins[i];\r\n        var mixinOptions = mixin.prototype instanceof Vue ? mixin.options : mixin;\r\n        parent = mergeOptions(parent, mixinOptions, vm);\r\n      }\r\n    }\r\n    for (key in parent) {\r\n      mergeField(key);\r\n    }\r\n    for (key in child) {\r\n      if (!hasOwn(parent, key)) {\r\n        mergeField(key);\r\n      }\r\n    }\r\n    function mergeField(key) {\r\n      var strat = strats[key] || defaultStrat;\r\n      options[key] = strat(parent[key], child[key], vm, key);\r\n    }\r\n    return options;\r\n  }\r\n\r\n  /**\r\n   * Resolve an asset.\r\n   * This function is used because child instances need access\r\n   * to assets defined in its ancestor chain.\r\n   *\r\n   * @param {Object} options\r\n   * @param {String} type\r\n   * @param {String} id\r\n   * @param {Boolean} warnMissing\r\n   * @return {Object|Function}\r\n   */\r\n\r\n  function resolveAsset(options, type, id, warnMissing) {\r\n    /* istanbul ignore if */\r\n    if (typeof id !== 'string') {\r\n      return;\r\n    }\r\n    var assets = options[type];\r\n    var camelizedId;\r\n    var res = assets[id] ||\r\n    // camelCase ID\r\n    assets[camelizedId = camelize(id)] ||\r\n    // Pascal Case ID\r\n    assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)];\r\n    if ('development' !== 'production' && warnMissing && !res) {\r\n      warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\r\n    }\r\n    return res;\r\n  }\r\n\r\n  var uid$1 = 0;\r\n\r\n  /**\r\n   * A dep is an observable that can have multiple\r\n   * directives subscribing to it.\r\n   *\r\n   * @constructor\r\n   */\r\n  function Dep() {\r\n    this.id = uid$1++;\r\n    this.subs = [];\r\n  }\r\n\r\n  // the current target watcher being evaluated.\r\n  // this is globally unique because there could be only one\r\n  // watcher being evaluated at any time.\r\n  Dep.target = null;\r\n\r\n  /**\r\n   * Add a directive subscriber.\r\n   *\r\n   * @param {Directive} sub\r\n   */\r\n\r\n  Dep.prototype.addSub = function (sub) {\r\n    this.subs.push(sub);\r\n  };\r\n\r\n  /**\r\n   * Remove a directive subscriber.\r\n   *\r\n   * @param {Directive} sub\r\n   */\r\n\r\n  Dep.prototype.removeSub = function (sub) {\r\n    this.subs.$remove(sub);\r\n  };\r\n\r\n  /**\r\n   * Add self as a dependency to the target watcher.\r\n   */\r\n\r\n  Dep.prototype.depend = function () {\r\n    Dep.target.addDep(this);\r\n  };\r\n\r\n  /**\r\n   * Notify all subscribers of a new value.\r\n   */\r\n\r\n  Dep.prototype.notify = function () {\r\n    // stablize the subscriber list first\r\n    var subs = toArray(this.subs);\r\n    for (var i = 0, l = subs.length; i < l; i++) {\r\n      subs[i].update();\r\n    }\r\n  };\r\n\r\n  var arrayProto = Array.prototype;\r\n  var arrayMethods = Object.create(arrayProto)\r\n\r\n  /**\r\n   * Intercept mutating methods and emit events\r\n   */\r\n\r\n  ;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {\r\n    // cache original method\r\n    var original = arrayProto[method];\r\n    def(arrayMethods, method, function mutator() {\r\n      // avoid leaking arguments:\r\n      // http://jsperf.com/closure-with-arguments\r\n      var i = arguments.length;\r\n      var args = new Array(i);\r\n      while (i--) {\r\n        args[i] = arguments[i];\r\n      }\r\n      var result = original.apply(this, args);\r\n      var ob = this.__ob__;\r\n      var inserted;\r\n      switch (method) {\r\n        case 'push':\r\n          inserted = args;\r\n          break;\r\n        case 'unshift':\r\n          inserted = args;\r\n          break;\r\n        case 'splice':\r\n          inserted = args.slice(2);\r\n          break;\r\n      }\r\n      if (inserted) ob.observeArray(inserted);\r\n      // notify change\r\n      ob.dep.notify();\r\n      return result;\r\n    });\r\n  });\r\n\r\n  /**\r\n   * Swap the element at the given index with a new value\r\n   * and emits corresponding event.\r\n   *\r\n   * @param {Number} index\r\n   * @param {*} val\r\n   * @return {*} - replaced element\r\n   */\r\n\r\n  def(arrayProto, '$set', function $set(index, val) {\r\n    if (index >= this.length) {\r\n      this.length = Number(index) + 1;\r\n    }\r\n    return this.splice(index, 1, val)[0];\r\n  });\r\n\r\n  /**\r\n   * Convenience method to remove the element at given index or target element reference.\r\n   *\r\n   * @param {*} item\r\n   */\r\n\r\n  def(arrayProto, '$remove', function $remove(item) {\r\n    /* istanbul ignore if */\r\n    if (!this.length) return;\r\n    var index = indexOf(this, item);\r\n    if (index > -1) {\r\n      return this.splice(index, 1);\r\n    }\r\n  });\r\n\r\n  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);\r\n\r\n  /**\r\n   * By default, when a reactive property is set, the new value is\r\n   * also converted to become reactive. However in certain cases, e.g.\r\n   * v-for scope alias and props, we don't want to force conversion\r\n   * because the value may be a nested value under a frozen data structure.\r\n   *\r\n   * So whenever we want to set a reactive property without forcing\r\n   * conversion on the new value, we wrap that call inside this function.\r\n   */\r\n\r\n  var shouldConvert = true;\r\n\r\n  function withoutConversion(fn) {\r\n    shouldConvert = false;\r\n    fn();\r\n    shouldConvert = true;\r\n  }\r\n\r\n  /**\r\n   * Observer class that are attached to each observed\r\n   * object. Once attached, the observer converts target\r\n   * object's property keys into getter/setters that\r\n   * collect dependencies and dispatches updates.\r\n   *\r\n   * @param {Array|Object} value\r\n   * @constructor\r\n   */\r\n\r\n  function Observer(value) {\r\n    this.value = value;\r\n    this.dep = new Dep();\r\n    def(value, '__ob__', this);\r\n    if (isArray(value)) {\r\n      var augment = hasProto ? protoAugment : copyAugment;\r\n      augment(value, arrayMethods, arrayKeys);\r\n      this.observeArray(value);\r\n    } else {\r\n      this.walk(value);\r\n    }\r\n  }\r\n\r\n  // Instance methods\r\n\r\n  /**\r\n   * Walk through each property and convert them into\r\n   * getter/setters. This method should only be called when\r\n   * value type is Object.\r\n   *\r\n   * @param {Object} obj\r\n   */\r\n\r\n  Observer.prototype.walk = function (obj) {\r\n    var keys = Object.keys(obj);\r\n    for (var i = 0, l = keys.length; i < l; i++) {\r\n      this.convert(keys[i], obj[keys[i]]);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Observe a list of Array items.\r\n   *\r\n   * @param {Array} items\r\n   */\r\n\r\n  Observer.prototype.observeArray = function (items) {\r\n    for (var i = 0, l = items.length; i < l; i++) {\r\n      observe(items[i]);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Convert a property into getter/setter so we can emit\r\n   * the events when the property is accessed/changed.\r\n   *\r\n   * @param {String} key\r\n   * @param {*} val\r\n   */\r\n\r\n  Observer.prototype.convert = function (key, val) {\r\n    defineReactive(this.value, key, val);\r\n  };\r\n\r\n  /**\r\n   * Add an owner vm, so that when $set/$delete mutations\r\n   * happen we can notify owner vms to proxy the keys and\r\n   * digest the watchers. This is only called when the object\r\n   * is observed as an instance's root $data.\r\n   *\r\n   * @param {Vue} vm\r\n   */\r\n\r\n  Observer.prototype.addVm = function (vm) {\r\n    (this.vms || (this.vms = [])).push(vm);\r\n  };\r\n\r\n  /**\r\n   * Remove an owner vm. This is called when the object is\r\n   * swapped out as an instance's $data object.\r\n   *\r\n   * @param {Vue} vm\r\n   */\r\n\r\n  Observer.prototype.removeVm = function (vm) {\r\n    this.vms.$remove(vm);\r\n  };\r\n\r\n  // helpers\r\n\r\n  /**\r\n   * Augment an target Object or Array by intercepting\r\n   * the prototype chain using __proto__\r\n   *\r\n   * @param {Object|Array} target\r\n   * @param {Object} src\r\n   */\r\n\r\n  function protoAugment(target, src) {\r\n    /* eslint-disable no-proto */\r\n    target.__proto__ = src;\r\n    /* eslint-enable no-proto */\r\n  }\r\n\r\n  /**\r\n   * Augment an target Object or Array by defining\r\n   * hidden properties.\r\n   *\r\n   * @param {Object|Array} target\r\n   * @param {Object} proto\r\n   */\r\n\r\n  function copyAugment(target, src, keys) {\r\n    for (var i = 0, l = keys.length; i < l; i++) {\r\n      var key = keys[i];\r\n      def(target, key, src[key]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Attempt to create an observer instance for a value,\r\n   * returns the new observer if successfully observed,\r\n   * or the existing observer if the value already has one.\r\n   *\r\n   * @param {*} value\r\n   * @param {Vue} [vm]\r\n   * @return {Observer|undefined}\r\n   * @static\r\n   */\r\n\r\n  function observe(value, vm) {\r\n    if (!value || typeof value !== 'object') {\r\n      return;\r\n    }\r\n    var ob;\r\n    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\r\n      ob = value.__ob__;\r\n    } else if (shouldConvert && (isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\r\n      ob = new Observer(value);\r\n    }\r\n    if (ob && vm) {\r\n      ob.addVm(vm);\r\n    }\r\n    return ob;\r\n  }\r\n\r\n  /**\r\n   * Define a reactive property on an Object.\r\n   *\r\n   * @param {Object} obj\r\n   * @param {String} key\r\n   * @param {*} val\r\n   */\r\n\r\n  function defineReactive(obj, key, val) {\r\n    var dep = new Dep();\r\n\r\n    var property = Object.getOwnPropertyDescriptor(obj, key);\r\n    if (property && property.configurable === false) {\r\n      return;\r\n    }\r\n\r\n    // cater for pre-defined getter/setters\r\n    var getter = property && property.get;\r\n    var setter = property && property.set;\r\n\r\n    var childOb = observe(val);\r\n    Object.defineProperty(obj, key, {\r\n      enumerable: true,\r\n      configurable: true,\r\n      get: function reactiveGetter() {\r\n        var value = getter ? getter.call(obj) : val;\r\n        if (Dep.target) {\r\n          dep.depend();\r\n          if (childOb) {\r\n            childOb.dep.depend();\r\n          }\r\n          if (isArray(value)) {\r\n            for (var e, i = 0, l = value.length; i < l; i++) {\r\n              e = value[i];\r\n              e && e.__ob__ && e.__ob__.dep.depend();\r\n            }\r\n          }\r\n        }\r\n        return value;\r\n      },\r\n      set: function reactiveSetter(newVal) {\r\n        var value = getter ? getter.call(obj) : val;\r\n        if (newVal === value) {\r\n          return;\r\n        }\r\n        if (setter) {\r\n          setter.call(obj, newVal);\r\n        } else {\r\n          val = newVal;\r\n        }\r\n        childOb = observe(newVal);\r\n        dep.notify();\r\n      }\r\n    });\r\n  }\r\n\r\n\r\n\r\n  var util = Object.freeze({\r\n  \tdefineReactive: defineReactive,\r\n  \tset: set,\r\n  \tdel: del,\r\n  \thasOwn: hasOwn,\r\n  \tisLiteral: isLiteral,\r\n  \tisReserved: isReserved,\r\n  \t_toString: _toString,\r\n  \ttoNumber: toNumber,\r\n  \ttoBoolean: toBoolean,\r\n  \tstripQuotes: stripQuotes,\r\n  \tcamelize: camelize,\r\n  \thyphenate: hyphenate,\r\n  \tclassify: classify,\r\n  \tbind: bind,\r\n  \ttoArray: toArray,\r\n  \textend: extend,\r\n  \tisObject: isObject,\r\n  \tisPlainObject: isPlainObject,\r\n  \tdef: def,\r\n  \tdebounce: _debounce,\r\n  \tindexOf: indexOf,\r\n  \tcancellable: cancellable,\r\n  \tlooseEqual: looseEqual,\r\n  \tisArray: isArray,\r\n  \thasProto: hasProto,\r\n  \tinBrowser: inBrowser,\r\n  \tdevtools: devtools,\r\n  \tisIE: isIE,\r\n  \tisIE9: isIE9,\r\n  \tisAndroid: isAndroid,\r\n  \tisIos: isIos,\r\n  \tiosVersionMatch: iosVersionMatch,\r\n  \tiosVersion: iosVersion,\r\n  \thasMutationObserverBug: hasMutationObserverBug,\r\n  \tget transitionProp () { return transitionProp; },\r\n  \tget transitionEndEvent () { return transitionEndEvent; },\r\n  \tget animationProp () { return animationProp; },\r\n  \tget animationEndEvent () { return animationEndEvent; },\r\n  \tnextTick: nextTick,\r\n  \tget _Set () { return _Set; },\r\n  \tquery: query,\r\n  \tinDoc: inDoc,\r\n  \tgetAttr: getAttr,\r\n  \tgetBindAttr: getBindAttr,\r\n  \thasBindAttr: hasBindAttr,\r\n  \tbefore: before,\r\n  \tafter: after,\r\n  \tremove: remove,\r\n  \tprepend: prepend,\r\n  \treplace: replace,\r\n  \ton: on,\r\n  \toff: off,\r\n  \tsetClass: setClass,\r\n  \taddClass: addClass,\r\n  \tremoveClass: removeClass,\r\n  \textractContent: extractContent,\r\n  \ttrimNode: trimNode,\r\n  \tisTemplate: isTemplate,\r\n  \tcreateAnchor: createAnchor,\r\n  \tfindRef: findRef,\r\n  \tmapNodeRange: mapNodeRange,\r\n  \tremoveNodeRange: removeNodeRange,\r\n  \tisFragment: isFragment,\r\n  \tgetOuterHTML: getOuterHTML,\r\n  \tmergeOptions: mergeOptions,\r\n  \tresolveAsset: resolveAsset,\r\n  \tcheckComponentAttr: checkComponentAttr,\r\n  \tcommonTagRE: commonTagRE,\r\n  \treservedTagRE: reservedTagRE,\r\n  \tget warn () { return warn; }\r\n  });\r\n\r\n  var uid = 0;\r\n\r\n  function initMixin (Vue) {\r\n    /**\r\n     * The main init sequence. This is called for every\r\n     * instance, including ones that are created from extended\r\n     * constructors.\r\n     *\r\n     * @param {Object} options - this options object should be\r\n     *                           the result of merging class\r\n     *                           options and the options passed\r\n     *                           in to the constructor.\r\n     */\r\n\r\n    Vue.prototype._init = function (options) {\r\n      options = options || {};\r\n\r\n      this.$el = null;\r\n      this.$parent = options.parent;\r\n      this.$root = this.$parent ? this.$parent.$root : this;\r\n      this.$children = [];\r\n      this.$refs = {}; // child vm references\r\n      this.$els = {}; // element references\r\n      this._watchers = []; // all watchers as an array\r\n      this._directives = []; // all directives\r\n\r\n      // a uid\r\n      this._uid = uid++;\r\n\r\n      // a flag to avoid this being observed\r\n      this._isVue = true;\r\n\r\n      // events bookkeeping\r\n      this._events = {}; // registered callbacks\r\n      this._eventsCount = {}; // for $broadcast optimization\r\n\r\n      // fragment instance properties\r\n      this._isFragment = false;\r\n      this._fragment = // @type {DocumentFragment}\r\n      this._fragmentStart = // @type {Text|Comment}\r\n      this._fragmentEnd = null; // @type {Text|Comment}\r\n\r\n      // lifecycle state\r\n      this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = this._vForRemoving = false;\r\n      this._unlinkFn = null;\r\n\r\n      // context:\r\n      // if this is a transcluded component, context\r\n      // will be the common parent vm of this instance\r\n      // and its host.\r\n      this._context = options._context || this.$parent;\r\n\r\n      // scope:\r\n      // if this is inside an inline v-for, the scope\r\n      // will be the intermediate scope created for this\r\n      // repeat fragment. this is used for linking props\r\n      // and container directives.\r\n      this._scope = options._scope;\r\n\r\n      // fragment:\r\n      // if this instance is compiled inside a Fragment, it\r\n      // needs to reigster itself as a child of that fragment\r\n      // for attach/detach to work properly.\r\n      this._frag = options._frag;\r\n      if (this._frag) {\r\n        this._frag.children.push(this);\r\n      }\r\n\r\n      // push self into parent / transclusion host\r\n      if (this.$parent) {\r\n        this.$parent.$children.push(this);\r\n      }\r\n\r\n      // merge options.\r\n      options = this.$options = mergeOptions(this.constructor.options, options, this);\r\n\r\n      // set ref\r\n      this._updateRef();\r\n\r\n      // initialize data as empty object.\r\n      // it will be filled up in _initData().\r\n      this._data = {};\r\n\r\n      // call init hook\r\n      this._callHook('init');\r\n\r\n      // initialize data observation and scope inheritance.\r\n      this._initState();\r\n\r\n      // setup event system and option events.\r\n      this._initEvents();\r\n\r\n      // call created hook\r\n      this._callHook('created');\r\n\r\n      // if `el` option is passed, start compilation.\r\n      if (options.el) {\r\n        this.$mount(options.el);\r\n      }\r\n    };\r\n  }\r\n\r\n  var pathCache = new Cache(1000);\r\n\r\n  // actions\r\n  var APPEND = 0;\r\n  var PUSH = 1;\r\n  var INC_SUB_PATH_DEPTH = 2;\r\n  var PUSH_SUB_PATH = 3;\r\n\r\n  // states\r\n  var BEFORE_PATH = 0;\r\n  var IN_PATH = 1;\r\n  var BEFORE_IDENT = 2;\r\n  var IN_IDENT = 3;\r\n  var IN_SUB_PATH = 4;\r\n  var IN_SINGLE_QUOTE = 5;\r\n  var IN_DOUBLE_QUOTE = 6;\r\n  var AFTER_PATH = 7;\r\n  var ERROR = 8;\r\n\r\n  var pathStateMachine = [];\r\n\r\n  pathStateMachine[BEFORE_PATH] = {\r\n    'ws': [BEFORE_PATH],\r\n    'ident': [IN_IDENT, APPEND],\r\n    '[': [IN_SUB_PATH],\r\n    'eof': [AFTER_PATH]\r\n  };\r\n\r\n  pathStateMachine[IN_PATH] = {\r\n    'ws': [IN_PATH],\r\n    '.': [BEFORE_IDENT],\r\n    '[': [IN_SUB_PATH],\r\n    'eof': [AFTER_PATH]\r\n  };\r\n\r\n  pathStateMachine[BEFORE_IDENT] = {\r\n    'ws': [BEFORE_IDENT],\r\n    'ident': [IN_IDENT, APPEND]\r\n  };\r\n\r\n  pathStateMachine[IN_IDENT] = {\r\n    'ident': [IN_IDENT, APPEND],\r\n    '0': [IN_IDENT, APPEND],\r\n    'number': [IN_IDENT, APPEND],\r\n    'ws': [IN_PATH, PUSH],\r\n    '.': [BEFORE_IDENT, PUSH],\r\n    '[': [IN_SUB_PATH, PUSH],\r\n    'eof': [AFTER_PATH, PUSH]\r\n  };\r\n\r\n  pathStateMachine[IN_SUB_PATH] = {\r\n    \"'\": [IN_SINGLE_QUOTE, APPEND],\r\n    '\"': [IN_DOUBLE_QUOTE, APPEND],\r\n    '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],\r\n    ']': [IN_PATH, PUSH_SUB_PATH],\r\n    'eof': ERROR,\r\n    'else': [IN_SUB_PATH, APPEND]\r\n  };\r\n\r\n  pathStateMachine[IN_SINGLE_QUOTE] = {\r\n    \"'\": [IN_SUB_PATH, APPEND],\r\n    'eof': ERROR,\r\n    'else': [IN_SINGLE_QUOTE, APPEND]\r\n  };\r\n\r\n  pathStateMachine[IN_DOUBLE_QUOTE] = {\r\n    '\"': [IN_SUB_PATH, APPEND],\r\n    'eof': ERROR,\r\n    'else': [IN_DOUBLE_QUOTE, APPEND]\r\n  };\r\n\r\n  /**\r\n   * Determine the type of a character in a keypath.\r\n   *\r\n   * @param {Char} ch\r\n   * @return {String} type\r\n   */\r\n\r\n  function getPathCharType(ch) {\r\n    if (ch === undefined) {\r\n      return 'eof';\r\n    }\r\n\r\n    var code = ch.charCodeAt(0);\r\n\r\n    switch (code) {\r\n      case 0x5B: // [\r\n      case 0x5D: // ]\r\n      case 0x2E: // .\r\n      case 0x22: // \"\r\n      case 0x27: // '\r\n      case 0x30:\r\n        // 0\r\n        return ch;\r\n\r\n      case 0x5F: // _\r\n      case 0x24:\r\n        // $\r\n        return 'ident';\r\n\r\n      case 0x20: // Space\r\n      case 0x09: // Tab\r\n      case 0x0A: // Newline\r\n      case 0x0D: // Return\r\n      case 0xA0: // No-break space\r\n      case 0xFEFF: // Byte Order Mark\r\n      case 0x2028: // Line Separator\r\n      case 0x2029:\r\n        // Paragraph Separator\r\n        return 'ws';\r\n    }\r\n\r\n    // a-z, A-Z\r\n    if (code >= 0x61 && code <= 0x7A || code >= 0x41 && code <= 0x5A) {\r\n      return 'ident';\r\n    }\r\n\r\n    // 1-9\r\n    if (code >= 0x31 && code <= 0x39) {\r\n      return 'number';\r\n    }\r\n\r\n    return 'else';\r\n  }\r\n\r\n  /**\r\n   * Format a subPath, return its plain form if it is\r\n   * a literal string or number. Otherwise prepend the\r\n   * dynamic indicator (*).\r\n   *\r\n   * @param {String} path\r\n   * @return {String}\r\n   */\r\n\r\n  function formatSubPath(path) {\r\n    var trimmed = path.trim();\r\n    // invalid leading 0\r\n    if (path.charAt(0) === '0' && isNaN(path)) {\r\n      return false;\r\n    }\r\n    return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed;\r\n  }\r\n\r\n  /**\r\n   * Parse a string path into an array of segments\r\n   *\r\n   * @param {String} path\r\n   * @return {Array|undefined}\r\n   */\r\n\r\n  function parse(path) {\r\n    var keys = [];\r\n    var index = -1;\r\n    var mode = BEFORE_PATH;\r\n    var subPathDepth = 0;\r\n    var c, newChar, key, type, transition, action, typeMap;\r\n\r\n    var actions = [];\r\n\r\n    actions[PUSH] = function () {\r\n      if (key !== undefined) {\r\n        keys.push(key);\r\n        key = undefined;\r\n      }\r\n    };\r\n\r\n    actions[APPEND] = function () {\r\n      if (key === undefined) {\r\n        key = newChar;\r\n      } else {\r\n        key += newChar;\r\n      }\r\n    };\r\n\r\n    actions[INC_SUB_PATH_DEPTH] = function () {\r\n      actions[APPEND]();\r\n      subPathDepth++;\r\n    };\r\n\r\n    actions[PUSH_SUB_PATH] = function () {\r\n      if (subPathDepth > 0) {\r\n        subPathDepth--;\r\n        mode = IN_SUB_PATH;\r\n        actions[APPEND]();\r\n      } else {\r\n        subPathDepth = 0;\r\n        key = formatSubPath(key);\r\n        if (key === false) {\r\n          return false;\r\n        } else {\r\n          actions[PUSH]();\r\n        }\r\n      }\r\n    };\r\n\r\n    function maybeUnescapeQuote() {\r\n      var nextChar = path[index + 1];\r\n      if (mode === IN_SINGLE_QUOTE && nextChar === \"'\" || mode === IN_DOUBLE_QUOTE && nextChar === '\"') {\r\n        index++;\r\n        newChar = '\\\\' + nextChar;\r\n        actions[APPEND]();\r\n        return true;\r\n      }\r\n    }\r\n\r\n    while (mode != null) {\r\n      index++;\r\n      c = path[index];\r\n\r\n      if (c === '\\\\' && maybeUnescapeQuote()) {\r\n        continue;\r\n      }\r\n\r\n      type = getPathCharType(c);\r\n      typeMap = pathStateMachine[mode];\r\n      transition = typeMap[type] || typeMap['else'] || ERROR;\r\n\r\n      if (transition === ERROR) {\r\n        return; // parse error\r\n      }\r\n\r\n      mode = transition[0];\r\n      action = actions[transition[1]];\r\n      if (action) {\r\n        newChar = transition[2];\r\n        newChar = newChar === undefined ? c : newChar;\r\n        if (action() === false) {\r\n          return;\r\n        }\r\n      }\r\n\r\n      if (mode === AFTER_PATH) {\r\n        keys.raw = path;\r\n        return keys;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * External parse that check for a cache hit first\r\n   *\r\n   * @param {String} path\r\n   * @return {Array|undefined}\r\n   */\r\n\r\n  function parsePath(path) {\r\n    var hit = pathCache.get(path);\r\n    if (!hit) {\r\n      hit = parse(path);\r\n      if (hit) {\r\n        pathCache.put(path, hit);\r\n      }\r\n    }\r\n    return hit;\r\n  }\r\n\r\n  /**\r\n   * Get from an object from a path string\r\n   *\r\n   * @param {Object} obj\r\n   * @param {String} path\r\n   */\r\n\r\n  function getPath(obj, path) {\r\n    return parseExpression(path).get(obj);\r\n  }\r\n\r\n  /**\r\n   * Warn against setting non-existent root path on a vm.\r\n   */\r\n\r\n  var warnNonExistent;\r\n  if ('development' !== 'production') {\r\n    warnNonExistent = function (path, vm) {\r\n      warn('You are setting a non-existent path \"' + path.raw + '\" ' + 'on a vm instance. Consider pre-initializing the property ' + 'with the \"data\" option for more reliable reactivity ' + 'and better performance.', vm);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Set on an object from a path\r\n   *\r\n   * @param {Object} obj\r\n   * @param {String | Array} path\r\n   * @param {*} val\r\n   */\r\n\r\n  function setPath(obj, path, val) {\r\n    var original = obj;\r\n    if (typeof path === 'string') {\r\n      path = parse(path);\r\n    }\r\n    if (!path || !isObject(obj)) {\r\n      return false;\r\n    }\r\n    var last, key;\r\n    for (var i = 0, l = path.length; i < l; i++) {\r\n      last = obj;\r\n      key = path[i];\r\n      if (key.charAt(0) === '*') {\r\n        key = parseExpression(key.slice(1)).get.call(original, original);\r\n      }\r\n      if (i < l - 1) {\r\n        obj = obj[key];\r\n        if (!isObject(obj)) {\r\n          obj = {};\r\n          if ('development' !== 'production' && last._isVue) {\r\n            warnNonExistent(path, last);\r\n          }\r\n          set(last, key, obj);\r\n        }\r\n      } else {\r\n        if (isArray(obj)) {\r\n          obj.$set(key, val);\r\n        } else if (key in obj) {\r\n          obj[key] = val;\r\n        } else {\r\n          if ('development' !== 'production' && obj._isVue) {\r\n            warnNonExistent(path, obj);\r\n          }\r\n          set(obj, key, val);\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\nvar path = Object.freeze({\r\n    parsePath: parsePath,\r\n    getPath: getPath,\r\n    setPath: setPath\r\n  });\r\n\r\n  var expressionCache = new Cache(1000);\r\n\r\n  var allowedKeywords = 'Math,Date,this,true,false,null,undefined,Infinity,NaN,' + 'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' + 'encodeURIComponent,parseInt,parseFloat';\r\n  var allowedKeywordsRE = new RegExp('^(' + allowedKeywords.replace(/,/g, '\\\\b|') + '\\\\b)');\r\n\r\n  // keywords that don't make sense inside expressions\r\n  var improperKeywords = 'break,case,class,catch,const,continue,debugger,default,' + 'delete,do,else,export,extends,finally,for,function,if,' + 'import,in,instanceof,let,return,super,switch,throw,try,' + 'var,while,with,yield,enum,await,implements,package,' + 'protected,static,interface,private,public';\r\n  var improperKeywordsRE = new RegExp('^(' + improperKeywords.replace(/,/g, '\\\\b|') + '\\\\b)');\r\n\r\n  var wsRE = /\\s/g;\r\n  var newlineRE = /\\n/g;\r\n  var saveRE = /[\\{,]\\s*[\\w\\$_]+\\s*:|('(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`)|new |typeof |void /g;\r\n  var restoreRE = /\"(\\d+)\"/g;\r\n  var pathTestRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?'\\]|\\[\".*?\"\\]|\\[\\d+\\]|\\[[A-Za-z_$][\\w$]*\\])*$/;\r\n  var identRE = /[^\\w$\\.](?:[A-Za-z_$][\\w$]*)/g;\r\n  var literalValueRE$1 = /^(?:true|false|null|undefined|Infinity|NaN)$/;\r\n\r\n  function noop() {}\r\n\r\n  /**\r\n   * Save / Rewrite / Restore\r\n   *\r\n   * When rewriting paths found in an expression, it is\r\n   * possible for the same letter sequences to be found in\r\n   * strings and Object literal property keys. Therefore we\r\n   * remove and store these parts in a temporary array, and\r\n   * restore them after the path rewrite.\r\n   */\r\n\r\n  var saved = [];\r\n\r\n  /**\r\n   * Save replacer\r\n   *\r\n   * The save regex can match two possible cases:\r\n   * 1. An opening object literal\r\n   * 2. A string\r\n   * If matched as a plain string, we need to escape its\r\n   * newlines, since the string needs to be preserved when\r\n   * generating the function body.\r\n   *\r\n   * @param {String} str\r\n   * @param {String} isString - str if matched as a string\r\n   * @return {String} - placeholder with index\r\n   */\r\n\r\n  function save(str, isString) {\r\n    var i = saved.length;\r\n    saved[i] = isString ? str.replace(newlineRE, '\\\\n') : str;\r\n    return '\"' + i + '\"';\r\n  }\r\n\r\n  /**\r\n   * Path rewrite replacer\r\n   *\r\n   * @param {String} raw\r\n   * @return {String}\r\n   */\r\n\r\n  function rewrite(raw) {\r\n    var c = raw.charAt(0);\r\n    var path = raw.slice(1);\r\n    if (allowedKeywordsRE.test(path)) {\r\n      return raw;\r\n    } else {\r\n      path = path.indexOf('\"') > -1 ? path.replace(restoreRE, restore) : path;\r\n      return c + 'scope.' + path;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Restore replacer\r\n   *\r\n   * @param {String} str\r\n   * @param {String} i - matched save index\r\n   * @return {String}\r\n   */\r\n\r\n  function restore(str, i) {\r\n    return saved[i];\r\n  }\r\n\r\n  /**\r\n   * Rewrite an expression, prefixing all path accessors with\r\n   * `scope.` and generate getter/setter functions.\r\n   *\r\n   * @param {String} exp\r\n   * @return {Function}\r\n   */\r\n\r\n  function compileGetter(exp) {\r\n    if (improperKeywordsRE.test(exp)) {\r\n      'development' !== 'production' && warn('Avoid using reserved keywords in expression: ' + exp);\r\n    }\r\n    // reset state\r\n    saved.length = 0;\r\n    // save strings and object literal keys\r\n    var body = exp.replace(saveRE, save).replace(wsRE, '');\r\n    // rewrite all paths\r\n    // pad 1 space here because the regex matches 1 extra char\r\n    body = (' ' + body).replace(identRE, rewrite).replace(restoreRE, restore);\r\n    return makeGetterFn(body);\r\n  }\r\n\r\n  /**\r\n   * Build a getter function. Requires eval.\r\n   *\r\n   * We isolate the try/catch so it doesn't affect the\r\n   * optimization of the parse function when it is not called.\r\n   *\r\n   * @param {String} body\r\n   * @return {Function|undefined}\r\n   */\r\n\r\n  function makeGetterFn(body) {\r\n    try {\r\n      /* eslint-disable no-new-func */\r\n      return new Function('scope', 'return ' + body + ';');\r\n      /* eslint-enable no-new-func */\r\n    } catch (e) {\r\n      if ('development' !== 'production') {\r\n        /* istanbul ignore if */\r\n        if (e.toString().match(/unsafe-eval|CSP/)) {\r\n          warn('It seems you are using the default build of Vue.js in an environment ' + 'with Content Security Policy that prohibits unsafe-eval. ' + 'Use the CSP-compliant build instead: ' + 'http://vuejs.org/guide/installation.html#CSP-compliant-build');\r\n        } else {\r\n          warn('Invalid expression. ' + 'Generated function body: ' + body);\r\n        }\r\n      }\r\n      return noop;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Compile a setter function for the expression.\r\n   *\r\n   * @param {String} exp\r\n   * @return {Function|undefined}\r\n   */\r\n\r\n  function compileSetter(exp) {\r\n    var path = parsePath(exp);\r\n    if (path) {\r\n      return function (scope, val) {\r\n        setPath(scope, path, val);\r\n      };\r\n    } else {\r\n      'development' !== 'production' && warn('Invalid setter expression: ' + exp);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse an expression into re-written getter/setters.\r\n   *\r\n   * @param {String} exp\r\n   * @param {Boolean} needSet\r\n   * @return {Function}\r\n   */\r\n\r\n  function parseExpression(exp, needSet) {\r\n    exp = exp.trim();\r\n    // try cache\r\n    var hit = expressionCache.get(exp);\r\n    if (hit) {\r\n      if (needSet && !hit.set) {\r\n        hit.set = compileSetter(hit.exp);\r\n      }\r\n      return hit;\r\n    }\r\n    var res = { exp: exp };\r\n    res.get = isSimplePath(exp) && exp.indexOf('[') < 0\r\n    // optimized super simple getter\r\n    ? makeGetterFn('scope.' + exp)\r\n    // dynamic getter\r\n    : compileGetter(exp);\r\n    if (needSet) {\r\n      res.set = compileSetter(exp);\r\n    }\r\n    expressionCache.put(exp, res);\r\n    return res;\r\n  }\r\n\r\n  /**\r\n   * Check if an expression is a simple path.\r\n   *\r\n   * @param {String} exp\r\n   * @return {Boolean}\r\n   */\r\n\r\n  function isSimplePath(exp) {\r\n    return pathTestRE.test(exp) &&\r\n    // don't treat literal values as paths\r\n    !literalValueRE$1.test(exp) &&\r\n    // Math constants e.g. Math.PI, Math.E etc.\r\n    exp.slice(0, 5) !== 'Math.';\r\n  }\r\n\r\nvar expression = Object.freeze({\r\n    parseExpression: parseExpression,\r\n    isSimplePath: isSimplePath\r\n  });\r\n\r\n  // we have two separate queues: one for directive updates\r\n  // and one for user watcher registered via $watch().\r\n  // we want to guarantee directive updates to be called\r\n  // before user watchers so that when user watchers are\r\n  // triggered, the DOM would have already been in updated\r\n  // state.\r\n\r\n  var queue = [];\r\n  var userQueue = [];\r\n  var has = {};\r\n  var circular = {};\r\n  var waiting = false;\r\n\r\n  /**\r\n   * Reset the batcher's state.\r\n   */\r\n\r\n  function resetBatcherState() {\r\n    queue.length = 0;\r\n    userQueue.length = 0;\r\n    has = {};\r\n    circular = {};\r\n    waiting = false;\r\n  }\r\n\r\n  /**\r\n   * Flush both queues and run the watchers.\r\n   */\r\n\r\n  function flushBatcherQueue() {\r\n    var _again = true;\r\n\r\n    _function: while (_again) {\r\n      _again = false;\r\n\r\n      runBatcherQueue(queue);\r\n      runBatcherQueue(userQueue);\r\n      // user watchers triggered more watchers,\r\n      // keep flushing until it depletes\r\n      if (queue.length) {\r\n        _again = true;\r\n        continue _function;\r\n      }\r\n      // dev tool hook\r\n      /* istanbul ignore if */\r\n      if (devtools && config.devtools) {\r\n        devtools.emit('flush');\r\n      }\r\n      resetBatcherState();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Run the watchers in a single queue.\r\n   *\r\n   * @param {Array} queue\r\n   */\r\n\r\n  function runBatcherQueue(queue) {\r\n    // do not cache length because more watchers might be pushed\r\n    // as we run existing watchers\r\n    for (var i = 0; i < queue.length; i++) {\r\n      var watcher = queue[i];\r\n      var id = watcher.id;\r\n      has[id] = null;\r\n      watcher.run();\r\n      // in dev build, check and stop circular updates.\r\n      if ('development' !== 'production' && has[id] != null) {\r\n        circular[id] = (circular[id] || 0) + 1;\r\n        if (circular[id] > config._maxUpdateCount) {\r\n          warn('You may have an infinite update loop for watcher ' + 'with expression \"' + watcher.expression + '\"', watcher.vm);\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    queue.length = 0;\r\n  }\r\n\r\n  /**\r\n   * Push a watcher into the watcher queue.\r\n   * Jobs with duplicate IDs will be skipped unless it's\r\n   * pushed when the queue is being flushed.\r\n   *\r\n   * @param {Watcher} watcher\r\n   *   properties:\r\n   *   - {Number} id\r\n   *   - {Function} run\r\n   */\r\n\r\n  function pushWatcher(watcher) {\r\n    var id = watcher.id;\r\n    if (has[id] == null) {\r\n      // push watcher into appropriate queue\r\n      var q = watcher.user ? userQueue : queue;\r\n      has[id] = q.length;\r\n      q.push(watcher);\r\n      // queue the flush\r\n      if (!waiting) {\r\n        waiting = true;\r\n        nextTick(flushBatcherQueue);\r\n      }\r\n    }\r\n  }\r\n\r\n  var uid$2 = 0;\r\n\r\n  /**\r\n   * A watcher parses an expression, collects dependencies,\r\n   * and fires callback when the expression value changes.\r\n   * This is used for both the $watch() api and directives.\r\n   *\r\n   * @param {Vue} vm\r\n   * @param {String|Function} expOrFn\r\n   * @param {Function} cb\r\n   * @param {Object} options\r\n   *                 - {Array} filters\r\n   *                 - {Boolean} twoWay\r\n   *                 - {Boolean} deep\r\n   *                 - {Boolean} user\r\n   *                 - {Boolean} sync\r\n   *                 - {Boolean} lazy\r\n   *                 - {Function} [preProcess]\r\n   *                 - {Function} [postProcess]\r\n   * @constructor\r\n   */\r\n  function Watcher(vm, expOrFn, cb, options) {\r\n    // mix in options\r\n    if (options) {\r\n      extend(this, options);\r\n    }\r\n    var isFn = typeof expOrFn === 'function';\r\n    this.vm = vm;\r\n    vm._watchers.push(this);\r\n    this.expression = expOrFn;\r\n    this.cb = cb;\r\n    this.id = ++uid$2; // uid for batching\r\n    this.active = true;\r\n    this.dirty = this.lazy; // for lazy watchers\r\n    this.deps = [];\r\n    this.newDeps = [];\r\n    this.depIds = new _Set();\r\n    this.newDepIds = new _Set();\r\n    this.prevError = null; // for async error stacks\r\n    // parse expression for getter/setter\r\n    if (isFn) {\r\n      this.getter = expOrFn;\r\n      this.setter = undefined;\r\n    } else {\r\n      var res = parseExpression(expOrFn, this.twoWay);\r\n      this.getter = res.get;\r\n      this.setter = res.set;\r\n    }\r\n    this.value = this.lazy ? undefined : this.get();\r\n    // state for avoiding false triggers for deep and Array\r\n    // watchers during vm._digest()\r\n    this.queued = this.shallow = false;\r\n  }\r\n\r\n  /**\r\n   * Evaluate the getter, and re-collect dependencies.\r\n   */\r\n\r\n  Watcher.prototype.get = function () {\r\n    this.beforeGet();\r\n    var scope = this.scope || this.vm;\r\n    var value;\r\n    try {\r\n      value = this.getter.call(scope, scope);\r\n    } catch (e) {\r\n      if ('development' !== 'production' && config.warnExpressionErrors) {\r\n        warn('Error when evaluating expression ' + '\"' + this.expression + '\": ' + e.toString(), this.vm);\r\n      }\r\n    }\r\n    // \"touch\" every property so they are all tracked as\r\n    // dependencies for deep watching\r\n    if (this.deep) {\r\n      traverse(value);\r\n    }\r\n    if (this.preProcess) {\r\n      value = this.preProcess(value);\r\n    }\r\n    if (this.filters) {\r\n      value = scope._applyFilters(value, null, this.filters, false);\r\n    }\r\n    if (this.postProcess) {\r\n      value = this.postProcess(value);\r\n    }\r\n    this.afterGet();\r\n    return value;\r\n  };\r\n\r\n  /**\r\n   * Set the corresponding value with the setter.\r\n   *\r\n   * @param {*} value\r\n   */\r\n\r\n  Watcher.prototype.set = function (value) {\r\n    var scope = this.scope || this.vm;\r\n    if (this.filters) {\r\n      value = scope._applyFilters(value, this.value, this.filters, true);\r\n    }\r\n    try {\r\n      this.setter.call(scope, scope, value);\r\n    } catch (e) {\r\n      if ('development' !== 'production' && config.warnExpressionErrors) {\r\n        warn('Error when evaluating setter ' + '\"' + this.expression + '\": ' + e.toString(), this.vm);\r\n      }\r\n    }\r\n    // two-way sync for v-for alias\r\n    var forContext = scope.$forContext;\r\n    if (forContext && forContext.alias === this.expression) {\r\n      if (forContext.filters) {\r\n        'development' !== 'production' && warn('It seems you are using two-way binding on ' + 'a v-for alias (' + this.expression + '), and the ' + 'v-for has filters. This will not work properly. ' + 'Either remove the filters or use an array of ' + 'objects and bind to object properties instead.', this.vm);\r\n        return;\r\n      }\r\n      forContext._withLock(function () {\r\n        if (scope.$key) {\r\n          // original is an object\r\n          forContext.rawValue[scope.$key] = value;\r\n        } else {\r\n          forContext.rawValue.$set(scope.$index, value);\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Prepare for dependency collection.\r\n   */\r\n\r\n  Watcher.prototype.beforeGet = function () {\r\n    Dep.target = this;\r\n  };\r\n\r\n  /**\r\n   * Add a dependency to this directive.\r\n   *\r\n   * @param {Dep} dep\r\n   */\r\n\r\n  Watcher.prototype.addDep = function (dep) {\r\n    var id = dep.id;\r\n    if (!this.newDepIds.has(id)) {\r\n      this.newDepIds.add(id);\r\n      this.newDeps.push(dep);\r\n      if (!this.depIds.has(id)) {\r\n        dep.addSub(this);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Clean up for dependency collection.\r\n   */\r\n\r\n  Watcher.prototype.afterGet = function () {\r\n    Dep.target = null;\r\n    var i = this.deps.length;\r\n    while (i--) {\r\n      var dep = this.deps[i];\r\n      if (!this.newDepIds.has(dep.id)) {\r\n        dep.removeSub(this);\r\n      }\r\n    }\r\n    var tmp = this.depIds;\r\n    this.depIds = this.newDepIds;\r\n    this.newDepIds = tmp;\r\n    this.newDepIds.clear();\r\n    tmp = this.deps;\r\n    this.deps = this.newDeps;\r\n    this.newDeps = tmp;\r\n    this.newDeps.length = 0;\r\n  };\r\n\r\n  /**\r\n   * Subscriber interface.\r\n   * Will be called when a dependency changes.\r\n   *\r\n   * @param {Boolean} shallow\r\n   */\r\n\r\n  Watcher.prototype.update = function (shallow) {\r\n    if (this.lazy) {\r\n      this.dirty = true;\r\n    } else if (this.sync || !config.async) {\r\n      this.run();\r\n    } else {\r\n      // if queued, only overwrite shallow with non-shallow,\r\n      // but not the other way around.\r\n      this.shallow = this.queued ? shallow ? this.shallow : false : !!shallow;\r\n      this.queued = true;\r\n      // record before-push error stack in debug mode\r\n      /* istanbul ignore if */\r\n      if ('development' !== 'production' && config.debug) {\r\n        this.prevError = new Error('[vue] async stack trace');\r\n      }\r\n      pushWatcher(this);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Batcher job interface.\r\n   * Will be called by the batcher.\r\n   */\r\n\r\n  Watcher.prototype.run = function () {\r\n    if (this.active) {\r\n      var value = this.get();\r\n      if (value !== this.value ||\r\n      // Deep watchers and watchers on Object/Arrays should fire even\r\n      // when the value is the same, because the value may\r\n      // have mutated; but only do so if this is a\r\n      // non-shallow update (caused by a vm digest).\r\n      (isObject(value) || this.deep) && !this.shallow) {\r\n        // set new value\r\n        var oldValue = this.value;\r\n        this.value = value;\r\n        // in debug + async mode, when a watcher callbacks\r\n        // throws, we also throw the saved before-push error\r\n        // so the full cross-tick stack trace is available.\r\n        var prevError = this.prevError;\r\n        /* istanbul ignore if */\r\n        if ('development' !== 'production' && config.debug && prevError) {\r\n          this.prevError = null;\r\n          try {\r\n            this.cb.call(this.vm, value, oldValue);\r\n          } catch (e) {\r\n            nextTick(function () {\r\n              throw prevError;\r\n            }, 0);\r\n            throw e;\r\n          }\r\n        } else {\r\n          this.cb.call(this.vm, value, oldValue);\r\n        }\r\n      }\r\n      this.queued = this.shallow = false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Evaluate the value of the watcher.\r\n   * This only gets called for lazy watchers.\r\n   */\r\n\r\n  Watcher.prototype.evaluate = function () {\r\n    // avoid overwriting another watcher that is being\r\n    // collected.\r\n    var current = Dep.target;\r\n    this.value = this.get();\r\n    this.dirty = false;\r\n    Dep.target = current;\r\n  };\r\n\r\n  /**\r\n   * Depend on all deps collected by this watcher.\r\n   */\r\n\r\n  Watcher.prototype.depend = function () {\r\n    var i = this.deps.length;\r\n    while (i--) {\r\n      this.deps[i].depend();\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Remove self from all dependencies' subcriber list.\r\n   */\r\n\r\n  Watcher.prototype.teardown = function () {\r\n    if (this.active) {\r\n      // remove self from vm's watcher list\r\n      // this is a somewhat expensive operation so we skip it\r\n      // if the vm is being destroyed or is performing a v-for\r\n      // re-render (the watcher list is then filtered by v-for).\r\n      if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {\r\n        this.vm._watchers.$remove(this);\r\n      }\r\n      var i = this.deps.length;\r\n      while (i--) {\r\n        this.deps[i].removeSub(this);\r\n      }\r\n      this.active = false;\r\n      this.vm = this.cb = this.value = null;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Recrusively traverse an object to evoke all converted\r\n   * getters, so that every nested property inside the object\r\n   * is collected as a \"deep\" dependency.\r\n   *\r\n   * @param {*} val\r\n   */\r\n\r\n  var seenObjects = new _Set();\r\n  function traverse(val, seen) {\r\n    var i = undefined,\r\n        keys = undefined;\r\n    if (!seen) {\r\n      seen = seenObjects;\r\n      seen.clear();\r\n    }\r\n    var isA = isArray(val);\r\n    var isO = isObject(val);\r\n    if ((isA || isO) && Object.isExtensible(val)) {\r\n      if (val.__ob__) {\r\n        var depId = val.__ob__.dep.id;\r\n        if (seen.has(depId)) {\r\n          return;\r\n        } else {\r\n          seen.add(depId);\r\n        }\r\n      }\r\n      if (isA) {\r\n        i = val.length;\r\n        while (i--) traverse(val[i], seen);\r\n      } else if (isO) {\r\n        keys = Object.keys(val);\r\n        i = keys.length;\r\n        while (i--) traverse(val[keys[i]], seen);\r\n      }\r\n    }\r\n  }\r\n\r\n  var text$1 = {\r\n\r\n    bind: function bind() {\r\n      this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';\r\n    },\r\n\r\n    update: function update(value) {\r\n      this.el[this.attr] = _toString(value);\r\n    }\r\n  };\r\n\r\n  var templateCache = new Cache(1000);\r\n  var idSelectorCache = new Cache(1000);\r\n\r\n  var map = {\r\n    efault: [0, '', ''],\r\n    legend: [1, '<fieldset>', '</fieldset>'],\r\n    tr: [2, '<table><tbody>', '</tbody></table>'],\r\n    col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>']\r\n  };\r\n\r\n  map.td = map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];\r\n\r\n  map.option = map.optgroup = [1, '<select multiple=\"multiple\">', '</select>'];\r\n\r\n  map.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, '<table>', '</table>'];\r\n\r\n  map.g = map.defs = map.symbol = map.use = map.image = map.text = map.circle = map.ellipse = map.line = map.path = map.polygon = map.polyline = map.rect = [1, '<svg ' + 'xmlns=\"http://www.w3.org/2000/svg\" ' + 'xmlns:xlink=\"http://www.w3.org/1999/xlink\" ' + 'xmlns:ev=\"http://www.w3.org/2001/xml-events\"' + 'version=\"1.1\">', '</svg>'];\r\n\r\n  /**\r\n   * Check if a node is a supported template node with a\r\n   * DocumentFragment content.\r\n   *\r\n   * @param {Node} node\r\n   * @return {Boolean}\r\n   */\r\n\r\n  function isRealTemplate(node) {\r\n    return isTemplate(node) && isFragment(node.content);\r\n  }\r\n\r\n  var tagRE$1 = /<([\\w:-]+)/;\r\n  var entityRE = /&#?\\w+?;/;\r\n  var commentRE = /<!--/;\r\n\r\n  /**\r\n   * Convert a string template to a DocumentFragment.\r\n   * Determines correct wrapping by tag types. Wrapping\r\n   * strategy found in jQuery & component/domify.\r\n   *\r\n   * @param {String} templateString\r\n   * @param {Boolean} raw\r\n   * @return {DocumentFragment}\r\n   */\r\n\r\n  function stringToFragment(templateString, raw) {\r\n    // try a cache hit first\r\n    var cacheKey = raw ? templateString : templateString.trim();\r\n    var hit = templateCache.get(cacheKey);\r\n    if (hit) {\r\n      return hit;\r\n    }\r\n\r\n    var frag = document.createDocumentFragment();\r\n    var tagMatch = templateString.match(tagRE$1);\r\n    var entityMatch = entityRE.test(templateString);\r\n    var commentMatch = commentRE.test(templateString);\r\n\r\n    if (!tagMatch && !entityMatch && !commentMatch) {\r\n      // text only, return a single text node.\r\n      frag.appendChild(document.createTextNode(templateString));\r\n    } else {\r\n      var tag = tagMatch && tagMatch[1];\r\n      var wrap = map[tag] || map.efault;\r\n      var depth = wrap[0];\r\n      var prefix = wrap[1];\r\n      var suffix = wrap[2];\r\n      var node = document.createElement('div');\r\n\r\n      node.innerHTML = prefix + templateString + suffix;\r\n      while (depth--) {\r\n        node = node.lastChild;\r\n      }\r\n\r\n      var child;\r\n      /* eslint-disable no-cond-assign */\r\n      while (child = node.firstChild) {\r\n        /* eslint-enable no-cond-assign */\r\n        frag.appendChild(child);\r\n      }\r\n    }\r\n    if (!raw) {\r\n      trimNode(frag);\r\n    }\r\n    templateCache.put(cacheKey, frag);\r\n    return frag;\r\n  }\r\n\r\n  /**\r\n   * Convert a template node to a DocumentFragment.\r\n   *\r\n   * @param {Node} node\r\n   * @return {DocumentFragment}\r\n   */\r\n\r\n  function nodeToFragment(node) {\r\n    // if its a template tag and the browser supports it,\r\n    // its content is already a document fragment. However, iOS Safari has\r\n    // bug when using directly cloned template content with touch\r\n    // events and can cause crashes when the nodes are removed from DOM, so we\r\n    // have to treat template elements as string templates. (#2805)\r\n    /* istanbul ignore if */\r\n    if (isRealTemplate(node)) {\r\n      return stringToFragment(node.innerHTML);\r\n    }\r\n    // script template\r\n    if (node.tagName === 'SCRIPT') {\r\n      return stringToFragment(node.textContent);\r\n    }\r\n    // normal node, clone it to avoid mutating the original\r\n    var clonedNode = cloneNode(node);\r\n    var frag = document.createDocumentFragment();\r\n    var child;\r\n    /* eslint-disable no-cond-assign */\r\n    while (child = clonedNode.firstChild) {\r\n      /* eslint-enable no-cond-assign */\r\n      frag.appendChild(child);\r\n    }\r\n    trimNode(frag);\r\n    return frag;\r\n  }\r\n\r\n  // Test for the presence of the Safari template cloning bug\r\n  // https://bugs.webkit.org/showug.cgi?id=137755\r\n  var hasBrokenTemplate = (function () {\r\n    /* istanbul ignore else */\r\n    if (inBrowser) {\r\n      var a = document.createElement('div');\r\n      a.innerHTML = '<template>1</template>';\r\n      return !a.cloneNode(true).firstChild.innerHTML;\r\n    } else {\r\n      return false;\r\n    }\r\n  })();\r\n\r\n  // Test for IE10/11 textarea placeholder clone bug\r\n  var hasTextareaCloneBug = (function () {\r\n    /* istanbul ignore else */\r\n    if (inBrowser) {\r\n      var t = document.createElement('textarea');\r\n      t.placeholder = 't';\r\n      return t.cloneNode(true).value === 't';\r\n    } else {\r\n      return false;\r\n    }\r\n  })();\r\n\r\n  /**\r\n   * 1. Deal with Safari cloning nested <template> bug by\r\n   *    manually cloning all template instances.\r\n   * 2. Deal with IE10/11 textarea placeholder bug by setting\r\n   *    the correct value after cloning.\r\n   *\r\n   * @param {Element|DocumentFragment} node\r\n   * @return {Element|DocumentFragment}\r\n   */\r\n\r\n  function cloneNode(node) {\r\n    /* istanbul ignore if */\r\n    if (!node.querySelectorAll) {\r\n      return node.cloneNode();\r\n    }\r\n    var res = node.cloneNode(true);\r\n    var i, original, cloned;\r\n    /* istanbul ignore if */\r\n    if (hasBrokenTemplate) {\r\n      var tempClone = res;\r\n      if (isRealTemplate(node)) {\r\n        node = node.content;\r\n        tempClone = res.content;\r\n      }\r\n      original = node.querySelectorAll('template');\r\n      if (original.length) {\r\n        cloned = tempClone.querySelectorAll('template');\r\n        i = cloned.length;\r\n        while (i--) {\r\n          cloned[i].parentNode.replaceChild(cloneNode(original[i]), cloned[i]);\r\n        }\r\n      }\r\n    }\r\n    /* istanbul ignore if */\r\n    if (hasTextareaCloneBug) {\r\n      if (node.tagName === 'TEXTAREA') {\r\n        res.value = node.value;\r\n      } else {\r\n        original = node.querySelectorAll('textarea');\r\n        if (original.length) {\r\n          cloned = res.querySelectorAll('textarea');\r\n          i = cloned.length;\r\n          while (i--) {\r\n            cloned[i].value = original[i].value;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return res;\r\n  }\r\n\r\n  /**\r\n   * Process the template option and normalizes it into a\r\n   * a DocumentFragment that can be used as a partial or a\r\n   * instance template.\r\n   *\r\n   * @param {*} template\r\n   *        Possible values include:\r\n   *        - DocumentFragment object\r\n   *        - Node object of type Template\r\n   *        - id selector: '#some-template-id'\r\n   *        - template string: '<div><span>{{msg}}</span></div>'\r\n   * @param {Boolean} shouldClone\r\n   * @param {Boolean} raw\r\n   *        inline HTML interpolation. Do not check for id\r\n   *        selector and keep whitespace in the string.\r\n   * @return {DocumentFragment|undefined}\r\n   */\r\n\r\n  function parseTemplate(template, shouldClone, raw) {\r\n    var node, frag;\r\n\r\n    // if the template is already a document fragment,\r\n    // do nothing\r\n    if (isFragment(template)) {\r\n      trimNode(template);\r\n      return shouldClone ? cloneNode(template) : template;\r\n    }\r\n\r\n    if (typeof template === 'string') {\r\n      // id selector\r\n      if (!raw && template.charAt(0) === '#') {\r\n        // id selector can be cached too\r\n        frag = idSelectorCache.get(template);\r\n        if (!frag) {\r\n          node = document.getElementById(template.slice(1));\r\n          if (node) {\r\n            frag = nodeToFragment(node);\r\n            // save selector to cache\r\n            idSelectorCache.put(template, frag);\r\n          }\r\n        }\r\n      } else {\r\n        // normal string template\r\n        frag = stringToFragment(template, raw);\r\n      }\r\n    } else if (template.nodeType) {\r\n      // a direct node\r\n      frag = nodeToFragment(template);\r\n    }\r\n\r\n    return frag && shouldClone ? cloneNode(frag) : frag;\r\n  }\r\n\r\nvar template = Object.freeze({\r\n    cloneNode: cloneNode,\r\n    parseTemplate: parseTemplate\r\n  });\r\n\r\n  var html = {\r\n\r\n    bind: function bind() {\r\n      // a comment node means this is a binding for\r\n      // {{{ inline unescaped html }}}\r\n      if (this.el.nodeType === 8) {\r\n        // hold nodes\r\n        this.nodes = [];\r\n        // replace the placeholder with proper anchor\r\n        this.anchor = createAnchor('v-html');\r\n        replace(this.el, this.anchor);\r\n      }\r\n    },\r\n\r\n    update: function update(value) {\r\n      value = _toString(value);\r\n      if (this.nodes) {\r\n        this.swap(value);\r\n      } else {\r\n        this.el.innerHTML = value;\r\n      }\r\n    },\r\n\r\n    swap: function swap(value) {\r\n      // remove old nodes\r\n      var i = this.nodes.length;\r\n      while (i--) {\r\n        remove(this.nodes[i]);\r\n      }\r\n      // convert new value to a fragment\r\n      // do not attempt to retrieve from id selector\r\n      var frag = parseTemplate(value, true, true);\r\n      // save a reference to these nodes so we can remove later\r\n      this.nodes = toArray(frag.childNodes);\r\n      before(frag, this.anchor);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Abstraction for a partially-compiled fragment.\r\n   * Can optionally compile content with a child scope.\r\n   *\r\n   * @param {Function} linker\r\n   * @param {Vue} vm\r\n   * @param {DocumentFragment} frag\r\n   * @param {Vue} [host]\r\n   * @param {Object} [scope]\r\n   * @param {Fragment} [parentFrag]\r\n   */\r\n  function Fragment(linker, vm, frag, host, scope, parentFrag) {\r\n    this.children = [];\r\n    this.childFrags = [];\r\n    this.vm = vm;\r\n    this.scope = scope;\r\n    this.inserted = false;\r\n    this.parentFrag = parentFrag;\r\n    if (parentFrag) {\r\n      parentFrag.childFrags.push(this);\r\n    }\r\n    this.unlink = linker(vm, frag, host, scope, this);\r\n    var single = this.single = frag.childNodes.length === 1 &&\r\n    // do not go single mode if the only node is an anchor\r\n    !frag.childNodes[0].__v_anchor;\r\n    if (single) {\r\n      this.node = frag.childNodes[0];\r\n      this.before = singleBefore;\r\n      this.remove = singleRemove;\r\n    } else {\r\n      this.node = createAnchor('fragment-start');\r\n      this.end = createAnchor('fragment-end');\r\n      this.frag = frag;\r\n      prepend(this.node, frag);\r\n      frag.appendChild(this.end);\r\n      this.before = multiBefore;\r\n      this.remove = multiRemove;\r\n    }\r\n    this.node.__v_frag = this;\r\n  }\r\n\r\n  /**\r\n   * Call attach/detach for all components contained within\r\n   * this fragment. Also do so recursively for all child\r\n   * fragments.\r\n   *\r\n   * @param {Function} hook\r\n   */\r\n\r\n  Fragment.prototype.callHook = function (hook) {\r\n    var i, l;\r\n    for (i = 0, l = this.childFrags.length; i < l; i++) {\r\n      this.childFrags[i].callHook(hook);\r\n    }\r\n    for (i = 0, l = this.children.length; i < l; i++) {\r\n      hook(this.children[i]);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Insert fragment before target, single node version\r\n   *\r\n   * @param {Node} target\r\n   * @param {Boolean} withTransition\r\n   */\r\n\r\n  function singleBefore(target, withTransition) {\r\n    this.inserted = true;\r\n    var method = withTransition !== false ? beforeWithTransition : before;\r\n    method(this.node, target, this.vm);\r\n    if (inDoc(this.node)) {\r\n      this.callHook(attach);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove fragment, single node version\r\n   */\r\n\r\n  function singleRemove() {\r\n    this.inserted = false;\r\n    var shouldCallRemove = inDoc(this.node);\r\n    var self = this;\r\n    this.beforeRemove();\r\n    removeWithTransition(this.node, this.vm, function () {\r\n      if (shouldCallRemove) {\r\n        self.callHook(detach);\r\n      }\r\n      self.destroy();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Insert fragment before target, multi-nodes version\r\n   *\r\n   * @param {Node} target\r\n   * @param {Boolean} withTransition\r\n   */\r\n\r\n  function multiBefore(target, withTransition) {\r\n    this.inserted = true;\r\n    var vm = this.vm;\r\n    var method = withTransition !== false ? beforeWithTransition : before;\r\n    mapNodeRange(this.node, this.end, function (node) {\r\n      method(node, target, vm);\r\n    });\r\n    if (inDoc(this.node)) {\r\n      this.callHook(attach);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove fragment, multi-nodes version\r\n   */\r\n\r\n  function multiRemove() {\r\n    this.inserted = false;\r\n    var self = this;\r\n    var shouldCallRemove = inDoc(this.node);\r\n    this.beforeRemove();\r\n    removeNodeRange(this.node, this.end, this.vm, this.frag, function () {\r\n      if (shouldCallRemove) {\r\n        self.callHook(detach);\r\n      }\r\n      self.destroy();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Prepare the fragment for removal.\r\n   */\r\n\r\n  Fragment.prototype.beforeRemove = function () {\r\n    var i, l;\r\n    for (i = 0, l = this.childFrags.length; i < l; i++) {\r\n      // call the same method recursively on child\r\n      // fragments, depth-first\r\n      this.childFrags[i].beforeRemove(false);\r\n    }\r\n    for (i = 0, l = this.children.length; i < l; i++) {\r\n      // Call destroy for all contained instances,\r\n      // with remove:false and defer:true.\r\n      // Defer is necessary because we need to\r\n      // keep the children to call detach hooks\r\n      // on them.\r\n      this.children[i].$destroy(false, true);\r\n    }\r\n    var dirs = this.unlink.dirs;\r\n    for (i = 0, l = dirs.length; i < l; i++) {\r\n      // disable the watchers on all the directives\r\n      // so that the rendered content stays the same\r\n      // during removal.\r\n      dirs[i]._watcher && dirs[i]._watcher.teardown();\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Destroy the fragment.\r\n   */\r\n\r\n  Fragment.prototype.destroy = function () {\r\n    if (this.parentFrag) {\r\n      this.parentFrag.childFrags.$remove(this);\r\n    }\r\n    this.node.__v_frag = null;\r\n    this.unlink();\r\n  };\r\n\r\n  /**\r\n   * Call attach hook for a Vue instance.\r\n   *\r\n   * @param {Vue} child\r\n   */\r\n\r\n  function attach(child) {\r\n    if (!child._isAttached && inDoc(child.$el)) {\r\n      child._callHook('attached');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Call detach hook for a Vue instance.\r\n   *\r\n   * @param {Vue} child\r\n   */\r\n\r\n  function detach(child) {\r\n    if (child._isAttached && !inDoc(child.$el)) {\r\n      child._callHook('detached');\r\n    }\r\n  }\r\n\r\n  var linkerCache = new Cache(5000);\r\n\r\n  /**\r\n   * A factory that can be used to create instances of a\r\n   * fragment. Caches the compiled linker if possible.\r\n   *\r\n   * @param {Vue} vm\r\n   * @param {Element|String} el\r\n   */\r\n  function FragmentFactory(vm, el) {\r\n    this.vm = vm;\r\n    var template;\r\n    var isString = typeof el === 'string';\r\n    if (isString || isTemplate(el) && !el.hasAttribute('v-if')) {\r\n      template = parseTemplate(el, true);\r\n    } else {\r\n      template = document.createDocumentFragment();\r\n      template.appendChild(el);\r\n    }\r\n    this.template = template;\r\n    // linker can be cached, but only for components\r\n    var linker;\r\n    var cid = vm.constructor.cid;\r\n    if (cid > 0) {\r\n      var cacheId = cid + (isString ? el : getOuterHTML(el));\r\n      linker = linkerCache.get(cacheId);\r\n      if (!linker) {\r\n        linker = compile(template, vm.$options, true);\r\n        linkerCache.put(cacheId, linker);\r\n      }\r\n    } else {\r\n      linker = compile(template, vm.$options, true);\r\n    }\r\n    this.linker = linker;\r\n  }\r\n\r\n  /**\r\n   * Create a fragment instance with given host and scope.\r\n   *\r\n   * @param {Vue} host\r\n   * @param {Object} scope\r\n   * @param {Fragment} parentFrag\r\n   */\r\n\r\n  FragmentFactory.prototype.create = function (host, scope, parentFrag) {\r\n    var frag = cloneNode(this.template);\r\n    return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag);\r\n  };\r\n\r\n  var ON = 700;\r\n  var MODEL = 800;\r\n  var BIND = 850;\r\n  var TRANSITION = 1100;\r\n  var EL = 1500;\r\n  var COMPONENT = 1500;\r\n  var PARTIAL = 1750;\r\n  var IF = 2100;\r\n  var FOR = 2200;\r\n  var SLOT = 2300;\r\n\r\n  var uid$3 = 0;\r\n\r\n  var vFor = {\r\n\r\n    priority: FOR,\r\n    terminal: true,\r\n\r\n    params: ['track-by', 'stagger', 'enter-stagger', 'leave-stagger'],\r\n\r\n    bind: function bind() {\r\n      // support \"item in/of items\" syntax\r\n      var inMatch = this.expression.match(/(.*) (?:in|of) (.*)/);\r\n      if (inMatch) {\r\n        var itMatch = inMatch[1].match(/\\((.*),(.*)\\)/);\r\n        if (itMatch) {\r\n          this.iterator = itMatch[1].trim();\r\n          this.alias = itMatch[2].trim();\r\n        } else {\r\n          this.alias = inMatch[1].trim();\r\n        }\r\n        this.expression = inMatch[2];\r\n      }\r\n\r\n      if (!this.alias) {\r\n        'development' !== 'production' && warn('Invalid v-for expression \"' + this.descriptor.raw + '\": ' + 'alias is required.', this.vm);\r\n        return;\r\n      }\r\n\r\n      // uid as a cache identifier\r\n      this.id = '__v-for__' + ++uid$3;\r\n\r\n      // check if this is an option list,\r\n      // so that we know if we need to update the <select>'s\r\n      // v-model when the option list has changed.\r\n      // because v-model has a lower priority than v-for,\r\n      // the v-model is not bound here yet, so we have to\r\n      // retrive it in the actual updateModel() function.\r\n      var tag = this.el.tagName;\r\n      this.isOption = (tag === 'OPTION' || tag === 'OPTGROUP') && this.el.parentNode.tagName === 'SELECT';\r\n\r\n      // setup anchor nodes\r\n      this.start = createAnchor('v-for-start');\r\n      this.end = createAnchor('v-for-end');\r\n      replace(this.el, this.end);\r\n      before(this.start, this.end);\r\n\r\n      // cache\r\n      this.cache = Object.create(null);\r\n\r\n      // fragment factory\r\n      this.factory = new FragmentFactory(this.vm, this.el);\r\n    },\r\n\r\n    update: function update(data) {\r\n      this.diff(data);\r\n      this.updateRef();\r\n      this.updateModel();\r\n    },\r\n\r\n    /**\r\n     * Diff, based on new data and old data, determine the\r\n     * minimum amount of DOM manipulations needed to make the\r\n     * DOM reflect the new data Array.\r\n     *\r\n     * The algorithm diffs the new data Array by storing a\r\n     * hidden reference to an owner vm instance on previously\r\n     * seen data. This allows us to achieve O(n) which is\r\n     * better than a levenshtein distance based algorithm,\r\n     * which is O(m * n).\r\n     *\r\n     * @param {Array} data\r\n     */\r\n\r\n    diff: function diff(data) {\r\n      // check if the Array was converted from an Object\r\n      var item = data[0];\r\n      var convertedFromObject = this.fromObject = isObject(item) && hasOwn(item, '$key') && hasOwn(item, '$value');\r\n\r\n      var trackByKey = this.params.trackBy;\r\n      var oldFrags = this.frags;\r\n      var frags = this.frags = new Array(data.length);\r\n      var alias = this.alias;\r\n      var iterator = this.iterator;\r\n      var start = this.start;\r\n      var end = this.end;\r\n      var inDocument = inDoc(start);\r\n      var init = !oldFrags;\r\n      var i, l, frag, key, value, primitive;\r\n\r\n      // First pass, go through the new Array and fill up\r\n      // the new frags array. If a piece of data has a cached\r\n      // instance for it, we reuse it. Otherwise build a new\r\n      // instance.\r\n      for (i = 0, l = data.length; i < l; i++) {\r\n        item = data[i];\r\n        key = convertedFromObject ? item.$key : null;\r\n        value = convertedFromObject ? item.$value : item;\r\n        primitive = !isObject(value);\r\n        frag = !init && this.getCachedFrag(value, i, key);\r\n        if (frag) {\r\n          // reusable fragment\r\n          frag.reused = true;\r\n          // update $index\r\n          frag.scope.$index = i;\r\n          // update $key\r\n          if (key) {\r\n            frag.scope.$key = key;\r\n          }\r\n          // update iterator\r\n          if (iterator) {\r\n            frag.scope[iterator] = key !== null ? key : i;\r\n          }\r\n          // update data for track-by, object repeat &\r\n          // primitive values.\r\n          if (trackByKey || convertedFromObject || primitive) {\r\n            withoutConversion(function () {\r\n              frag.scope[alias] = value;\r\n            });\r\n          }\r\n        } else {\r\n          // new isntance\r\n          frag = this.create(value, alias, i, key);\r\n          frag.fresh = !init;\r\n        }\r\n        frags[i] = frag;\r\n        if (init) {\r\n          frag.before(end);\r\n        }\r\n      }\r\n\r\n      // we're done for the initial render.\r\n      if (init) {\r\n        return;\r\n      }\r\n\r\n      // Second pass, go through the old fragments and\r\n      // destroy those who are not reused (and remove them\r\n      // from cache)\r\n      var removalIndex = 0;\r\n      var totalRemoved = oldFrags.length - frags.length;\r\n      // when removing a large number of fragments, watcher removal\r\n      // turns out to be a perf bottleneck, so we batch the watcher\r\n      // removals into a single filter call!\r\n      this.vm._vForRemoving = true;\r\n      for (i = 0, l = oldFrags.length; i < l; i++) {\r\n        frag = oldFrags[i];\r\n        if (!frag.reused) {\r\n          this.deleteCachedFrag(frag);\r\n          this.remove(frag, removalIndex++, totalRemoved, inDocument);\r\n        }\r\n      }\r\n      this.vm._vForRemoving = false;\r\n      if (removalIndex) {\r\n        this.vm._watchers = this.vm._watchers.filter(function (w) {\r\n          return w.active;\r\n        });\r\n      }\r\n\r\n      // Final pass, move/insert new fragments into the\r\n      // right place.\r\n      var targetPrev, prevEl, currentPrev;\r\n      var insertionIndex = 0;\r\n      for (i = 0, l = frags.length; i < l; i++) {\r\n        frag = frags[i];\r\n        // this is the frag that we should be after\r\n        targetPrev = frags[i - 1];\r\n        prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;\r\n        if (frag.reused && !frag.staggerCb) {\r\n          currentPrev = findPrevFrag(frag, start, this.id);\r\n          if (currentPrev !== targetPrev && (!currentPrev ||\r\n          // optimization for moving a single item.\r\n          // thanks to suggestions by @livoras in #1807\r\n          findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {\r\n            this.move(frag, prevEl);\r\n          }\r\n        } else {\r\n          // new instance, or still in stagger.\r\n          // insert with updated stagger index.\r\n          this.insert(frag, insertionIndex++, prevEl, inDocument);\r\n        }\r\n        frag.reused = frag.fresh = false;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Create a new fragment instance.\r\n     *\r\n     * @param {*} value\r\n     * @param {String} alias\r\n     * @param {Number} index\r\n     * @param {String} [key]\r\n     * @return {Fragment}\r\n     */\r\n\r\n    create: function create(value, alias, index, key) {\r\n      var host = this._host;\r\n      // create iteration scope\r\n      var parentScope = this._scope || this.vm;\r\n      var scope = Object.create(parentScope);\r\n      // ref holder for the scope\r\n      scope.$refs = Object.create(parentScope.$refs);\r\n      scope.$els = Object.create(parentScope.$els);\r\n      // make sure point $parent to parent scope\r\n      scope.$parent = parentScope;\r\n      // for two-way binding on alias\r\n      scope.$forContext = this;\r\n      // define scope properties\r\n      // important: define the scope alias without forced conversion\r\n      // so that frozen data structures remain non-reactive.\r\n      withoutConversion(function () {\r\n        defineReactive(scope, alias, value);\r\n      });\r\n      defineReactive(scope, '$index', index);\r\n      if (key) {\r\n        defineReactive(scope, '$key', key);\r\n      } else if (scope.$key) {\r\n        // avoid accidental fallback\r\n        def(scope, '$key', null);\r\n      }\r\n      if (this.iterator) {\r\n        defineReactive(scope, this.iterator, key !== null ? key : index);\r\n      }\r\n      var frag = this.factory.create(host, scope, this._frag);\r\n      frag.forId = this.id;\r\n      this.cacheFrag(value, frag, index, key);\r\n      return frag;\r\n    },\r\n\r\n    /**\r\n     * Update the v-ref on owner vm.\r\n     */\r\n\r\n    updateRef: function updateRef() {\r\n      var ref = this.descriptor.ref;\r\n      if (!ref) return;\r\n      var hash = (this._scope || this.vm).$refs;\r\n      var refs;\r\n      if (!this.fromObject) {\r\n        refs = this.frags.map(findVmFromFrag);\r\n      } else {\r\n        refs = {};\r\n        this.frags.forEach(function (frag) {\r\n          refs[frag.scope.$key] = findVmFromFrag(frag);\r\n        });\r\n      }\r\n      hash[ref] = refs;\r\n    },\r\n\r\n    /**\r\n     * For option lists, update the containing v-model on\r\n     * parent <select>.\r\n     */\r\n\r\n    updateModel: function updateModel() {\r\n      if (this.isOption) {\r\n        var parent = this.start.parentNode;\r\n        var model = parent && parent.__v_model;\r\n        if (model) {\r\n          model.forceUpdate();\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Insert a fragment. Handles staggering.\r\n     *\r\n     * @param {Fragment} frag\r\n     * @param {Number} index\r\n     * @param {Node} prevEl\r\n     * @param {Boolean} inDocument\r\n     */\r\n\r\n    insert: function insert(frag, index, prevEl, inDocument) {\r\n      if (frag.staggerCb) {\r\n        frag.staggerCb.cancel();\r\n        frag.staggerCb = null;\r\n      }\r\n      var staggerAmount = this.getStagger(frag, index, null, 'enter');\r\n      if (inDocument && staggerAmount) {\r\n        // create an anchor and insert it synchronously,\r\n        // so that we can resolve the correct order without\r\n        // worrying about some elements not inserted yet\r\n        var anchor = frag.staggerAnchor;\r\n        if (!anchor) {\r\n          anchor = frag.staggerAnchor = createAnchor('stagger-anchor');\r\n          anchor.__v_frag = frag;\r\n        }\r\n        after(anchor, prevEl);\r\n        var op = frag.staggerCb = cancellable(function () {\r\n          frag.staggerCb = null;\r\n          frag.before(anchor);\r\n          remove(anchor);\r\n        });\r\n        setTimeout(op, staggerAmount);\r\n      } else {\r\n        var target = prevEl.nextSibling;\r\n        /* istanbul ignore if */\r\n        if (!target) {\r\n          // reset end anchor position in case the position was messed up\r\n          // by an external drag-n-drop library.\r\n          after(this.end, prevEl);\r\n          target = this.end;\r\n        }\r\n        frag.before(target);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Remove a fragment. Handles staggering.\r\n     *\r\n     * @param {Fragment} frag\r\n     * @param {Number} index\r\n     * @param {Number} total\r\n     * @param {Boolean} inDocument\r\n     */\r\n\r\n    remove: function remove(frag, index, total, inDocument) {\r\n      if (frag.staggerCb) {\r\n        frag.staggerCb.cancel();\r\n        frag.staggerCb = null;\r\n        // it's not possible for the same frag to be removed\r\n        // twice, so if we have a pending stagger callback,\r\n        // it means this frag is queued for enter but removed\r\n        // before its transition started. Since it is already\r\n        // destroyed, we can just leave it in detached state.\r\n        return;\r\n      }\r\n      var staggerAmount = this.getStagger(frag, index, total, 'leave');\r\n      if (inDocument && staggerAmount) {\r\n        var op = frag.staggerCb = cancellable(function () {\r\n          frag.staggerCb = null;\r\n          frag.remove();\r\n        });\r\n        setTimeout(op, staggerAmount);\r\n      } else {\r\n        frag.remove();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Move a fragment to a new position.\r\n     * Force no transition.\r\n     *\r\n     * @param {Fragment} frag\r\n     * @param {Node} prevEl\r\n     */\r\n\r\n    move: function move(frag, prevEl) {\r\n      // fix a common issue with Sortable:\r\n      // if prevEl doesn't have nextSibling, this means it's\r\n      // been dragged after the end anchor. Just re-position\r\n      // the end anchor to the end of the container.\r\n      /* istanbul ignore if */\r\n      if (!prevEl.nextSibling) {\r\n        this.end.parentNode.appendChild(this.end);\r\n      }\r\n      frag.before(prevEl.nextSibling, false);\r\n    },\r\n\r\n    /**\r\n     * Cache a fragment using track-by or the object key.\r\n     *\r\n     * @param {*} value\r\n     * @param {Fragment} frag\r\n     * @param {Number} index\r\n     * @param {String} [key]\r\n     */\r\n\r\n    cacheFrag: function cacheFrag(value, frag, index, key) {\r\n      var trackByKey = this.params.trackBy;\r\n      var cache = this.cache;\r\n      var primitive = !isObject(value);\r\n      var id;\r\n      if (key || trackByKey || primitive) {\r\n        id = getTrackByKey(index, key, value, trackByKey);\r\n        if (!cache[id]) {\r\n          cache[id] = frag;\r\n        } else if (trackByKey !== '$index') {\r\n          'development' !== 'production' && this.warnDuplicate(value);\r\n        }\r\n      } else {\r\n        id = this.id;\r\n        if (hasOwn(value, id)) {\r\n          if (value[id] === null) {\r\n            value[id] = frag;\r\n          } else {\r\n            'development' !== 'production' && this.warnDuplicate(value);\r\n          }\r\n        } else if (Object.isExtensible(value)) {\r\n          def(value, id, frag);\r\n        } else if ('development' !== 'production') {\r\n          warn('Frozen v-for objects cannot be automatically tracked, make sure to ' + 'provide a track-by key.');\r\n        }\r\n      }\r\n      frag.raw = value;\r\n    },\r\n\r\n    /**\r\n     * Get a cached fragment from the value/index/key\r\n     *\r\n     * @param {*} value\r\n     * @param {Number} index\r\n     * @param {String} key\r\n     * @return {Fragment}\r\n     */\r\n\r\n    getCachedFrag: function getCachedFrag(value, index, key) {\r\n      var trackByKey = this.params.trackBy;\r\n      var primitive = !isObject(value);\r\n      var frag;\r\n      if (key || trackByKey || primitive) {\r\n        var id = getTrackByKey(index, key, value, trackByKey);\r\n        frag = this.cache[id];\r\n      } else {\r\n        frag = value[this.id];\r\n      }\r\n      if (frag && (frag.reused || frag.fresh)) {\r\n        'development' !== 'production' && this.warnDuplicate(value);\r\n      }\r\n      return frag;\r\n    },\r\n\r\n    /**\r\n     * Delete a fragment from cache.\r\n     *\r\n     * @param {Fragment} frag\r\n     */\r\n\r\n    deleteCachedFrag: function deleteCachedFrag(frag) {\r\n      var value = frag.raw;\r\n      var trackByKey = this.params.trackBy;\r\n      var scope = frag.scope;\r\n      var index = scope.$index;\r\n      // fix #948: avoid accidentally fall through to\r\n      // a parent repeater which happens to have $key.\r\n      var key = hasOwn(scope, '$key') && scope.$key;\r\n      var primitive = !isObject(value);\r\n      if (trackByKey || key || primitive) {\r\n        var id = getTrackByKey(index, key, value, trackByKey);\r\n        this.cache[id] = null;\r\n      } else {\r\n        value[this.id] = null;\r\n        frag.raw = null;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Get the stagger amount for an insertion/removal.\r\n     *\r\n     * @param {Fragment} frag\r\n     * @param {Number} index\r\n     * @param {Number} total\r\n     * @param {String} type\r\n     */\r\n\r\n    getStagger: function getStagger(frag, index, total, type) {\r\n      type = type + 'Stagger';\r\n      var trans = frag.node.__v_trans;\r\n      var hooks = trans && trans.hooks;\r\n      var hook = hooks && (hooks[type] || hooks.stagger);\r\n      return hook ? hook.call(frag, index, total) : index * parseInt(this.params[type] || this.params.stagger, 10);\r\n    },\r\n\r\n    /**\r\n     * Pre-process the value before piping it through the\r\n     * filters. This is passed to and called by the watcher.\r\n     */\r\n\r\n    _preProcess: function _preProcess(value) {\r\n      // regardless of type, store the un-filtered raw value.\r\n      this.rawValue = value;\r\n      return value;\r\n    },\r\n\r\n    /**\r\n     * Post-process the value after it has been piped through\r\n     * the filters. This is passed to and called by the watcher.\r\n     *\r\n     * It is necessary for this to be called during the\r\n     * watcher's dependency collection phase because we want\r\n     * the v-for to update when the source Object is mutated.\r\n     */\r\n\r\n    _postProcess: function _postProcess(value) {\r\n      if (isArray(value)) {\r\n        return value;\r\n      } else if (isPlainObject(value)) {\r\n        // convert plain object to array.\r\n        var keys = Object.keys(value);\r\n        var i = keys.length;\r\n        var res = new Array(i);\r\n        var key;\r\n        while (i--) {\r\n          key = keys[i];\r\n          res[i] = {\r\n            $key: key,\r\n            $value: value[key]\r\n          };\r\n        }\r\n        return res;\r\n      } else {\r\n        if (typeof value === 'number' && !isNaN(value)) {\r\n          value = range(value);\r\n        }\r\n        return value || [];\r\n      }\r\n    },\r\n\r\n    unbind: function unbind() {\r\n      if (this.descriptor.ref) {\r\n        (this._scope || this.vm).$refs[this.descriptor.ref] = null;\r\n      }\r\n      if (this.frags) {\r\n        var i = this.frags.length;\r\n        var frag;\r\n        while (i--) {\r\n          frag = this.frags[i];\r\n          this.deleteCachedFrag(frag);\r\n          frag.destroy();\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Helper to find the previous element that is a fragment\r\n   * anchor. This is necessary because a destroyed frag's\r\n   * element could still be lingering in the DOM before its\r\n   * leaving transition finishes, but its inserted flag\r\n   * should have been set to false so we can skip them.\r\n   *\r\n   * If this is a block repeat, we want to make sure we only\r\n   * return frag that is bound to this v-for. (see #929)\r\n   *\r\n   * @param {Fragment} frag\r\n   * @param {Comment|Text} anchor\r\n   * @param {String} id\r\n   * @return {Fragment}\r\n   */\r\n\r\n  function findPrevFrag(frag, anchor, id) {\r\n    var el = frag.node.previousSibling;\r\n    /* istanbul ignore if */\r\n    if (!el) return;\r\n    frag = el.__v_frag;\r\n    while ((!frag || frag.forId !== id || !frag.inserted) && el !== anchor) {\r\n      el = el.previousSibling;\r\n      /* istanbul ignore if */\r\n      if (!el) return;\r\n      frag = el.__v_frag;\r\n    }\r\n    return frag;\r\n  }\r\n\r\n  /**\r\n   * Find a vm from a fragment.\r\n   *\r\n   * @param {Fragment} frag\r\n   * @return {Vue|undefined}\r\n   */\r\n\r\n  function findVmFromFrag(frag) {\r\n    var node = frag.node;\r\n    // handle multi-node frag\r\n    if (frag.end) {\r\n      while (!node.__vue__ && node !== frag.end && node.nextSibling) {\r\n        node = node.nextSibling;\r\n      }\r\n    }\r\n    return node.__vue__;\r\n  }\r\n\r\n  /**\r\n   * Create a range array from given number.\r\n   *\r\n   * @param {Number} n\r\n   * @return {Array}\r\n   */\r\n\r\n  function range(n) {\r\n    var i = -1;\r\n    var ret = new Array(Math.floor(n));\r\n    while (++i < n) {\r\n      ret[i] = i;\r\n    }\r\n    return ret;\r\n  }\r\n\r\n  /**\r\n   * Get the track by key for an item.\r\n   *\r\n   * @param {Number} index\r\n   * @param {String} key\r\n   * @param {*} value\r\n   * @param {String} [trackByKey]\r\n   */\r\n\r\n  function getTrackByKey(index, key, value, trackByKey) {\r\n    return trackByKey ? trackByKey === '$index' ? index : trackByKey.charAt(0).match(/\\w/) ? getPath(value, trackByKey) : value[trackByKey] : key || value;\r\n  }\r\n\r\n  if ('development' !== 'production') {\r\n    vFor.warnDuplicate = function (value) {\r\n      warn('Duplicate value found in v-for=\"' + this.descriptor.raw + '\": ' + JSON.stringify(value) + '. Use track-by=\"$index\" if ' + 'you are expecting duplicate values.', this.vm);\r\n    };\r\n  }\r\n\r\n  var vIf = {\r\n\r\n    priority: IF,\r\n    terminal: true,\r\n\r\n    bind: function bind() {\r\n      var el = this.el;\r\n      if (!el.__vue__) {\r\n        // check else block\r\n        var next = el.nextElementSibling;\r\n        if (next && getAttr(next, 'v-else') !== null) {\r\n          remove(next);\r\n          this.elseEl = next;\r\n        }\r\n        // check main block\r\n        this.anchor = createAnchor('v-if');\r\n        replace(el, this.anchor);\r\n      } else {\r\n        'development' !== 'production' && warn('v-if=\"' + this.expression + '\" cannot be ' + 'used on an instance root element.', this.vm);\r\n        this.invalid = true;\r\n      }\r\n    },\r\n\r\n    update: function update(value) {\r\n      if (this.invalid) return;\r\n      if (value) {\r\n        if (!this.frag) {\r\n          this.insert();\r\n        }\r\n      } else {\r\n        this.remove();\r\n      }\r\n    },\r\n\r\n    insert: function insert() {\r\n      if (this.elseFrag) {\r\n        this.elseFrag.remove();\r\n        this.elseFrag = null;\r\n      }\r\n      // lazy init factory\r\n      if (!this.factory) {\r\n        this.factory = new FragmentFactory(this.vm, this.el);\r\n      }\r\n      this.frag = this.factory.create(this._host, this._scope, this._frag);\r\n      this.frag.before(this.anchor);\r\n    },\r\n\r\n    remove: function remove() {\r\n      if (this.frag) {\r\n        this.frag.remove();\r\n        this.frag = null;\r\n      }\r\n      if (this.elseEl && !this.elseFrag) {\r\n        if (!this.elseFactory) {\r\n          this.elseFactory = new FragmentFactory(this.elseEl._context || this.vm, this.elseEl);\r\n        }\r\n        this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag);\r\n        this.elseFrag.before(this.anchor);\r\n      }\r\n    },\r\n\r\n    unbind: function unbind() {\r\n      if (this.frag) {\r\n        this.frag.destroy();\r\n      }\r\n      if (this.elseFrag) {\r\n        this.elseFrag.destroy();\r\n      }\r\n    }\r\n  };\r\n\r\n  var show = {\r\n\r\n    bind: function bind() {\r\n      // check else block\r\n      var next = this.el.nextElementSibling;\r\n      if (next && getAttr(next, 'v-else') !== null) {\r\n        this.elseEl = next;\r\n      }\r\n    },\r\n\r\n    update: function update(value) {\r\n      this.apply(this.el, value);\r\n      if (this.elseEl) {\r\n        this.apply(this.elseEl, !value);\r\n      }\r\n    },\r\n\r\n    apply: function apply(el, value) {\r\n      if (inDoc(el)) {\r\n        applyTransition(el, value ? 1 : -1, toggle, this.vm);\r\n      } else {\r\n        toggle();\r\n      }\r\n      function toggle() {\r\n        el.style.display = value ? '' : 'none';\r\n      }\r\n    }\r\n  };\r\n\r\n  var text$2 = {\r\n\r\n    bind: function bind() {\r\n      var self = this;\r\n      var el = this.el;\r\n      var isRange = el.type === 'range';\r\n      var lazy = this.params.lazy;\r\n      var number = this.params.number;\r\n      var debounce = this.params.debounce;\r\n\r\n      // handle composition events.\r\n      //   http://blog.evanyou.me/2014/01/03/composition-event/\r\n      // skip this for Android because it handles composition\r\n      // events quite differently. Android doesn't trigger\r\n      // composition events for language input methods e.g.\r\n      // Chinese, but instead triggers them for spelling\r\n      // suggestions... (see Discussion/#162)\r\n      var composing = false;\r\n      if (!isAndroid && !isRange) {\r\n        this.on('compositionstart', function () {\r\n          composing = true;\r\n        });\r\n        this.on('compositionend', function () {\r\n          composing = false;\r\n          // in IE11 the \"compositionend\" event fires AFTER\r\n          // the \"input\" event, so the input handler is blocked\r\n          // at the end... have to call it here.\r\n          //\r\n          // #1327: in lazy mode this is unecessary.\r\n          if (!lazy) {\r\n            self.listener();\r\n          }\r\n        });\r\n      }\r\n\r\n      // prevent messing with the input when user is typing,\r\n      // and force update on blur.\r\n      this.focused = false;\r\n      if (!isRange && !lazy) {\r\n        this.on('focus', function () {\r\n          self.focused = true;\r\n        });\r\n        this.on('blur', function () {\r\n          self.focused = false;\r\n          // do not sync value after fragment removal (#2017)\r\n          if (!self._frag || self._frag.inserted) {\r\n            self.rawListener();\r\n          }\r\n        });\r\n      }\r\n\r\n      // Now attach the main listener\r\n      this.listener = this.rawListener = function () {\r\n        if (composing || !self._bound) {\r\n          return;\r\n        }\r\n        var val = number || isRange ? toNumber(el.value) : el.value;\r\n        self.set(val);\r\n        // force update on next tick to avoid lock & same value\r\n        // also only update when user is not typing\r\n        nextTick(function () {\r\n          if (self._bound && !self.focused) {\r\n            self.update(self._watcher.value);\r\n          }\r\n        });\r\n      };\r\n\r\n      // apply debounce\r\n      if (debounce) {\r\n        this.listener = _debounce(this.listener, debounce);\r\n      }\r\n\r\n      // Support jQuery events, since jQuery.trigger() doesn't\r\n      // trigger native events in some cases and some plugins\r\n      // rely on $.trigger()\r\n      //\r\n      // We want to make sure if a listener is attached using\r\n      // jQuery, it is also removed with jQuery, that's why\r\n      // we do the check for each directive instance and\r\n      // store that check result on itself. This also allows\r\n      // easier test coverage control by unsetting the global\r\n      // jQuery variable in tests.\r\n      this.hasjQuery = typeof jQuery === 'function';\r\n      if (this.hasjQuery) {\r\n        var method = jQuery.fn.on ? 'on' : 'bind';\r\n        jQuery(el)[method]('change', this.rawListener);\r\n        if (!lazy) {\r\n          jQuery(el)[method]('input', this.listener);\r\n        }\r\n      } else {\r\n        this.on('change', this.rawListener);\r\n        if (!lazy) {\r\n          this.on('input', this.listener);\r\n        }\r\n      }\r\n\r\n      // IE9 doesn't fire input event on backspace/del/cut\r\n      if (!lazy && isIE9) {\r\n        this.on('cut', function () {\r\n          nextTick(self.listener);\r\n        });\r\n        this.on('keyup', function (e) {\r\n          if (e.keyCode === 46 || e.keyCode === 8) {\r\n            self.listener();\r\n          }\r\n        });\r\n      }\r\n\r\n      // set initial value if present\r\n      if (el.hasAttribute('value') || el.tagName === 'TEXTAREA' && el.value.trim()) {\r\n        this.afterBind = this.listener;\r\n      }\r\n    },\r\n\r\n    update: function update(value) {\r\n      // #3029 only update when the value changes. This prevent\r\n      // browsers from overwriting values like selectionStart\r\n      value = _toString(value);\r\n      if (value !== this.el.value) this.el.value = value;\r\n    },\r\n\r\n    unbind: function unbind() {\r\n      var el = this.el;\r\n      if (this.hasjQuery) {\r\n        var method = jQuery.fn.off ? 'off' : 'unbind';\r\n        jQuery(el)[method]('change', this.listener);\r\n        jQuery(el)[method]('input', this.listener);\r\n      }\r\n    }\r\n  };\r\n\r\n  var radio = {\r\n\r\n    bind: function bind() {\r\n      var self = this;\r\n      var el = this.el;\r\n\r\n      this.getValue = function () {\r\n        // value overwrite via v-bind:value\r\n        if (el.hasOwnProperty('_value')) {\r\n          return el._value;\r\n        }\r\n        var val = el.value;\r\n        if (self.params.number) {\r\n          val = toNumber(val);\r\n        }\r\n        return val;\r\n      };\r\n\r\n      this.listener = function () {\r\n        self.set(self.getValue());\r\n      };\r\n      this.on('change', this.listener);\r\n\r\n      if (el.hasAttribute('checked')) {\r\n        this.afterBind = this.listener;\r\n      }\r\n    },\r\n\r\n    update: function update(value) {\r\n      this.el.checked = looseEqual(value, this.getValue());\r\n    }\r\n  };\r\n\r\n  var select = {\r\n\r\n    bind: function bind() {\r\n      var _this = this;\r\n\r\n      var self = this;\r\n      var el = this.el;\r\n\r\n      // method to force update DOM using latest value.\r\n      this.forceUpdate = function () {\r\n        if (self._watcher) {\r\n          self.update(self._watcher.get());\r\n        }\r\n      };\r\n\r\n      // check if this is a multiple select\r\n      var multiple = this.multiple = el.hasAttribute('multiple');\r\n\r\n      // attach listener\r\n      this.listener = function () {\r\n        var value = getValue(el, multiple);\r\n        value = self.params.number ? isArray(value) ? value.map(toNumber) : toNumber(value) : value;\r\n        self.set(value);\r\n      };\r\n      this.on('change', this.listener);\r\n\r\n      // if has initial value, set afterBind\r\n      var initValue = getValue(el, multiple, true);\r\n      if (multiple && initValue.length || !multiple && initValue !== null) {\r\n        this.afterBind = this.listener;\r\n      }\r\n\r\n      // All major browsers except Firefox resets\r\n      // selectedIndex with value -1 to 0 when the element\r\n      // is appended to a new parent, therefore we have to\r\n      // force a DOM update whenever that happens...\r\n      this.vm.$on('hook:attached', function () {\r\n        nextTick(_this.forceUpdate);\r\n      });\r\n      if (!inDoc(el)) {\r\n        nextTick(this.forceUpdate);\r\n      }\r\n    },\r\n\r\n    update: function update(value) {\r\n      var el = this.el;\r\n      el.selectedIndex = -1;\r\n      var multi = this.multiple && isArray(value);\r\n      var options = el.options;\r\n      var i = options.length;\r\n      var op, val;\r\n      while (i--) {\r\n        op = options[i];\r\n        val = op.hasOwnProperty('_value') ? op._value : op.value;\r\n        /* eslint-disable eqeqeq */\r\n        op.selected = multi ? indexOf$1(value, val) > -1 : looseEqual(value, val);\r\n        /* eslint-enable eqeqeq */\r\n      }\r\n    },\r\n\r\n    unbind: function unbind() {\r\n      /* istanbul ignore next */\r\n      this.vm.$off('hook:attached', this.forceUpdate);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Get select value\r\n   *\r\n   * @param {SelectElement} el\r\n   * @param {Boolean} multi\r\n   * @param {Boolean} init\r\n   * @return {Array|*}\r\n   */\r\n\r\n  function getValue(el, multi, init) {\r\n    var res = multi ? [] : null;\r\n    var op, val, selected;\r\n    for (var i = 0, l = el.options.length; i < l; i++) {\r\n      op = el.options[i];\r\n      selected = init ? op.hasAttribute('selected') : op.selected;\r\n      if (selected) {\r\n        val = op.hasOwnProperty('_value') ? op._value : op.value;\r\n        if (multi) {\r\n          res.push(val);\r\n        } else {\r\n          return val;\r\n        }\r\n      }\r\n    }\r\n    return res;\r\n  }\r\n\r\n  /**\r\n   * Native Array.indexOf uses strict equal, but in this\r\n   * case we need to match string/numbers with custom equal.\r\n   *\r\n   * @param {Array} arr\r\n   * @param {*} val\r\n   */\r\n\r\n  function indexOf$1(arr, val) {\r\n    var i = arr.length;\r\n    while (i--) {\r\n      if (looseEqual(arr[i], val)) {\r\n        return i;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  var checkbox = {\r\n\r\n    bind: function bind() {\r\n      var self = this;\r\n      var el = this.el;\r\n\r\n      this.getValue = function () {\r\n        return el.hasOwnProperty('_value') ? el._value : self.params.number ? toNumber(el.value) : el.value;\r\n      };\r\n\r\n      function getBooleanValue() {\r\n        var val = el.checked;\r\n        if (val && el.hasOwnProperty('_trueValue')) {\r\n          return el._trueValue;\r\n        }\r\n        if (!val && el.hasOwnProperty('_falseValue')) {\r\n          return el._falseValue;\r\n        }\r\n        return val;\r\n      }\r\n\r\n      this.listener = function () {\r\n        var model = self._watcher.value;\r\n        if (isArray(model)) {\r\n          var val = self.getValue();\r\n          if (el.checked) {\r\n            if (indexOf(model, val) < 0) {\r\n              model.push(val);\r\n            }\r\n          } else {\r\n            model.$remove(val);\r\n          }\r\n        } else {\r\n          self.set(getBooleanValue());\r\n        }\r\n      };\r\n\r\n      this.on('change', this.listener);\r\n      if (el.hasAttribute('checked')) {\r\n        this.afterBind = this.listener;\r\n      }\r\n    },\r\n\r\n    update: function update(value) {\r\n      var el = this.el;\r\n      if (isArray(value)) {\r\n        el.checked = indexOf(value, this.getValue()) > -1;\r\n      } else {\r\n        if (el.hasOwnProperty('_trueValue')) {\r\n          el.checked = looseEqual(value, el._trueValue);\r\n        } else {\r\n          el.checked = !!value;\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  var handlers = {\r\n    text: text$2,\r\n    radio: radio,\r\n    select: select,\r\n    checkbox: checkbox\r\n  };\r\n\r\n  var model = {\r\n\r\n    priority: MODEL,\r\n    twoWay: true,\r\n    handlers: handlers,\r\n    params: ['lazy', 'number', 'debounce'],\r\n\r\n    /**\r\n     * Possible elements:\r\n     *   <select>\r\n     *   <textarea>\r\n     *   <input type=\"*\">\r\n     *     - text\r\n     *     - checkbox\r\n     *     - radio\r\n     *     - number\r\n     */\r\n\r\n    bind: function bind() {\r\n      // friendly warning...\r\n      this.checkFilters();\r\n      if (this.hasRead && !this.hasWrite) {\r\n        'development' !== 'production' && warn('It seems you are using a read-only filter with ' + 'v-model=\"' + this.descriptor.raw + '\". ' + 'You might want to use a two-way filter to ensure correct behavior.', this.vm);\r\n      }\r\n      var el = this.el;\r\n      var tag = el.tagName;\r\n      var handler;\r\n      if (tag === 'INPUT') {\r\n        handler = handlers[el.type] || handlers.text;\r\n      } else if (tag === 'SELECT') {\r\n        handler = handlers.select;\r\n      } else if (tag === 'TEXTAREA') {\r\n        handler = handlers.text;\r\n      } else {\r\n        'development' !== 'production' && warn('v-model does not support element type: ' + tag, this.vm);\r\n        return;\r\n      }\r\n      el.__v_model = this;\r\n      handler.bind.call(this);\r\n      this.update = handler.update;\r\n      this._unbind = handler.unbind;\r\n    },\r\n\r\n    /**\r\n     * Check read/write filter stats.\r\n     */\r\n\r\n    checkFilters: function checkFilters() {\r\n      var filters = this.filters;\r\n      if (!filters) return;\r\n      var i = filters.length;\r\n      while (i--) {\r\n        var filter = resolveAsset(this.vm.$options, 'filters', filters[i].name);\r\n        if (typeof filter === 'function' || filter.read) {\r\n          this.hasRead = true;\r\n        }\r\n        if (filter.write) {\r\n          this.hasWrite = true;\r\n        }\r\n      }\r\n    },\r\n\r\n    unbind: function unbind() {\r\n      this.el.__v_model = null;\r\n      this._unbind && this._unbind();\r\n    }\r\n  };\r\n\r\n  // keyCode aliases\r\n  var keyCodes = {\r\n    esc: 27,\r\n    tab: 9,\r\n    enter: 13,\r\n    space: 32,\r\n    'delete': [8, 46],\r\n    up: 38,\r\n    left: 37,\r\n    right: 39,\r\n    down: 40\r\n  };\r\n\r\n  function keyFilter(handler, keys) {\r\n    var codes = keys.map(function (key) {\r\n      var charCode = key.charCodeAt(0);\r\n      if (charCode > 47 && charCode < 58) {\r\n        return parseInt(key, 10);\r\n      }\r\n      if (key.length === 1) {\r\n        charCode = key.toUpperCase().charCodeAt(0);\r\n        if (charCode > 64 && charCode < 91) {\r\n          return charCode;\r\n        }\r\n      }\r\n      return keyCodes[key];\r\n    });\r\n    codes = [].concat.apply([], codes);\r\n    return function keyHandler(e) {\r\n      if (codes.indexOf(e.keyCode) > -1) {\r\n        return handler.call(this, e);\r\n      }\r\n    };\r\n  }\r\n\r\n  function stopFilter(handler) {\r\n    return function stopHandler(e) {\r\n      e.stopPropagation();\r\n      return handler.call(this, e);\r\n    };\r\n  }\r\n\r\n  function preventFilter(handler) {\r\n    return function preventHandler(e) {\r\n      e.preventDefault();\r\n      return handler.call(this, e);\r\n    };\r\n  }\r\n\r\n  function selfFilter(handler) {\r\n    return function selfHandler(e) {\r\n      if (e.target === e.currentTarget) {\r\n        return handler.call(this, e);\r\n      }\r\n    };\r\n  }\r\n\r\n  var on$1 = {\r\n\r\n    priority: ON,\r\n    acceptStatement: true,\r\n    keyCodes: keyCodes,\r\n\r\n    bind: function bind() {\r\n      // deal with iframes\r\n      if (this.el.tagName === 'IFRAME' && this.arg !== 'load') {\r\n        var self = this;\r\n        this.iframeBind = function () {\r\n          on(self.el.contentWindow, self.arg, self.handler, self.modifiers.capture);\r\n        };\r\n        this.on('load', this.iframeBind);\r\n      }\r\n    },\r\n\r\n    update: function update(handler) {\r\n      // stub a noop for v-on with no value,\r\n      // e.g. @mousedown.prevent\r\n      if (!this.descriptor.raw) {\r\n        handler = function () {};\r\n      }\r\n\r\n      if (typeof handler !== 'function') {\r\n        'development' !== 'production' && warn('v-on:' + this.arg + '=\"' + this.expression + '\" expects a function value, ' + 'got ' + handler, this.vm);\r\n        return;\r\n      }\r\n\r\n      // apply modifiers\r\n      if (this.modifiers.stop) {\r\n        handler = stopFilter(handler);\r\n      }\r\n      if (this.modifiers.prevent) {\r\n        handler = preventFilter(handler);\r\n      }\r\n      if (this.modifiers.self) {\r\n        handler = selfFilter(handler);\r\n      }\r\n      // key filter\r\n      var keys = Object.keys(this.modifiers).filter(function (key) {\r\n        return key !== 'stop' && key !== 'prevent' && key !== 'self' && key !== 'capture';\r\n      });\r\n      if (keys.length) {\r\n        handler = keyFilter(handler, keys);\r\n      }\r\n\r\n      this.reset();\r\n      this.handler = handler;\r\n\r\n      if (this.iframeBind) {\r\n        this.iframeBind();\r\n      } else {\r\n        on(this.el, this.arg, this.handler, this.modifiers.capture);\r\n      }\r\n    },\r\n\r\n    reset: function reset() {\r\n      var el = this.iframeBind ? this.el.contentWindow : this.el;\r\n      if (this.handler) {\r\n        off(el, this.arg, this.handler);\r\n      }\r\n    },\r\n\r\n    unbind: function unbind() {\r\n      this.reset();\r\n    }\r\n  };\r\n\r\n  var prefixes = ['-webkit-', '-moz-', '-ms-'];\r\n  var camelPrefixes = ['Webkit', 'Moz', 'ms'];\r\n  var importantRE = /!important;?$/;\r\n  var propCache = Object.create(null);\r\n\r\n  var testEl = null;\r\n\r\n  var style = {\r\n\r\n    deep: true,\r\n\r\n    update: function update(value) {\r\n      if (typeof value === 'string') {\r\n        this.el.style.cssText = value;\r\n      } else if (isArray(value)) {\r\n        this.handleObject(value.reduce(extend, {}));\r\n      } else {\r\n        this.handleObject(value || {});\r\n      }\r\n    },\r\n\r\n    handleObject: function handleObject(value) {\r\n      // cache object styles so that only changed props\r\n      // are actually updated.\r\n      var cache = this.cache || (this.cache = {});\r\n      var name, val;\r\n      for (name in cache) {\r\n        if (!(name in value)) {\r\n          this.handleSingle(name, null);\r\n          delete cache[name];\r\n        }\r\n      }\r\n      for (name in value) {\r\n        val = value[name];\r\n        if (val !== cache[name]) {\r\n          cache[name] = val;\r\n          this.handleSingle(name, val);\r\n        }\r\n      }\r\n    },\r\n\r\n    handleSingle: function handleSingle(prop, value) {\r\n      prop = normalize(prop);\r\n      if (!prop) return; // unsupported prop\r\n      // cast possible numbers/booleans into strings\r\n      if (value != null) value += '';\r\n      if (value) {\r\n        var isImportant = importantRE.test(value) ? 'important' : '';\r\n        if (isImportant) {\r\n          /* istanbul ignore if */\r\n          if ('development' !== 'production') {\r\n            warn('It\\'s probably a bad idea to use !important with inline rules. ' + 'This feature will be deprecated in a future version of Vue.');\r\n          }\r\n          value = value.replace(importantRE, '').trim();\r\n          this.el.style.setProperty(prop.kebab, value, isImportant);\r\n        } else {\r\n          this.el.style[prop.camel] = value;\r\n        }\r\n      } else {\r\n        this.el.style[prop.camel] = '';\r\n      }\r\n    }\r\n\r\n  };\r\n\r\n  /**\r\n   * Normalize a CSS property name.\r\n   * - cache result\r\n   * - auto prefix\r\n   * - camelCase -> dash-case\r\n   *\r\n   * @param {String} prop\r\n   * @return {String}\r\n   */\r\n\r\n  function normalize(prop) {\r\n    if (propCache[prop]) {\r\n      return propCache[prop];\r\n    }\r\n    var res = prefix(prop);\r\n    propCache[prop] = propCache[res] = res;\r\n    return res;\r\n  }\r\n\r\n  /**\r\n   * Auto detect the appropriate prefix for a CSS property.\r\n   * https://gist.github.com/paulirish/523692\r\n   *\r\n   * @param {String} prop\r\n   * @return {String}\r\n   */\r\n\r\n  function prefix(prop) {\r\n    prop = hyphenate(prop);\r\n    var camel = camelize(prop);\r\n    var upper = camel.charAt(0).toUpperCase() + camel.slice(1);\r\n    if (!testEl) {\r\n      testEl = document.createElement('div');\r\n    }\r\n    var i = prefixes.length;\r\n    var prefixed;\r\n    if (camel !== 'filter' && camel in testEl.style) {\r\n      return {\r\n        kebab: prop,\r\n        camel: camel\r\n      };\r\n    }\r\n    while (i--) {\r\n      prefixed = camelPrefixes[i] + upper;\r\n      if (prefixed in testEl.style) {\r\n        return {\r\n          kebab: prefixes[i] + prop,\r\n          camel: prefixed\r\n        };\r\n      }\r\n    }\r\n  }\r\n\r\n  // xlink\r\n  var xlinkNS = 'http://www.w3.org/1999/xlink';\r\n  var xlinkRE = /^xlink:/;\r\n\r\n  // check for attributes that prohibit interpolations\r\n  var disallowedInterpAttrRE = /^v-|^:|^@|^(?:is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/;\r\n  // these attributes should also set their corresponding properties\r\n  // because they only affect the initial state of the element\r\n  var attrWithPropsRE = /^(?:value|checked|selected|muted)$/;\r\n  // these attributes expect enumrated values of \"true\" or \"false\"\r\n  // but are not boolean attributes\r\n  var enumeratedAttrRE = /^(?:draggable|contenteditable|spellcheck)$/;\r\n\r\n  // these attributes should set a hidden property for\r\n  // binding v-model to object values\r\n  var modelProps = {\r\n    value: '_value',\r\n    'true-value': '_trueValue',\r\n    'false-value': '_falseValue'\r\n  };\r\n\r\n  var bind$1 = {\r\n\r\n    priority: BIND,\r\n\r\n    bind: function bind() {\r\n      var attr = this.arg;\r\n      var tag = this.el.tagName;\r\n      // should be deep watch on object mode\r\n      if (!attr) {\r\n        this.deep = true;\r\n      }\r\n      // handle interpolation bindings\r\n      var descriptor = this.descriptor;\r\n      var tokens = descriptor.interp;\r\n      if (tokens) {\r\n        // handle interpolations with one-time tokens\r\n        if (descriptor.hasOneTime) {\r\n          this.expression = tokensToExp(tokens, this._scope || this.vm);\r\n        }\r\n\r\n        // only allow binding on native attributes\r\n        if (disallowedInterpAttrRE.test(attr) || attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT')) {\r\n          'development' !== 'production' && warn(attr + '=\"' + descriptor.raw + '\": ' + 'attribute interpolation is not allowed in Vue.js ' + 'directives and special attributes.', this.vm);\r\n          this.el.removeAttribute(attr);\r\n          this.invalid = true;\r\n        }\r\n\r\n        /* istanbul ignore if */\r\n        if ('development' !== 'production') {\r\n          var raw = attr + '=\"' + descriptor.raw + '\": ';\r\n          // warn src\r\n          if (attr === 'src') {\r\n            warn(raw + 'interpolation in \"src\" attribute will cause ' + 'a 404 request. Use v-bind:src instead.', this.vm);\r\n          }\r\n\r\n          // warn style\r\n          if (attr === 'style') {\r\n            warn(raw + 'interpolation in \"style\" attribute will cause ' + 'the attribute to be discarded in Internet Explorer. ' + 'Use v-bind:style instead.', this.vm);\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    update: function update(value) {\r\n      if (this.invalid) {\r\n        return;\r\n      }\r\n      var attr = this.arg;\r\n      if (this.arg) {\r\n        this.handleSingle(attr, value);\r\n      } else {\r\n        this.handleObject(value || {});\r\n      }\r\n    },\r\n\r\n    // share object handler with v-bind:class\r\n    handleObject: style.handleObject,\r\n\r\n    handleSingle: function handleSingle(attr, value) {\r\n      var el = this.el;\r\n      var interp = this.descriptor.interp;\r\n      if (this.modifiers.camel) {\r\n        attr = camelize(attr);\r\n      }\r\n      if (!interp && attrWithPropsRE.test(attr) && attr in el) {\r\n        var attrValue = attr === 'value' ? value == null // IE9 will set input.value to \"null\" for null...\r\n        ? '' : value : value;\r\n\r\n        if (el[attr] !== attrValue) {\r\n          el[attr] = attrValue;\r\n        }\r\n      }\r\n      // set model props\r\n      var modelProp = modelProps[attr];\r\n      if (!interp && modelProp) {\r\n        el[modelProp] = value;\r\n        // update v-model if present\r\n        var model = el.__v_model;\r\n        if (model) {\r\n          model.listener();\r\n        }\r\n      }\r\n      // do not set value attribute for textarea\r\n      if (attr === 'value' && el.tagName === 'TEXTAREA') {\r\n        el.removeAttribute(attr);\r\n        return;\r\n      }\r\n      // update attribute\r\n      if (enumeratedAttrRE.test(attr)) {\r\n        el.setAttribute(attr, value ? 'true' : 'false');\r\n      } else if (value != null && value !== false) {\r\n        if (attr === 'class') {\r\n          // handle edge case #1960:\r\n          // class interpolation should not overwrite Vue transition class\r\n          if (el.__v_trans) {\r\n            value += ' ' + el.__v_trans.id + '-transition';\r\n          }\r\n          setClass(el, value);\r\n        } else if (xlinkRE.test(attr)) {\r\n          el.setAttributeNS(xlinkNS, attr, value === true ? '' : value);\r\n        } else {\r\n          el.setAttribute(attr, value === true ? '' : value);\r\n        }\r\n      } else {\r\n        el.removeAttribute(attr);\r\n      }\r\n    }\r\n  };\r\n\r\n  var el = {\r\n\r\n    priority: EL,\r\n\r\n    bind: function bind() {\r\n      /* istanbul ignore if */\r\n      if (!this.arg) {\r\n        return;\r\n      }\r\n      var id = this.id = camelize(this.arg);\r\n      var refs = (this._scope || this.vm).$els;\r\n      if (hasOwn(refs, id)) {\r\n        refs[id] = this.el;\r\n      } else {\r\n        defineReactive(refs, id, this.el);\r\n      }\r\n    },\r\n\r\n    unbind: function unbind() {\r\n      var refs = (this._scope || this.vm).$els;\r\n      if (refs[this.id] === this.el) {\r\n        refs[this.id] = null;\r\n      }\r\n    }\r\n  };\r\n\r\n  var ref = {\r\n    bind: function bind() {\r\n      'development' !== 'production' && warn('v-ref:' + this.arg + ' must be used on a child ' + 'component. Found on <' + this.el.tagName.toLowerCase() + '>.', this.vm);\r\n    }\r\n  };\r\n\r\n  var cloak = {\r\n    bind: function bind() {\r\n      var el = this.el;\r\n      this.vm.$once('pre-hook:compiled', function () {\r\n        el.removeAttribute('v-cloak');\r\n      });\r\n    }\r\n  };\r\n\r\n  // must export plain object\r\n  var directives = {\r\n    text: text$1,\r\n    html: html,\r\n    'for': vFor,\r\n    'if': vIf,\r\n    show: show,\r\n    model: model,\r\n    on: on$1,\r\n    bind: bind$1,\r\n    el: el,\r\n    ref: ref,\r\n    cloak: cloak\r\n  };\r\n\r\n  var vClass = {\r\n\r\n    deep: true,\r\n\r\n    update: function update(value) {\r\n      if (!value) {\r\n        this.cleanup();\r\n      } else if (typeof value === 'string') {\r\n        this.setClass(value.trim().split(/\\s+/));\r\n      } else {\r\n        this.setClass(normalize$1(value));\r\n      }\r\n    },\r\n\r\n    setClass: function setClass(value) {\r\n      this.cleanup(value);\r\n      for (var i = 0, l = value.length; i < l; i++) {\r\n        var val = value[i];\r\n        if (val) {\r\n          apply(this.el, val, addClass);\r\n        }\r\n      }\r\n      this.prevKeys = value;\r\n    },\r\n\r\n    cleanup: function cleanup(value) {\r\n      var prevKeys = this.prevKeys;\r\n      if (!prevKeys) return;\r\n      var i = prevKeys.length;\r\n      while (i--) {\r\n        var key = prevKeys[i];\r\n        if (!value || value.indexOf(key) < 0) {\r\n          apply(this.el, key, removeClass);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Normalize objects and arrays (potentially containing objects)\r\n   * into array of strings.\r\n   *\r\n   * @param {Object|Array<String|Object>} value\r\n   * @return {Array<String>}\r\n   */\r\n\r\n  function normalize$1(value) {\r\n    var res = [];\r\n    if (isArray(value)) {\r\n      for (var i = 0, l = value.length; i < l; i++) {\r\n        var _key = value[i];\r\n        if (_key) {\r\n          if (typeof _key === 'string') {\r\n            res.push(_key);\r\n          } else {\r\n            for (var k in _key) {\r\n              if (_key[k]) res.push(k);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } else if (isObject(value)) {\r\n      for (var key in value) {\r\n        if (value[key]) res.push(key);\r\n      }\r\n    }\r\n    return res;\r\n  }\r\n\r\n  /**\r\n   * Add or remove a class/classes on an element\r\n   *\r\n   * @param {Element} el\r\n   * @param {String} key The class name. This may or may not\r\n   *                     contain a space character, in such a\r\n   *                     case we'll deal with multiple class\r\n   *                     names at once.\r\n   * @param {Function} fn\r\n   */\r\n\r\n  function apply(el, key, fn) {\r\n    key = key.trim();\r\n    if (key.indexOf(' ') === -1) {\r\n      fn(el, key);\r\n      return;\r\n    }\r\n    // The key contains one or more space characters.\r\n    // Since a class name doesn't accept such characters, we\r\n    // treat it as multiple classes.\r\n    var keys = key.split(/\\s+/);\r\n    for (var i = 0, l = keys.length; i < l; i++) {\r\n      fn(el, keys[i]);\r\n    }\r\n  }\r\n\r\n  var component = {\r\n\r\n    priority: COMPONENT,\r\n\r\n    params: ['keep-alive', 'transition-mode', 'inline-template'],\r\n\r\n    /**\r\n     * Setup. Two possible usages:\r\n     *\r\n     * - static:\r\n     *   <comp> or <div v-component=\"comp\">\r\n     *\r\n     * - dynamic:\r\n     *   <component :is=\"view\">\r\n     */\r\n\r\n    bind: function bind() {\r\n      if (!this.el.__vue__) {\r\n        // keep-alive cache\r\n        this.keepAlive = this.params.keepAlive;\r\n        if (this.keepAlive) {\r\n          this.cache = {};\r\n        }\r\n        // check inline-template\r\n        if (this.params.inlineTemplate) {\r\n          // extract inline template as a DocumentFragment\r\n          this.inlineTemplate = extractContent(this.el, true);\r\n        }\r\n        // component resolution related state\r\n        this.pendingComponentCb = this.Component = null;\r\n        // transition related state\r\n        this.pendingRemovals = 0;\r\n        this.pendingRemovalCb = null;\r\n        // create a ref anchor\r\n        this.anchor = createAnchor('v-component');\r\n        replace(this.el, this.anchor);\r\n        // remove is attribute.\r\n        // this is removed during compilation, but because compilation is\r\n        // cached, when the component is used elsewhere this attribute\r\n        // will remain at link time.\r\n        this.el.removeAttribute('is');\r\n        this.el.removeAttribute(':is');\r\n        // remove ref, same as above\r\n        if (this.descriptor.ref) {\r\n          this.el.removeAttribute('v-ref:' + hyphenate(this.descriptor.ref));\r\n        }\r\n        // if static, build right now.\r\n        if (this.literal) {\r\n          this.setComponent(this.expression);\r\n        }\r\n      } else {\r\n        'development' !== 'production' && warn('cannot mount component \"' + this.expression + '\" ' + 'on already mounted element: ' + this.el);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Public update, called by the watcher in the dynamic\r\n     * literal scenario, e.g. <component :is=\"view\">\r\n     */\r\n\r\n    update: function update(value) {\r\n      if (!this.literal) {\r\n        this.setComponent(value);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Switch dynamic components. May resolve the component\r\n     * asynchronously, and perform transition based on\r\n     * specified transition mode. Accepts a few additional\r\n     * arguments specifically for vue-router.\r\n     *\r\n     * The callback is called when the full transition is\r\n     * finished.\r\n     *\r\n     * @param {String} value\r\n     * @param {Function} [cb]\r\n     */\r\n\r\n    setComponent: function setComponent(value, cb) {\r\n      this.invalidatePending();\r\n      if (!value) {\r\n        // just remove current\r\n        this.unbuild(true);\r\n        this.remove(this.childVM, cb);\r\n        this.childVM = null;\r\n      } else {\r\n        var self = this;\r\n        this.resolveComponent(value, function () {\r\n          self.mountComponent(cb);\r\n        });\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Resolve the component constructor to use when creating\r\n     * the child vm.\r\n     *\r\n     * @param {String|Function} value\r\n     * @param {Function} cb\r\n     */\r\n\r\n    resolveComponent: function resolveComponent(value, cb) {\r\n      var self = this;\r\n      this.pendingComponentCb = cancellable(function (Component) {\r\n        self.ComponentName = Component.options.name || (typeof value === 'string' ? value : null);\r\n        self.Component = Component;\r\n        cb();\r\n      });\r\n      this.vm._resolveComponent(value, this.pendingComponentCb);\r\n    },\r\n\r\n    /**\r\n     * Create a new instance using the current constructor and\r\n     * replace the existing instance. This method doesn't care\r\n     * whether the new component and the old one are actually\r\n     * the same.\r\n     *\r\n     * @param {Function} [cb]\r\n     */\r\n\r\n    mountComponent: function mountComponent(cb) {\r\n      // actual mount\r\n      this.unbuild(true);\r\n      var self = this;\r\n      var activateHooks = this.Component.options.activate;\r\n      var cached = this.getCached();\r\n      var newComponent = this.build();\r\n      if (activateHooks && !cached) {\r\n        this.waitingFor = newComponent;\r\n        callActivateHooks(activateHooks, newComponent, function () {\r\n          if (self.waitingFor !== newComponent) {\r\n            return;\r\n          }\r\n          self.waitingFor = null;\r\n          self.transition(newComponent, cb);\r\n        });\r\n      } else {\r\n        // update ref for kept-alive component\r\n        if (cached) {\r\n          newComponent._updateRef();\r\n        }\r\n        this.transition(newComponent, cb);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * When the component changes or unbinds before an async\r\n     * constructor is resolved, we need to invalidate its\r\n     * pending callback.\r\n     */\r\n\r\n    invalidatePending: function invalidatePending() {\r\n      if (this.pendingComponentCb) {\r\n        this.pendingComponentCb.cancel();\r\n        this.pendingComponentCb = null;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Instantiate/insert a new child vm.\r\n     * If keep alive and has cached instance, insert that\r\n     * instance; otherwise build a new one and cache it.\r\n     *\r\n     * @param {Object} [extraOptions]\r\n     * @return {Vue} - the created instance\r\n     */\r\n\r\n    build: function build(extraOptions) {\r\n      var cached = this.getCached();\r\n      if (cached) {\r\n        return cached;\r\n      }\r\n      if (this.Component) {\r\n        // default options\r\n        var options = {\r\n          name: this.ComponentName,\r\n          el: cloneNode(this.el),\r\n          template: this.inlineTemplate,\r\n          // make sure to add the child with correct parent\r\n          // if this is a transcluded component, its parent\r\n          // should be the transclusion host.\r\n          parent: this._host || this.vm,\r\n          // if no inline-template, then the compiled\r\n          // linker can be cached for better performance.\r\n          _linkerCachable: !this.inlineTemplate,\r\n          _ref: this.descriptor.ref,\r\n          _asComponent: true,\r\n          _isRouterView: this._isRouterView,\r\n          // if this is a transcluded component, context\r\n          // will be the common parent vm of this instance\r\n          // and its host.\r\n          _context: this.vm,\r\n          // if this is inside an inline v-for, the scope\r\n          // will be the intermediate scope created for this\r\n          // repeat fragment. this is used for linking props\r\n          // and container directives.\r\n          _scope: this._scope,\r\n          // pass in the owner fragment of this component.\r\n          // this is necessary so that the fragment can keep\r\n          // track of its contained components in order to\r\n          // call attach/detach hooks for them.\r\n          _frag: this._frag\r\n        };\r\n        // extra options\r\n        // in 1.0.0 this is used by vue-router only\r\n        /* istanbul ignore if */\r\n        if (extraOptions) {\r\n          extend(options, extraOptions);\r\n        }\r\n        var child = new this.Component(options);\r\n        if (this.keepAlive) {\r\n          this.cache[this.Component.cid] = child;\r\n        }\r\n        /* istanbul ignore if */\r\n        if ('development' !== 'production' && this.el.hasAttribute('transition') && child._isFragment) {\r\n          warn('Transitions will not work on a fragment instance. ' + 'Template: ' + child.$options.template, child);\r\n        }\r\n        return child;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Try to get a cached instance of the current component.\r\n     *\r\n     * @return {Vue|undefined}\r\n     */\r\n\r\n    getCached: function getCached() {\r\n      return this.keepAlive && this.cache[this.Component.cid];\r\n    },\r\n\r\n    /**\r\n     * Teardown the current child, but defers cleanup so\r\n     * that we can separate the destroy and removal steps.\r\n     *\r\n     * @param {Boolean} defer\r\n     */\r\n\r\n    unbuild: function unbuild(defer) {\r\n      if (this.waitingFor) {\r\n        if (!this.keepAlive) {\r\n          this.waitingFor.$destroy();\r\n        }\r\n        this.waitingFor = null;\r\n      }\r\n      var child = this.childVM;\r\n      if (!child || this.keepAlive) {\r\n        if (child) {\r\n          // remove ref\r\n          child._inactive = true;\r\n          child._updateRef(true);\r\n        }\r\n        return;\r\n      }\r\n      // the sole purpose of `deferCleanup` is so that we can\r\n      // \"deactivate\" the vm right now and perform DOM removal\r\n      // later.\r\n      child.$destroy(false, defer);\r\n    },\r\n\r\n    /**\r\n     * Remove current destroyed child and manually do\r\n     * the cleanup after removal.\r\n     *\r\n     * @param {Function} cb\r\n     */\r\n\r\n    remove: function remove(child, cb) {\r\n      var keepAlive = this.keepAlive;\r\n      if (child) {\r\n        // we may have a component switch when a previous\r\n        // component is still being transitioned out.\r\n        // we want to trigger only one lastest insertion cb\r\n        // when the existing transition finishes. (#1119)\r\n        this.pendingRemovals++;\r\n        this.pendingRemovalCb = cb;\r\n        var self = this;\r\n        child.$remove(function () {\r\n          self.pendingRemovals--;\r\n          if (!keepAlive) child._cleanup();\r\n          if (!self.pendingRemovals && self.pendingRemovalCb) {\r\n            self.pendingRemovalCb();\r\n            self.pendingRemovalCb = null;\r\n          }\r\n        });\r\n      } else if (cb) {\r\n        cb();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Actually swap the components, depending on the\r\n     * transition mode. Defaults to simultaneous.\r\n     *\r\n     * @param {Vue} target\r\n     * @param {Function} [cb]\r\n     */\r\n\r\n    transition: function transition(target, cb) {\r\n      var self = this;\r\n      var current = this.childVM;\r\n      // for devtool inspection\r\n      if (current) current._inactive = true;\r\n      target._inactive = false;\r\n      this.childVM = target;\r\n      switch (self.params.transitionMode) {\r\n        case 'in-out':\r\n          target.$before(self.anchor, function () {\r\n            self.remove(current, cb);\r\n          });\r\n          break;\r\n        case 'out-in':\r\n          self.remove(current, function () {\r\n            target.$before(self.anchor, cb);\r\n          });\r\n          break;\r\n        default:\r\n          self.remove(current);\r\n          target.$before(self.anchor, cb);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Unbind.\r\n     */\r\n\r\n    unbind: function unbind() {\r\n      this.invalidatePending();\r\n      // Do not defer cleanup when unbinding\r\n      this.unbuild();\r\n      // destroy all keep-alive cached instances\r\n      if (this.cache) {\r\n        for (var key in this.cache) {\r\n          this.cache[key].$destroy();\r\n        }\r\n        this.cache = null;\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Call activate hooks in order (asynchronous)\r\n   *\r\n   * @param {Array} hooks\r\n   * @param {Vue} vm\r\n   * @param {Function} cb\r\n   */\r\n\r\n  function callActivateHooks(hooks, vm, cb) {\r\n    var total = hooks.length;\r\n    var called = 0;\r\n    hooks[0].call(vm, next);\r\n    function next() {\r\n      if (++called >= total) {\r\n        cb();\r\n      } else {\r\n        hooks[called].call(vm, next);\r\n      }\r\n    }\r\n  }\r\n\r\n  var propBindingModes = config._propBindingModes;\r\n  var empty = {};\r\n\r\n  // regexes\r\n  var identRE$1 = /^[$_a-zA-Z]+[\\w$]*$/;\r\n  var settablePathRE = /^[A-Za-z_$][\\w$]*(\\.[A-Za-z_$][\\w$]*|\\[[^\\[\\]]+\\])*$/;\r\n\r\n  /**\r\n   * Compile props on a root element and return\r\n   * a props link function.\r\n   *\r\n   * @param {Element|DocumentFragment} el\r\n   * @param {Array} propOptions\r\n   * @param {Vue} vm\r\n   * @return {Function} propsLinkFn\r\n   */\r\n\r\n  function compileProps(el, propOptions, vm) {\r\n    var props = [];\r\n    var names = Object.keys(propOptions);\r\n    var i = names.length;\r\n    var options, name, attr, value, path, parsed, prop;\r\n    while (i--) {\r\n      name = names[i];\r\n      options = propOptions[name] || empty;\r\n\r\n      if ('development' !== 'production' && name === '$data') {\r\n        warn('Do not use $data as prop.', vm);\r\n        continue;\r\n      }\r\n\r\n      // props could contain dashes, which will be\r\n      // interpreted as minus calculations by the parser\r\n      // so we need to camelize the path here\r\n      path = camelize(name);\r\n      if (!identRE$1.test(path)) {\r\n        'development' !== 'production' && warn('Invalid prop key: \"' + name + '\". Prop keys ' + 'must be valid identifiers.', vm);\r\n        continue;\r\n      }\r\n\r\n      prop = {\r\n        name: name,\r\n        path: path,\r\n        options: options,\r\n        mode: propBindingModes.ONE_WAY,\r\n        raw: null\r\n      };\r\n\r\n      attr = hyphenate(name);\r\n      // first check dynamic version\r\n      if ((value = getBindAttr(el, attr)) === null) {\r\n        if ((value = getBindAttr(el, attr + '.sync')) !== null) {\r\n          prop.mode = propBindingModes.TWO_WAY;\r\n        } else if ((value = getBindAttr(el, attr + '.once')) !== null) {\r\n          prop.mode = propBindingModes.ONE_TIME;\r\n        }\r\n      }\r\n      if (value !== null) {\r\n        // has dynamic binding!\r\n        prop.raw = value;\r\n        parsed = parseDirective(value);\r\n        value = parsed.expression;\r\n        prop.filters = parsed.filters;\r\n        // check binding type\r\n        if (isLiteral(value) && !parsed.filters) {\r\n          // for expressions containing literal numbers and\r\n          // booleans, there's no need to setup a prop binding,\r\n          // so we can optimize them as a one-time set.\r\n          prop.optimizedLiteral = true;\r\n        } else {\r\n          prop.dynamic = true;\r\n          // check non-settable path for two-way bindings\r\n          if ('development' !== 'production' && prop.mode === propBindingModes.TWO_WAY && !settablePathRE.test(value)) {\r\n            prop.mode = propBindingModes.ONE_WAY;\r\n            warn('Cannot bind two-way prop with non-settable ' + 'parent path: ' + value, vm);\r\n          }\r\n        }\r\n        prop.parentPath = value;\r\n\r\n        // warn required two-way\r\n        if ('development' !== 'production' && options.twoWay && prop.mode !== propBindingModes.TWO_WAY) {\r\n          warn('Prop \"' + name + '\" expects a two-way binding type.', vm);\r\n        }\r\n      } else if ((value = getAttr(el, attr)) !== null) {\r\n        // has literal binding!\r\n        prop.raw = value;\r\n      } else if ('development' !== 'production') {\r\n        // check possible camelCase prop usage\r\n        var lowerCaseName = path.toLowerCase();\r\n        value = /[A-Z\\-]/.test(name) && (el.getAttribute(lowerCaseName) || el.getAttribute(':' + lowerCaseName) || el.getAttribute('v-bind:' + lowerCaseName) || el.getAttribute(':' + lowerCaseName + '.once') || el.getAttribute('v-bind:' + lowerCaseName + '.once') || el.getAttribute(':' + lowerCaseName + '.sync') || el.getAttribute('v-bind:' + lowerCaseName + '.sync'));\r\n        if (value) {\r\n          warn('Possible usage error for prop `' + lowerCaseName + '` - ' + 'did you mean `' + attr + '`? HTML is case-insensitive, remember to use ' + 'kebab-case for props in templates.', vm);\r\n        } else if (options.required) {\r\n          // warn missing required\r\n          warn('Missing required prop: ' + name, vm);\r\n        }\r\n      }\r\n      // push prop\r\n      props.push(prop);\r\n    }\r\n    return makePropsLinkFn(props);\r\n  }\r\n\r\n  /**\r\n   * Build a function that applies props to a vm.\r\n   *\r\n   * @param {Array} props\r\n   * @return {Function} propsLinkFn\r\n   */\r\n\r\n  function makePropsLinkFn(props) {\r\n    return function propsLinkFn(vm, scope) {\r\n      // store resolved props info\r\n      vm._props = {};\r\n      var inlineProps = vm.$options.propsData;\r\n      var i = props.length;\r\n      var prop, path, options, value, raw;\r\n      while (i--) {\r\n        prop = props[i];\r\n        raw = prop.raw;\r\n        path = prop.path;\r\n        options = prop.options;\r\n        vm._props[path] = prop;\r\n        if (inlineProps && hasOwn(inlineProps, path)) {\r\n          initProp(vm, prop, inlineProps[path]);\r\n        }if (raw === null) {\r\n          // initialize absent prop\r\n          initProp(vm, prop, undefined);\r\n        } else if (prop.dynamic) {\r\n          // dynamic prop\r\n          if (prop.mode === propBindingModes.ONE_TIME) {\r\n            // one time binding\r\n            value = (scope || vm._context || vm).$get(prop.parentPath);\r\n            initProp(vm, prop, value);\r\n          } else {\r\n            if (vm._context) {\r\n              // dynamic binding\r\n              vm._bindDir({\r\n                name: 'prop',\r\n                def: propDef,\r\n                prop: prop\r\n              }, null, null, scope); // el, host, scope\r\n            } else {\r\n                // root instance\r\n                initProp(vm, prop, vm.$get(prop.parentPath));\r\n              }\r\n          }\r\n        } else if (prop.optimizedLiteral) {\r\n          // optimized literal, cast it and just set once\r\n          var stripped = stripQuotes(raw);\r\n          value = stripped === raw ? toBoolean(toNumber(raw)) : stripped;\r\n          initProp(vm, prop, value);\r\n        } else {\r\n          // string literal, but we need to cater for\r\n          // Boolean props with no value, or with same\r\n          // literal value (e.g. disabled=\"disabled\")\r\n          // see https://github.com/vuejs/vue-loader/issues/182\r\n          value = options.type === Boolean && (raw === '' || raw === hyphenate(prop.name)) ? true : raw;\r\n          initProp(vm, prop, value);\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Process a prop with a rawValue, applying necessary coersions,\r\n   * default values & assertions and call the given callback with\r\n   * processed value.\r\n   *\r\n   * @param {Vue} vm\r\n   * @param {Object} prop\r\n   * @param {*} rawValue\r\n   * @param {Function} fn\r\n   */\r\n\r\n  function processPropValue(vm, prop, rawValue, fn) {\r\n    var isSimple = prop.dynamic && isSimplePath(prop.parentPath);\r\n    var value = rawValue;\r\n    if (value === undefined) {\r\n      value = getPropDefaultValue(vm, prop);\r\n    }\r\n    value = coerceProp(prop, value, vm);\r\n    var coerced = value !== rawValue;\r\n    if (!assertProp(prop, value, vm)) {\r\n      value = undefined;\r\n    }\r\n    if (isSimple && !coerced) {\r\n      withoutConversion(function () {\r\n        fn(value);\r\n      });\r\n    } else {\r\n      fn(value);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set a prop's initial value on a vm and its data object.\r\n   *\r\n   * @param {Vue} vm\r\n   * @param {Object} prop\r\n   * @param {*} value\r\n   */\r\n\r\n  function initProp(vm, prop, value) {\r\n    processPropValue(vm, prop, value, function (value) {\r\n      defineReactive(vm, prop.path, value);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update a prop's value on a vm.\r\n   *\r\n   * @param {Vue} vm\r\n   * @param {Object} prop\r\n   * @param {*} value\r\n   */\r\n\r\n  function updateProp(vm, prop, value) {\r\n    processPropValue(vm, prop, value, function (value) {\r\n      vm[prop.path] = value;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get the default value of a prop.\r\n   *\r\n   * @param {Vue} vm\r\n   * @param {Object} prop\r\n   * @return {*}\r\n   */\r\n\r\n  function getPropDefaultValue(vm, prop) {\r\n    // no default, return undefined\r\n    var options = prop.options;\r\n    if (!hasOwn(options, 'default')) {\r\n      // absent boolean value defaults to false\r\n      return options.type === Boolean ? false : undefined;\r\n    }\r\n    var def = options['default'];\r\n    // warn against non-factory defaults for Object & Array\r\n    if (isObject(def)) {\r\n      'development' !== 'production' && warn('Invalid default value for prop \"' + prop.name + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\r\n    }\r\n    // call factory function for non-Function types\r\n    return typeof def === 'function' && options.type !== Function ? def.call(vm) : def;\r\n  }\r\n\r\n  /**\r\n   * Assert whether a prop is valid.\r\n   *\r\n   * @param {Object} prop\r\n   * @param {*} value\r\n   * @param {Vue} vm\r\n   */\r\n\r\n  function assertProp(prop, value, vm) {\r\n    if (!prop.options.required && ( // non-required\r\n    prop.raw === null || // abscent\r\n    value == null) // null or undefined\r\n    ) {\r\n        return true;\r\n      }\r\n    var options = prop.options;\r\n    var type = options.type;\r\n    var valid = !type;\r\n    var expectedTypes = [];\r\n    if (type) {\r\n      if (!isArray(type)) {\r\n        type = [type];\r\n      }\r\n      for (var i = 0; i < type.length && !valid; i++) {\r\n        var assertedType = assertType(value, type[i]);\r\n        expectedTypes.push(assertedType.expectedType);\r\n        valid = assertedType.valid;\r\n      }\r\n    }\r\n    if (!valid) {\r\n      if ('development' !== 'production') {\r\n        warn('Invalid prop: type check failed for prop \"' + prop.name + '\".' + ' Expected ' + expectedTypes.map(formatType).join(', ') + ', got ' + formatValue(value) + '.', vm);\r\n      }\r\n      return false;\r\n    }\r\n    var validator = options.validator;\r\n    if (validator) {\r\n      if (!validator(value)) {\r\n        'development' !== 'production' && warn('Invalid prop: custom validator check failed for prop \"' + prop.name + '\".', vm);\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Force parsing value with coerce option.\r\n   *\r\n   * @param {*} value\r\n   * @param {Object} options\r\n   * @return {*}\r\n   */\r\n\r\n  function coerceProp(prop, value, vm) {\r\n    var coerce = prop.options.coerce;\r\n    if (!coerce) {\r\n      return value;\r\n    }\r\n    if (typeof coerce === 'function') {\r\n      return coerce(value);\r\n    } else {\r\n      'development' !== 'production' && warn('Invalid coerce for prop \"' + prop.name + '\": expected function, got ' + typeof coerce + '.', vm);\r\n      return value;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Assert the type of a value\r\n   *\r\n   * @param {*} value\r\n   * @param {Function} type\r\n   * @return {Object}\r\n   */\r\n\r\n  function assertType(value, type) {\r\n    var valid;\r\n    var expectedType;\r\n    if (type === String) {\r\n      expectedType = 'string';\r\n      valid = typeof value === expectedType;\r\n    } else if (type === Number) {\r\n      expectedType = 'number';\r\n      valid = typeof value === expectedType;\r\n    } else if (type === Boolean) {\r\n      expectedType = 'boolean';\r\n      valid = typeof value === expectedType;\r\n    } else if (type === Function) {\r\n      expectedType = 'function';\r\n      valid = typeof value === expectedType;\r\n    } else if (type === Object) {\r\n      expectedType = 'object';\r\n      valid = isPlainObject(value);\r\n    } else if (type === Array) {\r\n      expectedType = 'array';\r\n      valid = isArray(value);\r\n    } else {\r\n      valid = value instanceof type;\r\n    }\r\n    return {\r\n      valid: valid,\r\n      expectedType: expectedType\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Format type for output\r\n   *\r\n   * @param {String} type\r\n   * @return {String}\r\n   */\r\n\r\n  function formatType(type) {\r\n    return type ? type.charAt(0).toUpperCase() + type.slice(1) : 'custom type';\r\n  }\r\n\r\n  /**\r\n   * Format value\r\n   *\r\n   * @param {*} value\r\n   * @return {String}\r\n   */\r\n\r\n  function formatValue(val) {\r\n    return Object.prototype.toString.call(val).slice(8, -1);\r\n  }\r\n\r\n  var bindingModes = config._propBindingModes;\r\n\r\n  var propDef = {\r\n\r\n    bind: function bind() {\r\n      var child = this.vm;\r\n      var parent = child._context;\r\n      // passed in from compiler directly\r\n      var prop = this.descriptor.prop;\r\n      var childKey = prop.path;\r\n      var parentKey = prop.parentPath;\r\n      var twoWay = prop.mode === bindingModes.TWO_WAY;\r\n\r\n      var parentWatcher = this.parentWatcher = new Watcher(parent, parentKey, function (val) {\r\n        updateProp(child, prop, val);\r\n      }, {\r\n        twoWay: twoWay,\r\n        filters: prop.filters,\r\n        // important: props need to be observed on the\r\n        // v-for scope if present\r\n        scope: this._scope\r\n      });\r\n\r\n      // set the child initial value.\r\n      initProp(child, prop, parentWatcher.value);\r\n\r\n      // setup two-way binding\r\n      if (twoWay) {\r\n        // important: defer the child watcher creation until\r\n        // the created hook (after data observation)\r\n        var self = this;\r\n        child.$once('pre-hook:created', function () {\r\n          self.childWatcher = new Watcher(child, childKey, function (val) {\r\n            parentWatcher.set(val);\r\n          }, {\r\n            // ensure sync upward before parent sync down.\r\n            // this is necessary in cases e.g. the child\r\n            // mutates a prop array, then replaces it. (#1683)\r\n            sync: true\r\n          });\r\n        });\r\n      }\r\n    },\r\n\r\n    unbind: function unbind() {\r\n      this.parentWatcher.teardown();\r\n      if (this.childWatcher) {\r\n        this.childWatcher.teardown();\r\n      }\r\n    }\r\n  };\r\n\r\n  var queue$1 = [];\r\n  var queued = false;\r\n\r\n  /**\r\n   * Push a job into the queue.\r\n   *\r\n   * @param {Function} job\r\n   */\r\n\r\n  function pushJob(job) {\r\n    queue$1.push(job);\r\n    if (!queued) {\r\n      queued = true;\r\n      nextTick(flush);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Flush the queue, and do one forced reflow before\r\n   * triggering transitions.\r\n   */\r\n\r\n  function flush() {\r\n    // Force layout\r\n    var f = document.documentElement.offsetHeight;\r\n    for (var i = 0; i < queue$1.length; i++) {\r\n      queue$1[i]();\r\n    }\r\n    queue$1 = [];\r\n    queued = false;\r\n    // dummy return, so js linters don't complain about\r\n    // unused variable f\r\n    return f;\r\n  }\r\n\r\n  var TYPE_TRANSITION = 'transition';\r\n  var TYPE_ANIMATION = 'animation';\r\n  var transDurationProp = transitionProp + 'Duration';\r\n  var animDurationProp = animationProp + 'Duration';\r\n\r\n  /**\r\n   * If a just-entered element is applied the\r\n   * leave class while its enter transition hasn't started yet,\r\n   * and the transitioned property has the same value for both\r\n   * enter/leave, then the leave transition will be skipped and\r\n   * the transitionend event never fires. This function ensures\r\n   * its callback to be called after a transition has started\r\n   * by waiting for double raf.\r\n   *\r\n   * It falls back to setTimeout on devices that support CSS\r\n   * transitions but not raf (e.g. Android 4.2 browser) - since\r\n   * these environments are usually slow, we are giving it a\r\n   * relatively large timeout.\r\n   */\r\n\r\n  var raf = inBrowser && window.requestAnimationFrame;\r\n  var waitForTransitionStart = raf\r\n  /* istanbul ignore next */\r\n  ? function (fn) {\r\n    raf(function () {\r\n      raf(fn);\r\n    });\r\n  } : function (fn) {\r\n    setTimeout(fn, 50);\r\n  };\r\n\r\n  /**\r\n   * A Transition object that encapsulates the state and logic\r\n   * of the transition.\r\n   *\r\n   * @param {Element} el\r\n   * @param {String} id\r\n   * @param {Object} hooks\r\n   * @param {Vue} vm\r\n   */\r\n  function Transition(el, id, hooks, vm) {\r\n    this.id = id;\r\n    this.el = el;\r\n    this.enterClass = hooks && hooks.enterClass || id + '-enter';\r\n    this.leaveClass = hooks && hooks.leaveClass || id + '-leave';\r\n    this.hooks = hooks;\r\n    this.vm = vm;\r\n    // async state\r\n    this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null;\r\n    this.justEntered = false;\r\n    this.entered = this.left = false;\r\n    this.typeCache = {};\r\n    // check css transition type\r\n    this.type = hooks && hooks.type;\r\n    /* istanbul ignore if */\r\n    if ('development' !== 'production') {\r\n      if (this.type && this.type !== TYPE_TRANSITION && this.type !== TYPE_ANIMATION) {\r\n        warn('invalid CSS transition type for transition=\"' + this.id + '\": ' + this.type, vm);\r\n      }\r\n    }\r\n    // bind\r\n    var self = this;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone'].forEach(function (m) {\r\n      self[m] = bind(self[m], self);\r\n    });\r\n  }\r\n\r\n  var p$1 = Transition.prototype;\r\n\r\n  /**\r\n   * Start an entering transition.\r\n   *\r\n   * 1. enter transition triggered\r\n   * 2. call beforeEnter hook\r\n   * 3. add enter class\r\n   * 4. insert/show element\r\n   * 5. call enter hook (with possible explicit js callback)\r\n   * 6. reflow\r\n   * 7. based on transition type:\r\n   *    - transition:\r\n   *        remove class now, wait for transitionend,\r\n   *        then done if there's no explicit js callback.\r\n   *    - animation:\r\n   *        wait for animationend, remove class,\r\n   *        then done if there's no explicit js callback.\r\n   *    - no css transition:\r\n   *        done now if there's no explicit js callback.\r\n   * 8. wait for either done or js callback, then call\r\n   *    afterEnter hook.\r\n   *\r\n   * @param {Function} op - insert/show the element\r\n   * @param {Function} [cb]\r\n   */\r\n\r\n  p$1.enter = function (op, cb) {\r\n    this.cancelPending();\r\n    this.callHook('beforeEnter');\r\n    this.cb = cb;\r\n    addClass(this.el, this.enterClass);\r\n    op();\r\n    this.entered = false;\r\n    this.callHookWithCb('enter');\r\n    if (this.entered) {\r\n      return; // user called done synchronously.\r\n    }\r\n    this.cancel = this.hooks && this.hooks.enterCancelled;\r\n    pushJob(this.enterNextTick);\r\n  };\r\n\r\n  /**\r\n   * The \"nextTick\" phase of an entering transition, which is\r\n   * to be pushed into a queue and executed after a reflow so\r\n   * that removing the class can trigger a CSS transition.\r\n   */\r\n\r\n  p$1.enterNextTick = function () {\r\n    var _this = this;\r\n\r\n    // prevent transition skipping\r\n    this.justEntered = true;\r\n    waitForTransitionStart(function () {\r\n      _this.justEntered = false;\r\n    });\r\n    var enterDone = this.enterDone;\r\n    var type = this.getCssTransitionType(this.enterClass);\r\n    if (!this.pendingJsCb) {\r\n      if (type === TYPE_TRANSITION) {\r\n        // trigger transition by removing enter class now\r\n        removeClass(this.el, this.enterClass);\r\n        this.setupCssCb(transitionEndEvent, enterDone);\r\n      } else if (type === TYPE_ANIMATION) {\r\n        this.setupCssCb(animationEndEvent, enterDone);\r\n      } else {\r\n        enterDone();\r\n      }\r\n    } else if (type === TYPE_TRANSITION) {\r\n      removeClass(this.el, this.enterClass);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * The \"cleanup\" phase of an entering transition.\r\n   */\r\n\r\n  p$1.enterDone = function () {\r\n    this.entered = true;\r\n    this.cancel = this.pendingJsCb = null;\r\n    removeClass(this.el, this.enterClass);\r\n    this.callHook('afterEnter');\r\n    if (this.cb) this.cb();\r\n  };\r\n\r\n  /**\r\n   * Start a leaving transition.\r\n   *\r\n   * 1. leave transition triggered.\r\n   * 2. call beforeLeave hook\r\n   * 3. add leave class (trigger css transition)\r\n   * 4. call leave hook (with possible explicit js callback)\r\n   * 5. reflow if no explicit js callback is provided\r\n   * 6. based on transition type:\r\n   *    - transition or animation:\r\n   *        wait for end event, remove class, then done if\r\n   *        there's no explicit js callback.\r\n   *    - no css transition:\r\n   *        done if there's no explicit js callback.\r\n   * 7. wait for either done or js callback, then call\r\n   *    afterLeave hook.\r\n   *\r\n   * @param {Function} op - remove/hide the element\r\n   * @param {Function} [cb]\r\n   */\r\n\r\n  p$1.leave = function (op, cb) {\r\n    this.cancelPending();\r\n    this.callHook('beforeLeave');\r\n    this.op = op;\r\n    this.cb = cb;\r\n    addClass(this.el, this.leaveClass);\r\n    this.left = false;\r\n    this.callHookWithCb('leave');\r\n    if (this.left) {\r\n      return; // user called done synchronously.\r\n    }\r\n    this.cancel = this.hooks && this.hooks.leaveCancelled;\r\n    // only need to handle leaveDone if\r\n    // 1. the transition is already done (synchronously called\r\n    //    by the user, which causes this.op set to null)\r\n    // 2. there's no explicit js callback\r\n    if (this.op && !this.pendingJsCb) {\r\n      // if a CSS transition leaves immediately after enter,\r\n      // the transitionend event never fires. therefore we\r\n      // detect such cases and end the leave immediately.\r\n      if (this.justEntered) {\r\n        this.leaveDone();\r\n      } else {\r\n        pushJob(this.leaveNextTick);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * The \"nextTick\" phase of a leaving transition.\r\n   */\r\n\r\n  p$1.leaveNextTick = function () {\r\n    var type = this.getCssTransitionType(this.leaveClass);\r\n    if (type) {\r\n      var event = type === TYPE_TRANSITION ? transitionEndEvent : animationEndEvent;\r\n      this.setupCssCb(event, this.leaveDone);\r\n    } else {\r\n      this.leaveDone();\r\n    }\r\n  };\r\n\r\n  /**\r\n   * The \"cleanup\" phase of a leaving transition.\r\n   */\r\n\r\n  p$1.leaveDone = function () {\r\n    this.left = true;\r\n    this.cancel = this.pendingJsCb = null;\r\n    this.op();\r\n    removeClass(this.el, this.leaveClass);\r\n    this.callHook('afterLeave');\r\n    if (this.cb) this.cb();\r\n    this.op = null;\r\n  };\r\n\r\n  /**\r\n   * Cancel any pending callbacks from a previously running\r\n   * but not finished transition.\r\n   */\r\n\r\n  p$1.cancelPending = function () {\r\n    this.op = this.cb = null;\r\n    var hasPending = false;\r\n    if (this.pendingCssCb) {\r\n      hasPending = true;\r\n      off(this.el, this.pendingCssEvent, this.pendingCssCb);\r\n      this.pendingCssEvent = this.pendingCssCb = null;\r\n    }\r\n    if (this.pendingJsCb) {\r\n      hasPending = true;\r\n      this.pendingJsCb.cancel();\r\n      this.pendingJsCb = null;\r\n    }\r\n    if (hasPending) {\r\n      removeClass(this.el, this.enterClass);\r\n      removeClass(this.el, this.leaveClass);\r\n    }\r\n    if (this.cancel) {\r\n      this.cancel.call(this.vm, this.el);\r\n      this.cancel = null;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Call a user-provided synchronous hook function.\r\n   *\r\n   * @param {String} type\r\n   */\r\n\r\n  p$1.callHook = function (type) {\r\n    if (this.hooks && this.hooks[type]) {\r\n      this.hooks[type].call(this.vm, this.el);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Call a user-provided, potentially-async hook function.\r\n   * We check for the length of arguments to see if the hook\r\n   * expects a `done` callback. If true, the transition's end\r\n   * will be determined by when the user calls that callback;\r\n   * otherwise, the end is determined by the CSS transition or\r\n   * animation.\r\n   *\r\n   * @param {String} type\r\n   */\r\n\r\n  p$1.callHookWithCb = function (type) {\r\n    var hook = this.hooks && this.hooks[type];\r\n    if (hook) {\r\n      if (hook.length > 1) {\r\n        this.pendingJsCb = cancellable(this[type + 'Done']);\r\n      }\r\n      hook.call(this.vm, this.el, this.pendingJsCb);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Get an element's transition type based on the\r\n   * calculated styles.\r\n   *\r\n   * @param {String} className\r\n   * @return {Number}\r\n   */\r\n\r\n  p$1.getCssTransitionType = function (className) {\r\n    /* istanbul ignore if */\r\n    if (!transitionEndEvent ||\r\n    // skip CSS transitions if page is not visible -\r\n    // this solves the issue of transitionend events not\r\n    // firing until the page is visible again.\r\n    // pageVisibility API is supported in IE10+, same as\r\n    // CSS transitions.\r\n    document.hidden ||\r\n    // explicit js-only transition\r\n    this.hooks && this.hooks.css === false ||\r\n    // element is hidden\r\n    isHidden(this.el)) {\r\n      return;\r\n    }\r\n    var type = this.type || this.typeCache[className];\r\n    if (type) return type;\r\n    var inlineStyles = this.el.style;\r\n    var computedStyles = window.getComputedStyle(this.el);\r\n    var transDuration = inlineStyles[transDurationProp] || computedStyles[transDurationProp];\r\n    if (transDuration && transDuration !== '0s') {\r\n      type = TYPE_TRANSITION;\r\n    } else {\r\n      var animDuration = inlineStyles[animDurationProp] || computedStyles[animDurationProp];\r\n      if (animDuration && animDuration !== '0s') {\r\n        type = TYPE_ANIMATION;\r\n      }\r\n    }\r\n    if (type) {\r\n      this.typeCache[className] = type;\r\n    }\r\n    return type;\r\n  };\r\n\r\n  /**\r\n   * Setup a CSS transitionend/animationend callback.\r\n   *\r\n   * @param {String} event\r\n   * @param {Function} cb\r\n   */\r\n\r\n  p$1.setupCssCb = function (event, cb) {\r\n    this.pendingCssEvent = event;\r\n    var self = this;\r\n    var el = this.el;\r\n    var onEnd = this.pendingCssCb = function (e) {\r\n      if (e.target === el) {\r\n        off(el, event, onEnd);\r\n        self.pendingCssEvent = self.pendingCssCb = null;\r\n        if (!self.pendingJsCb && cb) {\r\n          cb();\r\n        }\r\n      }\r\n    };\r\n    on(el, event, onEnd);\r\n  };\r\n\r\n  /**\r\n   * Check if an element is hidden - in that case we can just\r\n   * skip the transition alltogether.\r\n   *\r\n   * @param {Element} el\r\n   * @return {Boolean}\r\n   */\r\n\r\n  function isHidden(el) {\r\n    if (/svg$/.test(el.namespaceURI)) {\r\n      // SVG elements do not have offset(Width|Height)\r\n      // so we need to check the client rect\r\n      var rect = el.getBoundingClientRect();\r\n      return !(rect.width || rect.height);\r\n    } else {\r\n      return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);\r\n    }\r\n  }\r\n\r\n  var transition$1 = {\r\n\r\n    priority: TRANSITION,\r\n\r\n    update: function update(id, oldId) {\r\n      var el = this.el;\r\n      // resolve on owner vm\r\n      var hooks = resolveAsset(this.vm.$options, 'transitions', id);\r\n      id = id || 'v';\r\n      oldId = oldId || 'v';\r\n      el.__v_trans = new Transition(el, id, hooks, this.vm);\r\n      removeClass(el, oldId + '-transition');\r\n      addClass(el, id + '-transition');\r\n    }\r\n  };\r\n\r\n  var internalDirectives = {\r\n    style: style,\r\n    'class': vClass,\r\n    component: component,\r\n    prop: propDef,\r\n    transition: transition$1\r\n  };\r\n\r\n  // special binding prefixes\r\n  var bindRE = /^v-bind:|^:/;\r\n  var onRE = /^v-on:|^@/;\r\n  var dirAttrRE = /^v-([^:]+)(?:$|:(.*)$)/;\r\n  var modifierRE = /\\.[^\\.]+/g;\r\n  var transitionRE = /^(v-bind:|:)?transition$/;\r\n\r\n  // default directive priority\r\n  var DEFAULT_PRIORITY = 1000;\r\n  var DEFAULT_TERMINAL_PRIORITY = 2000;\r\n\r\n  /**\r\n   * Compile a template and return a reusable composite link\r\n   * function, which recursively contains more link functions\r\n   * inside. This top level compile function would normally\r\n   * be called on instance root nodes, but can also be used\r\n   * for partial compilation if the partial argument is true.\r\n   *\r\n   * The returned composite link function, when called, will\r\n   * return an unlink function that tearsdown all directives\r\n   * created during the linking phase.\r\n   *\r\n   * @param {Element|DocumentFragment} el\r\n   * @param {Object} options\r\n   * @param {Boolean} partial\r\n   * @return {Function}\r\n   */\r\n\r\n  function compile(el, options, partial) {\r\n    // link function for the node itself.\r\n    var nodeLinkFn = partial || !options._asComponent ? compileNode(el, options) : null;\r\n    // link function for the childNodes\r\n    var childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && !isScript(el) && el.hasChildNodes() ? compileNodeList(el.childNodes, options) : null;\r\n\r\n    /**\r\n     * A composite linker function to be called on a already\r\n     * compiled piece of DOM, which instantiates all directive\r\n     * instances.\r\n     *\r\n     * @param {Vue} vm\r\n     * @param {Element|DocumentFragment} el\r\n     * @param {Vue} [host] - host vm of transcluded content\r\n     * @param {Object} [scope] - v-for scope\r\n     * @param {Fragment} [frag] - link context fragment\r\n     * @return {Function|undefined}\r\n     */\r\n\r\n    return function compositeLinkFn(vm, el, host, scope, frag) {\r\n      // cache childNodes before linking parent, fix #657\r\n      var childNodes = toArray(el.childNodes);\r\n      // link\r\n      var dirs = linkAndCapture(function compositeLinkCapturer() {\r\n        if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag);\r\n        if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag);\r\n      }, vm);\r\n      return makeUnlinkFn(vm, dirs);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Apply a linker to a vm/element pair and capture the\r\n   * directives created during the process.\r\n   *\r\n   * @param {Function} linker\r\n   * @param {Vue} vm\r\n   */\r\n\r\n  function linkAndCapture(linker, vm) {\r\n    /* istanbul ignore if */\r\n    if ('development' === 'production') {}\r\n    var originalDirCount = vm._directives.length;\r\n    linker();\r\n    var dirs = vm._directives.slice(originalDirCount);\r\n    dirs.sort(directiveComparator);\r\n    for (var i = 0, l = dirs.length; i < l; i++) {\r\n      dirs[i]._bind();\r\n    }\r\n    return dirs;\r\n  }\r\n\r\n  /**\r\n   * Directive priority sort comparator\r\n   *\r\n   * @param {Object} a\r\n   * @param {Object} b\r\n   */\r\n\r\n  function directiveComparator(a, b) {\r\n    a = a.descriptor.def.priority || DEFAULT_PRIORITY;\r\n    b = b.descriptor.def.priority || DEFAULT_PRIORITY;\r\n    return a > b ? -1 : a === b ? 0 : 1;\r\n  }\r\n\r\n  /**\r\n   * Linker functions return an unlink function that\r\n   * tearsdown all directives instances generated during\r\n   * the process.\r\n   *\r\n   * We create unlink functions with only the necessary\r\n   * information to avoid retaining additional closures.\r\n   *\r\n   * @param {Vue} vm\r\n   * @param {Array} dirs\r\n   * @param {Vue} [context]\r\n   * @param {Array} [contextDirs]\r\n   * @return {Function}\r\n   */\r\n\r\n  function makeUnlinkFn(vm, dirs, context, contextDirs) {\r\n    function unlink(destroying) {\r\n      teardownDirs(vm, dirs, destroying);\r\n      if (context && contextDirs) {\r\n        teardownDirs(context, contextDirs);\r\n      }\r\n    }\r\n    // expose linked directives\r\n    unlink.dirs = dirs;\r\n    return unlink;\r\n  }\r\n\r\n  /**\r\n   * Teardown partial linked directives.\r\n   *\r\n   * @param {Vue} vm\r\n   * @param {Array} dirs\r\n   * @param {Boolean} destroying\r\n   */\r\n\r\n  function teardownDirs(vm, dirs, destroying) {\r\n    var i = dirs.length;\r\n    while (i--) {\r\n      dirs[i]._teardown();\r\n      if ('development' !== 'production' && !destroying) {\r\n        vm._directives.$remove(dirs[i]);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Compile link props on an instance.\r\n   *\r\n   * @param {Vue} vm\r\n   * @param {Element} el\r\n   * @param {Object} props\r\n   * @param {Object} [scope]\r\n   * @return {Function}\r\n   */\r\n\r\n  function compileAndLinkProps(vm, el, props, scope) {\r\n    var propsLinkFn = compileProps(el, props, vm);\r\n    var propDirs = linkAndCapture(function () {\r\n      propsLinkFn(vm, scope);\r\n    }, vm);\r\n    return makeUnlinkFn(vm, propDirs);\r\n  }\r\n\r\n  /**\r\n   * Compile the root element of an instance.\r\n   *\r\n   * 1. attrs on context container (context scope)\r\n   * 2. attrs on the component template root node, if\r\n   *    replace:true (child scope)\r\n   *\r\n   * If this is a fragment instance, we only need to compile 1.\r\n   *\r\n   * @param {Element} el\r\n   * @param {Object} options\r\n   * @param {Object} contextOptions\r\n   * @return {Function}\r\n   */\r\n\r\n  function compileRoot(el, options, contextOptions) {\r\n    var containerAttrs = options._containerAttrs;\r\n    var replacerAttrs = options._replacerAttrs;\r\n    var contextLinkFn, replacerLinkFn;\r\n\r\n    // only need to compile other attributes for\r\n    // non-fragment instances\r\n    if (el.nodeType !== 11) {\r\n      // for components, container and replacer need to be\r\n      // compiled separately and linked in different scopes.\r\n      if (options._asComponent) {\r\n        // 2. container attributes\r\n        if (containerAttrs && contextOptions) {\r\n          contextLinkFn = compileDirectives(containerAttrs, contextOptions);\r\n        }\r\n        if (replacerAttrs) {\r\n          // 3. replacer attributes\r\n          replacerLinkFn = compileDirectives(replacerAttrs, options);\r\n        }\r\n      } else {\r\n        // non-component, just compile as a normal element.\r\n        replacerLinkFn = compileDirectives(el.attributes, options);\r\n      }\r\n    } else if ('development' !== 'production' && containerAttrs) {\r\n      // warn container directives for fragment instances\r\n      var names = containerAttrs.filter(function (attr) {\r\n        // allow vue-loader/vueify scoped css attributes\r\n        return attr.name.indexOf('_v-') < 0 &&\r\n        // allow event listeners\r\n        !onRE.test(attr.name) &&\r\n        // allow slots\r\n        attr.name !== 'slot';\r\n      }).map(function (attr) {\r\n        return '\"' + attr.name + '\"';\r\n      });\r\n      if (names.length) {\r\n        var plural = names.length > 1;\r\n        warn('Attribute' + (plural ? 's ' : ' ') + names.join(', ') + (plural ? ' are' : ' is') + ' ignored on component ' + '<' + options.el.tagName.toLowerCase() + '> because ' + 'the component is a fragment instance: ' + 'http://vuejs.org/guide/components.html#Fragment-Instance');\r\n      }\r\n    }\r\n\r\n    options._containerAttrs = options._replacerAttrs = null;\r\n    return function rootLinkFn(vm, el, scope) {\r\n      // link context scope dirs\r\n      var context = vm._context;\r\n      var contextDirs;\r\n      if (context && contextLinkFn) {\r\n        contextDirs = linkAndCapture(function () {\r\n          contextLinkFn(context, el, null, scope);\r\n        }, context);\r\n      }\r\n\r\n      // link self\r\n      var selfDirs = linkAndCapture(function () {\r\n        if (replacerLinkFn) replacerLinkFn(vm, el);\r\n      }, vm);\r\n\r\n      // return the unlink function that tearsdown context\r\n      // container directives.\r\n      return makeUnlinkFn(vm, selfDirs, context, contextDirs);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Compile a node and return a nodeLinkFn based on the\r\n   * node type.\r\n   *\r\n   * @param {Node} node\r\n   * @param {Object} options\r\n   * @return {Function|null}\r\n   */\r\n\r\n  function compileNode(node, options) {\r\n    var type = node.nodeType;\r\n    if (type === 1 && !isScript(node)) {\r\n      return compileElement(node, options);\r\n    } else if (type === 3 && node.data.trim()) {\r\n      return compileTextNode(node, options);\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Compile an element and return a nodeLinkFn.\r\n   *\r\n   * @param {Element} el\r\n   * @param {Object} options\r\n   * @return {Function|null}\r\n   */\r\n\r\n  function compileElement(el, options) {\r\n    // preprocess textareas.\r\n    // textarea treats its text content as the initial value.\r\n    // just bind it as an attr directive for value.\r\n    if (el.tagName === 'TEXTAREA') {\r\n      var tokens = parseText(el.value);\r\n      if (tokens) {\r\n        el.setAttribute(':value', tokensToExp(tokens));\r\n        el.value = '';\r\n      }\r\n    }\r\n    var linkFn;\r\n    var hasAttrs = el.hasAttributes();\r\n    var attrs = hasAttrs && toArray(el.attributes);\r\n    // check terminal directives (for & if)\r\n    if (hasAttrs) {\r\n      linkFn = checkTerminalDirectives(el, attrs, options);\r\n    }\r\n    // check element directives\r\n    if (!linkFn) {\r\n      linkFn = checkElementDirectives(el, options);\r\n    }\r\n    // check component\r\n    if (!linkFn) {\r\n      linkFn = checkComponent(el, options);\r\n    }\r\n    // normal directives\r\n    if (!linkFn && hasAttrs) {\r\n      linkFn = compileDirectives(attrs, options);\r\n    }\r\n    return linkFn;\r\n  }\r\n\r\n  /**\r\n   * Compile a textNode and return a nodeLinkFn.\r\n   *\r\n   * @param {TextNode} node\r\n   * @param {Object} options\r\n   * @return {Function|null} textNodeLinkFn\r\n   */\r\n\r\n  function compileTextNode(node, options) {\r\n    // skip marked text nodes\r\n    if (node._skip) {\r\n      return removeText;\r\n    }\r\n\r\n    var tokens = parseText(node.wholeText);\r\n    if (!tokens) {\r\n      return null;\r\n    }\r\n\r\n    // mark adjacent text nodes as skipped,\r\n    // because we are using node.wholeText to compile\r\n    // all adjacent text nodes together. This fixes\r\n    // issues in IE where sometimes it splits up a single\r\n    // text node into multiple ones.\r\n    var next = node.nextSibling;\r\n    while (next && next.nodeType === 3) {\r\n      next._skip = true;\r\n      next = next.nextSibling;\r\n    }\r\n\r\n    var frag = document.createDocumentFragment();\r\n    var el, token;\r\n    for (var i = 0, l = tokens.length; i < l; i++) {\r\n      token = tokens[i];\r\n      el = token.tag ? processTextToken(token, options) : document.createTextNode(token.value);\r\n      frag.appendChild(el);\r\n    }\r\n    return makeTextNodeLinkFn(tokens, frag, options);\r\n  }\r\n\r\n  /**\r\n   * Linker for an skipped text node.\r\n   *\r\n   * @param {Vue} vm\r\n   * @param {Text} node\r\n   */\r\n\r\n  function removeText(vm, node) {\r\n    remove(node);\r\n  }\r\n\r\n  /**\r\n   * Process a single text token.\r\n   *\r\n   * @param {Object} token\r\n   * @param {Object} options\r\n   * @return {Node}\r\n   */\r\n\r\n  function processTextToken(token, options) {\r\n    var el;\r\n    if (token.oneTime) {\r\n      el = document.createTextNode(token.value);\r\n    } else {\r\n      if (token.html) {\r\n        el = document.createComment('v-html');\r\n        setTokenType('html');\r\n      } else {\r\n        // IE will clean up empty textNodes during\r\n        // frag.cloneNode(true), so we have to give it\r\n        // something here...\r\n        el = document.createTextNode(' ');\r\n        setTokenType('text');\r\n      }\r\n    }\r\n    function setTokenType(type) {\r\n      if (token.descriptor) return;\r\n      var parsed = parseDirective(token.value);\r\n      token.descriptor = {\r\n        name: type,\r\n        def: directives[type],\r\n        expression: parsed.expression,\r\n        filters: parsed.filters\r\n      };\r\n    }\r\n    return el;\r\n  }\r\n\r\n  /**\r\n   * Build a function that processes a textNode.\r\n   *\r\n   * @param {Array<Object>} tokens\r\n   * @param {DocumentFragment} frag\r\n   */\r\n\r\n  function makeTextNodeLinkFn(tokens, frag) {\r\n    return function textNodeLinkFn(vm, el, host, scope) {\r\n      var fragClone = frag.cloneNode(true);\r\n      var childNodes = toArray(fragClone.childNodes);\r\n      var token, value, node;\r\n      for (var i = 0, l = tokens.length; i < l; i++) {\r\n        token = tokens[i];\r\n        value = token.value;\r\n        if (token.tag) {\r\n          node = childNodes[i];\r\n          if (token.oneTime) {\r\n            value = (scope || vm).$eval(value);\r\n            if (token.html) {\r\n              replace(node, parseTemplate(value, true));\r\n            } else {\r\n              node.data = _toString(value);\r\n            }\r\n          } else {\r\n            vm._bindDir(token.descriptor, node, host, scope);\r\n          }\r\n        }\r\n      }\r\n      replace(el, fragClone);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Compile a node list and return a childLinkFn.\r\n   *\r\n   * @param {NodeList} nodeList\r\n   * @param {Object} options\r\n   * @return {Function|undefined}\r\n   */\r\n\r\n  function compileNodeList(nodeList, options) {\r\n    var linkFns = [];\r\n    var nodeLinkFn, childLinkFn, node;\r\n    for (var i = 0, l = nodeList.length; i < l; i++) {\r\n      node = nodeList[i];\r\n      nodeLinkFn = compileNode(node, options);\r\n      childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && node.tagName !== 'SCRIPT' && node.hasChildNodes() ? compileNodeList(node.childNodes, options) : null;\r\n      linkFns.push(nodeLinkFn, childLinkFn);\r\n    }\r\n    return linkFns.length ? makeChildLinkFn(linkFns) : null;\r\n  }\r\n\r\n  /**\r\n   * Make a child link function for a node's childNodes.\r\n   *\r\n   * @param {Array<Function>} linkFns\r\n   * @return {Function} childLinkFn\r\n   */\r\n\r\n  function makeChildLinkFn(linkFns) {\r\n    return function childLinkFn(vm, nodes, host, scope, frag) {\r\n      var node, nodeLinkFn, childrenLinkFn;\r\n      for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {\r\n        node = nodes[n];\r\n        nodeLinkFn = linkFns[i++];\r\n        childrenLinkFn = linkFns[i++];\r\n        // cache childNodes before linking parent, fix #657\r\n        var childNodes = toArray(node.childNodes);\r\n        if (nodeLinkFn) {\r\n          nodeLinkFn(vm, node, host, scope, frag);\r\n        }\r\n        if (childrenLinkFn) {\r\n          childrenLinkFn(vm, childNodes, host, scope, frag);\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check for element directives (custom elements that should\r\n   * be resovled as terminal directives).\r\n   *\r\n   * @param {Element} el\r\n   * @param {Object} options\r\n   */\r\n\r\n  function checkElementDirectives(el, options) {\r\n    var tag = el.tagName.toLowerCase();\r\n    if (commonTagRE.test(tag)) {\r\n      return;\r\n    }\r\n    var def = resolveAsset(options, 'elementDirectives', tag);\r\n    if (def) {\r\n      return makeTerminalNodeLinkFn(el, tag, '', options, def);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if an element is a component. If yes, return\r\n   * a component link function.\r\n   *\r\n   * @param {Element} el\r\n   * @param {Object} options\r\n   * @return {Function|undefined}\r\n   */\r\n\r\n  function checkComponent(el, options) {\r\n    var component = checkComponentAttr(el, options);\r\n    if (component) {\r\n      var ref = findRef(el);\r\n      var descriptor = {\r\n        name: 'component',\r\n        ref: ref,\r\n        expression: component.id,\r\n        def: internalDirectives.component,\r\n        modifiers: {\r\n          literal: !component.dynamic\r\n        }\r\n      };\r\n      var componentLinkFn = function componentLinkFn(vm, el, host, scope, frag) {\r\n        if (ref) {\r\n          defineReactive((scope || vm).$refs, ref, null);\r\n        }\r\n        vm._bindDir(descriptor, el, host, scope, frag);\r\n      };\r\n      componentLinkFn.terminal = true;\r\n      return componentLinkFn;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check an element for terminal directives in fixed order.\r\n   * If it finds one, return a terminal link function.\r\n   *\r\n   * @param {Element} el\r\n   * @param {Array} attrs\r\n   * @param {Object} options\r\n   * @return {Function} terminalLinkFn\r\n   */\r\n\r\n  function checkTerminalDirectives(el, attrs, options) {\r\n    // skip v-pre\r\n    if (getAttr(el, 'v-pre') !== null) {\r\n      return skip;\r\n    }\r\n    // skip v-else block, but only if following v-if\r\n    if (el.hasAttribute('v-else')) {\r\n      var prev = el.previousElementSibling;\r\n      if (prev && prev.hasAttribute('v-if')) {\r\n        return skip;\r\n      }\r\n    }\r\n\r\n    var attr, name, value, modifiers, matched, dirName, rawName, arg, def, termDef;\r\n    for (var i = 0, j = attrs.length; i < j; i++) {\r\n      attr = attrs[i];\r\n      name = attr.name.replace(modifierRE, '');\r\n      if (matched = name.match(dirAttrRE)) {\r\n        def = resolveAsset(options, 'directives', matched[1]);\r\n        if (def && def.terminal) {\r\n          if (!termDef || (def.priority || DEFAULT_TERMINAL_PRIORITY) > termDef.priority) {\r\n            termDef = def;\r\n            rawName = attr.name;\r\n            modifiers = parseModifiers(attr.name);\r\n            value = attr.value;\r\n            dirName = matched[1];\r\n            arg = matched[2];\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (termDef) {\r\n      return makeTerminalNodeLinkFn(el, dirName, value, options, termDef, rawName, arg, modifiers);\r\n    }\r\n  }\r\n\r\n  function skip() {}\r\n  skip.terminal = true;\r\n\r\n  /**\r\n   * Build a node link function for a terminal directive.\r\n   * A terminal link function terminates the current\r\n   * compilation recursion and handles compilation of the\r\n   * subtree in the directive.\r\n   *\r\n   * @param {Element} el\r\n   * @param {String} dirName\r\n   * @param {String} value\r\n   * @param {Object} options\r\n   * @param {Object} def\r\n   * @param {String} [rawName]\r\n   * @param {String} [arg]\r\n   * @param {Object} [modifiers]\r\n   * @return {Function} terminalLinkFn\r\n   */\r\n\r\n  function makeTerminalNodeLinkFn(el, dirName, value, options, def, rawName, arg, modifiers) {\r\n    var parsed = parseDirective(value);\r\n    var descriptor = {\r\n      name: dirName,\r\n      arg: arg,\r\n      expression: parsed.expression,\r\n      filters: parsed.filters,\r\n      raw: value,\r\n      attr: rawName,\r\n      modifiers: modifiers,\r\n      def: def\r\n    };\r\n    // check ref for v-for and router-view\r\n    if (dirName === 'for' || dirName === 'router-view') {\r\n      descriptor.ref = findRef(el);\r\n    }\r\n    var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {\r\n      if (descriptor.ref) {\r\n        defineReactive((scope || vm).$refs, descriptor.ref, null);\r\n      }\r\n      vm._bindDir(descriptor, el, host, scope, frag);\r\n    };\r\n    fn.terminal = true;\r\n    return fn;\r\n  }\r\n\r\n  /**\r\n   * Compile the directives on an element and return a linker.\r\n   *\r\n   * @param {Array|NamedNodeMap} attrs\r\n   * @param {Object} options\r\n   * @return {Function}\r\n   */\r\n\r\n  function compileDirectives(attrs, options) {\r\n    var i = attrs.length;\r\n    var dirs = [];\r\n    var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens, matched;\r\n    while (i--) {\r\n      attr = attrs[i];\r\n      name = rawName = attr.name;\r\n      value = rawValue = attr.value;\r\n      tokens = parseText(value);\r\n      // reset arg\r\n      arg = null;\r\n      // check modifiers\r\n      modifiers = parseModifiers(name);\r\n      name = name.replace(modifierRE, '');\r\n\r\n      // attribute interpolations\r\n      if (tokens) {\r\n        value = tokensToExp(tokens);\r\n        arg = name;\r\n        pushDir('bind', directives.bind, tokens);\r\n        // warn against mixing mustaches with v-bind\r\n        if ('development' !== 'production') {\r\n          if (name === 'class' && Array.prototype.some.call(attrs, function (attr) {\r\n            return attr.name === ':class' || attr.name === 'v-bind:class';\r\n          })) {\r\n            warn('class=\"' + rawValue + '\": Do not mix mustache interpolation ' + 'and v-bind for \"class\" on the same element. Use one or the other.', options);\r\n          }\r\n        }\r\n      } else\r\n\r\n        // special attribute: transition\r\n        if (transitionRE.test(name)) {\r\n          modifiers.literal = !bindRE.test(name);\r\n          pushDir('transition', internalDirectives.transition);\r\n        } else\r\n\r\n          // event handlers\r\n          if (onRE.test(name)) {\r\n            arg = name.replace(onRE, '');\r\n            pushDir('on', directives.on);\r\n          } else\r\n\r\n            // attribute bindings\r\n            if (bindRE.test(name)) {\r\n              dirName = name.replace(bindRE, '');\r\n              if (dirName === 'style' || dirName === 'class') {\r\n                pushDir(dirName, internalDirectives[dirName]);\r\n              } else {\r\n                arg = dirName;\r\n                pushDir('bind', directives.bind);\r\n              }\r\n            } else\r\n\r\n              // normal directives\r\n              if (matched = name.match(dirAttrRE)) {\r\n                dirName = matched[1];\r\n                arg = matched[2];\r\n\r\n                // skip v-else (when used with v-show)\r\n                if (dirName === 'else') {\r\n                  continue;\r\n                }\r\n\r\n                dirDef = resolveAsset(options, 'directives', dirName, true);\r\n                if (dirDef) {\r\n                  pushDir(dirName, dirDef);\r\n                }\r\n              }\r\n    }\r\n\r\n    /**\r\n     * Push a directive.\r\n     *\r\n     * @param {String} dirName\r\n     * @param {Object|Function} def\r\n     * @param {Array} [interpTokens]\r\n     */\r\n\r\n    function pushDir(dirName, def, interpTokens) {\r\n      var hasOneTimeToken = interpTokens && hasOneTime(interpTokens);\r\n      var parsed = !hasOneTimeToken && parseDirective(value);\r\n      dirs.push({\r\n        name: dirName,\r\n        attr: rawName,\r\n        raw: rawValue,\r\n        def: def,\r\n        arg: arg,\r\n        modifiers: modifiers,\r\n        // conversion from interpolation strings with one-time token\r\n        // to expression is differed until directive bind time so that we\r\n        // have access to the actual vm context for one-time bindings.\r\n        expression: parsed && parsed.expression,\r\n        filters: parsed && parsed.filters,\r\n        interp: interpTokens,\r\n        hasOneTime: hasOneTimeToken\r\n      });\r\n    }\r\n\r\n    if (dirs.length) {\r\n      return makeNodeLinkFn(dirs);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse modifiers from directive attribute name.\r\n   *\r\n   * @param {String} name\r\n   * @return {Object}\r\n   */\r\n\r\n  function parseModifiers(name) {\r\n    var res = Object.create(null);\r\n    var match = name.match(modifierRE);\r\n    if (match) {\r\n      var i = match.length;\r\n      while (i--) {\r\n        res[match[i].slice(1)] = true;\r\n      }\r\n    }\r\n    return res;\r\n  }\r\n\r\n  /**\r\n   * Build a link function for all directives on a single node.\r\n   *\r\n   * @param {Array} directives\r\n   * @return {Function} directivesLinkFn\r\n   */\r\n\r\n  function makeNodeLinkFn(directives) {\r\n    return function nodeLinkFn(vm, el, host, scope, frag) {\r\n      // reverse apply because it's sorted low to high\r\n      var i = directives.length;\r\n      while (i--) {\r\n        vm._bindDir(directives[i], el, host, scope, frag);\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if an interpolation string contains one-time tokens.\r\n   *\r\n   * @param {Array} tokens\r\n   * @return {Boolean}\r\n   */\r\n\r\n  function hasOneTime(tokens) {\r\n    var i = tokens.length;\r\n    while (i--) {\r\n      if (tokens[i].oneTime) return true;\r\n    }\r\n  }\r\n\r\n  function isScript(el) {\r\n    return el.tagName === 'SCRIPT' && (!el.hasAttribute('type') || el.getAttribute('type') === 'text/javascript');\r\n  }\r\n\r\n  var specialCharRE = /[^\\w\\-:\\.]/;\r\n\r\n  /**\r\n   * Process an element or a DocumentFragment based on a\r\n   * instance option object. This allows us to transclude\r\n   * a template node/fragment before the instance is created,\r\n   * so the processed fragment can then be cloned and reused\r\n   * in v-for.\r\n   *\r\n   * @param {Element} el\r\n   * @param {Object} options\r\n   * @return {Element|DocumentFragment}\r\n   */\r\n\r\n  function transclude(el, options) {\r\n    // extract container attributes to pass them down\r\n    // to compiler, because they need to be compiled in\r\n    // parent scope. we are mutating the options object here\r\n    // assuming the same object will be used for compile\r\n    // right after this.\r\n    if (options) {\r\n      options._containerAttrs = extractAttrs(el);\r\n    }\r\n    // for template tags, what we want is its content as\r\n    // a documentFragment (for fragment instances)\r\n    if (isTemplate(el)) {\r\n      el = parseTemplate(el);\r\n    }\r\n    if (options) {\r\n      if (options._asComponent && !options.template) {\r\n        options.template = '<slot></slot>';\r\n      }\r\n      if (options.template) {\r\n        options._content = extractContent(el);\r\n        el = transcludeTemplate(el, options);\r\n      }\r\n    }\r\n    if (isFragment(el)) {\r\n      // anchors for fragment instance\r\n      // passing in `persist: true` to avoid them being\r\n      // discarded by IE during template cloning\r\n      prepend(createAnchor('v-start', true), el);\r\n      el.appendChild(createAnchor('v-end', true));\r\n    }\r\n    return el;\r\n  }\r\n\r\n  /**\r\n   * Process the template option.\r\n   * If the replace option is true this will swap the $el.\r\n   *\r\n   * @param {Element} el\r\n   * @param {Object} options\r\n   * @return {Element|DocumentFragment}\r\n   */\r\n\r\n  function transcludeTemplate(el, options) {\r\n    var template = options.template;\r\n    var frag = parseTemplate(template, true);\r\n    if (frag) {\r\n      var replacer = frag.firstChild;\r\n      var tag = replacer.tagName && replacer.tagName.toLowerCase();\r\n      if (options.replace) {\r\n        /* istanbul ignore if */\r\n        if (el === document.body) {\r\n          'development' !== 'production' && warn('You are mounting an instance with a template to ' + '<body>. This will replace <body> entirely. You ' + 'should probably use `replace: false` here.');\r\n        }\r\n        // there are many cases where the instance must\r\n        // become a fragment instance: basically anything that\r\n        // can create more than 1 root nodes.\r\n        if (\r\n        // multi-children template\r\n        frag.childNodes.length > 1 ||\r\n        // non-element template\r\n        replacer.nodeType !== 1 ||\r\n        // single nested component\r\n        tag === 'component' || resolveAsset(options, 'components', tag) || hasBindAttr(replacer, 'is') ||\r\n        // element directive\r\n        resolveAsset(options, 'elementDirectives', tag) ||\r\n        // for block\r\n        replacer.hasAttribute('v-for') ||\r\n        // if block\r\n        replacer.hasAttribute('v-if')) {\r\n          return frag;\r\n        } else {\r\n          options._replacerAttrs = extractAttrs(replacer);\r\n          mergeAttrs(el, replacer);\r\n          return replacer;\r\n        }\r\n      } else {\r\n        el.appendChild(frag);\r\n        return el;\r\n      }\r\n    } else {\r\n      'development' !== 'production' && warn('Invalid template option: ' + template);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper to extract a component container's attributes\r\n   * into a plain object array.\r\n   *\r\n   * @param {Element} el\r\n   * @return {Array}\r\n   */\r\n\r\n  function extractAttrs(el) {\r\n    if (el.nodeType === 1 && el.hasAttributes()) {\r\n      return toArray(el.attributes);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Merge the attributes of two elements, and make sure\r\n   * the class names are merged properly.\r\n   *\r\n   * @param {Element} from\r\n   * @param {Element} to\r\n   */\r\n\r\n  function mergeAttrs(from, to) {\r\n    var attrs = from.attributes;\r\n    var i = attrs.length;\r\n    var name, value;\r\n    while (i--) {\r\n      name = attrs[i].name;\r\n      value = attrs[i].value;\r\n      if (!to.hasAttribute(name) && !specialCharRE.test(name)) {\r\n        to.setAttribute(name, value);\r\n      } else if (name === 'class' && !parseText(value) && (value = value.trim())) {\r\n        value.split(/\\s+/).forEach(function (cls) {\r\n          addClass(to, cls);\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Scan and determine slot content distribution.\r\n   * We do this during transclusion instead at compile time so that\r\n   * the distribution is decoupled from the compilation order of\r\n   * the slots.\r\n   *\r\n   * @param {Element|DocumentFragment} template\r\n   * @param {Element} content\r\n   * @param {Vue} vm\r\n   */\r\n\r\n  function resolveSlots(vm, content) {\r\n    if (!content) {\r\n      return;\r\n    }\r\n    var contents = vm._slotContents = Object.create(null);\r\n    var el, name;\r\n    for (var i = 0, l = content.children.length; i < l; i++) {\r\n      el = content.children[i];\r\n      /* eslint-disable no-cond-assign */\r\n      if (name = el.getAttribute('slot')) {\r\n        (contents[name] || (contents[name] = [])).push(el);\r\n      }\r\n      /* eslint-enable no-cond-assign */\r\n      if ('development' !== 'production' && getBindAttr(el, 'slot')) {\r\n        warn('The \"slot\" attribute must be static.', vm.$parent);\r\n      }\r\n    }\r\n    for (name in contents) {\r\n      contents[name] = extractFragment(contents[name], content);\r\n    }\r\n    if (content.hasChildNodes()) {\r\n      var nodes = content.childNodes;\r\n      if (nodes.length === 1 && nodes[0].nodeType === 3 && !nodes[0].data.trim()) {\r\n        return;\r\n      }\r\n      contents['default'] = extractFragment(content.childNodes, content);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract qualified content nodes from a node list.\r\n   *\r\n   * @param {NodeList} nodes\r\n   * @return {DocumentFragment}\r\n   */\r\n\r\n  function extractFragment(nodes, parent) {\r\n    var frag = document.createDocumentFragment();\r\n    nodes = toArray(nodes);\r\n    for (var i = 0, l = nodes.length; i < l; i++) {\r\n      var node = nodes[i];\r\n      if (isTemplate(node) && !node.hasAttribute('v-if') && !node.hasAttribute('v-for')) {\r\n        parent.removeChild(node);\r\n        node = parseTemplate(node, true);\r\n      }\r\n      frag.appendChild(node);\r\n    }\r\n    return frag;\r\n  }\r\n\r\n\r\n\r\n  var compiler = Object.freeze({\r\n  \tcompile: compile,\r\n  \tcompileAndLinkProps: compileAndLinkProps,\r\n  \tcompileRoot: compileRoot,\r\n  \ttransclude: transclude,\r\n  \tresolveSlots: resolveSlots\r\n  });\r\n\r\n  function stateMixin (Vue) {\r\n    /**\r\n     * Accessor for `$data` property, since setting $data\r\n     * requires observing the new object and updating\r\n     * proxied properties.\r\n     */\r\n\r\n    Object.defineProperty(Vue.prototype, '$data', {\r\n      get: function get() {\r\n        return this._data;\r\n      },\r\n      set: function set(newData) {\r\n        if (newData !== this._data) {\r\n          this._setData(newData);\r\n        }\r\n      }\r\n    });\r\n\r\n    /**\r\n     * Setup the scope of an instance, which contains:\r\n     * - observed data\r\n     * - computed properties\r\n     * - user methods\r\n     * - meta properties\r\n     */\r\n\r\n    Vue.prototype._initState = function () {\r\n      this._initProps();\r\n      this._initMeta();\r\n      this._initMethods();\r\n      this._initData();\r\n      this._initComputed();\r\n    };\r\n\r\n    /**\r\n     * Initialize props.\r\n     */\r\n\r\n    Vue.prototype._initProps = function () {\r\n      var options = this.$options;\r\n      var el = options.el;\r\n      var props = options.props;\r\n      if (props && !el) {\r\n        'development' !== 'production' && warn('Props will not be compiled if no `el` option is ' + 'provided at instantiation.', this);\r\n      }\r\n      // make sure to convert string selectors into element now\r\n      el = options.el = query(el);\r\n      this._propsUnlinkFn = el && el.nodeType === 1 && props\r\n      // props must be linked in proper scope if inside v-for\r\n      ? compileAndLinkProps(this, el, props, this._scope) : null;\r\n    };\r\n\r\n    /**\r\n     * Initialize the data.\r\n     */\r\n\r\n    Vue.prototype._initData = function () {\r\n      var dataFn = this.$options.data;\r\n      var data = this._data = dataFn ? dataFn() : {};\r\n      if (!isPlainObject(data)) {\r\n        data = {};\r\n        'development' !== 'production' && warn('data functions should return an object.', this);\r\n      }\r\n      var props = this._props;\r\n      // proxy data on instance\r\n      var keys = Object.keys(data);\r\n      var i, key;\r\n      i = keys.length;\r\n      while (i--) {\r\n        key = keys[i];\r\n        // there are two scenarios where we can proxy a data key:\r\n        // 1. it's not already defined as a prop\r\n        // 2. it's provided via a instantiation option AND there are no\r\n        //    template prop present\r\n        if (!props || !hasOwn(props, key)) {\r\n          this._proxy(key);\r\n        } else if ('development' !== 'production') {\r\n          warn('Data field \"' + key + '\" is already defined ' + 'as a prop. To provide default value for a prop, use the \"default\" ' + 'prop option; if you want to pass prop values to an instantiation ' + 'call, use the \"propsData\" option.', this);\r\n        }\r\n      }\r\n      // observe data\r\n      observe(data, this);\r\n    };\r\n\r\n    /**\r\n     * Swap the instance's $data. Called in $data's setter.\r\n     *\r\n     * @param {Object} newData\r\n     */\r\n\r\n    Vue.prototype._setData = function (newData) {\r\n      newData = newData || {};\r\n      var oldData = this._data;\r\n      this._data = newData;\r\n      var keys, key, i;\r\n      // unproxy keys not present in new data\r\n      keys = Object.keys(oldData);\r\n      i = keys.length;\r\n      while (i--) {\r\n        key = keys[i];\r\n        if (!(key in newData)) {\r\n          this._unproxy(key);\r\n        }\r\n      }\r\n      // proxy keys not already proxied,\r\n      // and trigger change for changed values\r\n      keys = Object.keys(newData);\r\n      i = keys.length;\r\n      while (i--) {\r\n        key = keys[i];\r\n        if (!hasOwn(this, key)) {\r\n          // new property\r\n          this._proxy(key);\r\n        }\r\n      }\r\n      oldData.__ob__.removeVm(this);\r\n      observe(newData, this);\r\n      this._digest();\r\n    };\r\n\r\n    /**\r\n     * Proxy a property, so that\r\n     * vm.prop === vm._data.prop\r\n     *\r\n     * @param {String} key\r\n     */\r\n\r\n    Vue.prototype._proxy = function (key) {\r\n      if (!isReserved(key)) {\r\n        // need to store ref to self here\r\n        // because these getter/setters might\r\n        // be called by child scopes via\r\n        // prototype inheritance.\r\n        var self = this;\r\n        Object.defineProperty(self, key, {\r\n          configurable: true,\r\n          enumerable: true,\r\n          get: function proxyGetter() {\r\n            return self._data[key];\r\n          },\r\n          set: function proxySetter(val) {\r\n            self._data[key] = val;\r\n          }\r\n        });\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Unproxy a property.\r\n     *\r\n     * @param {String} key\r\n     */\r\n\r\n    Vue.prototype._unproxy = function (key) {\r\n      if (!isReserved(key)) {\r\n        delete this[key];\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Force update on every watcher in scope.\r\n     */\r\n\r\n    Vue.prototype._digest = function () {\r\n      for (var i = 0, l = this._watchers.length; i < l; i++) {\r\n        this._watchers[i].update(true); // shallow updates\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Setup computed properties. They are essentially\r\n     * special getter/setters\r\n     */\r\n\r\n    function noop() {}\r\n    Vue.prototype._initComputed = function () {\r\n      var computed = this.$options.computed;\r\n      if (computed) {\r\n        for (var key in computed) {\r\n          var userDef = computed[key];\r\n          var def = {\r\n            enumerable: true,\r\n            configurable: true\r\n          };\r\n          if (typeof userDef === 'function') {\r\n            def.get = makeComputedGetter(userDef, this);\r\n            def.set = noop;\r\n          } else {\r\n            def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, this) : bind(userDef.get, this) : noop;\r\n            def.set = userDef.set ? bind(userDef.set, this) : noop;\r\n          }\r\n          Object.defineProperty(this, key, def);\r\n        }\r\n      }\r\n    };\r\n\r\n    function makeComputedGetter(getter, owner) {\r\n      var watcher = new Watcher(owner, getter, null, {\r\n        lazy: true\r\n      });\r\n      return function computedGetter() {\r\n        if (watcher.dirty) {\r\n          watcher.evaluate();\r\n        }\r\n        if (Dep.target) {\r\n          watcher.depend();\r\n        }\r\n        return watcher.value;\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Setup instance methods. Methods must be bound to the\r\n     * instance since they might be passed down as a prop to\r\n     * child components.\r\n     */\r\n\r\n    Vue.prototype._initMethods = function () {\r\n      var methods = this.$options.methods;\r\n      if (methods) {\r\n        for (var key in methods) {\r\n          this[key] = bind(methods[key], this);\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Initialize meta information like $index, $key & $value.\r\n     */\r\n\r\n    Vue.prototype._initMeta = function () {\r\n      var metas = this.$options._meta;\r\n      if (metas) {\r\n        for (var key in metas) {\r\n          defineReactive(this, key, metas[key]);\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  var eventRE = /^v-on:|^@/;\r\n\r\n  function eventsMixin (Vue) {\r\n    /**\r\n     * Setup the instance's option events & watchers.\r\n     * If the value is a string, we pull it from the\r\n     * instance's methods by name.\r\n     */\r\n\r\n    Vue.prototype._initEvents = function () {\r\n      var options = this.$options;\r\n      if (options._asComponent) {\r\n        registerComponentEvents(this, options.el);\r\n      }\r\n      registerCallbacks(this, '$on', options.events);\r\n      registerCallbacks(this, '$watch', options.watch);\r\n    };\r\n\r\n    /**\r\n     * Register v-on events on a child component\r\n     *\r\n     * @param {Vue} vm\r\n     * @param {Element} el\r\n     */\r\n\r\n    function registerComponentEvents(vm, el) {\r\n      var attrs = el.attributes;\r\n      var name, value, handler;\r\n      for (var i = 0, l = attrs.length; i < l; i++) {\r\n        name = attrs[i].name;\r\n        if (eventRE.test(name)) {\r\n          name = name.replace(eventRE, '');\r\n          // force the expression into a statement so that\r\n          // it always dynamically resolves the method to call (#2670)\r\n          // kinda ugly hack, but does the job.\r\n          value = attrs[i].value;\r\n          if (isSimplePath(value)) {\r\n            value += '.apply(this, $arguments)';\r\n          }\r\n          handler = (vm._scope || vm._context).$eval(value, true);\r\n          handler._fromParent = true;\r\n          vm.$on(name.replace(eventRE), handler);\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Register callbacks for option events and watchers.\r\n     *\r\n     * @param {Vue} vm\r\n     * @param {String} action\r\n     * @param {Object} hash\r\n     */\r\n\r\n    function registerCallbacks(vm, action, hash) {\r\n      if (!hash) return;\r\n      var handlers, key, i, j;\r\n      for (key in hash) {\r\n        handlers = hash[key];\r\n        if (isArray(handlers)) {\r\n          for (i = 0, j = handlers.length; i < j; i++) {\r\n            register(vm, action, key, handlers[i]);\r\n          }\r\n        } else {\r\n          register(vm, action, key, handlers);\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Helper to register an event/watch callback.\r\n     *\r\n     * @param {Vue} vm\r\n     * @param {String} action\r\n     * @param {String} key\r\n     * @param {Function|String|Object} handler\r\n     * @param {Object} [options]\r\n     */\r\n\r\n    function register(vm, action, key, handler, options) {\r\n      var type = typeof handler;\r\n      if (type === 'function') {\r\n        vm[action](key, handler, options);\r\n      } else if (type === 'string') {\r\n        var methods = vm.$options.methods;\r\n        var method = methods && methods[handler];\r\n        if (method) {\r\n          vm[action](key, method, options);\r\n        } else {\r\n          'development' !== 'production' && warn('Unknown method: \"' + handler + '\" when ' + 'registering callback for ' + action + ': \"' + key + '\".', vm);\r\n        }\r\n      } else if (handler && type === 'object') {\r\n        register(vm, action, key, handler.handler, handler);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Setup recursive attached/detached calls\r\n     */\r\n\r\n    Vue.prototype._initDOMHooks = function () {\r\n      this.$on('hook:attached', onAttached);\r\n      this.$on('hook:detached', onDetached);\r\n    };\r\n\r\n    /**\r\n     * Callback to recursively call attached hook on children\r\n     */\r\n\r\n    function onAttached() {\r\n      if (!this._isAttached) {\r\n        this._isAttached = true;\r\n        this.$children.forEach(callAttach);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Iterator to call attached hook\r\n     *\r\n     * @param {Vue} child\r\n     */\r\n\r\n    function callAttach(child) {\r\n      if (!child._isAttached && inDoc(child.$el)) {\r\n        child._callHook('attached');\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Callback to recursively call detached hook on children\r\n     */\r\n\r\n    function onDetached() {\r\n      if (this._isAttached) {\r\n        this._isAttached = false;\r\n        this.$children.forEach(callDetach);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Iterator to call detached hook\r\n     *\r\n     * @param {Vue} child\r\n     */\r\n\r\n    function callDetach(child) {\r\n      if (child._isAttached && !inDoc(child.$el)) {\r\n        child._callHook('detached');\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Trigger all handlers for a hook\r\n     *\r\n     * @param {String} hook\r\n     */\r\n\r\n    Vue.prototype._callHook = function (hook) {\r\n      this.$emit('pre-hook:' + hook);\r\n      var handlers = this.$options[hook];\r\n      if (handlers) {\r\n        for (var i = 0, j = handlers.length; i < j; i++) {\r\n          handlers[i].call(this);\r\n        }\r\n      }\r\n      this.$emit('hook:' + hook);\r\n    };\r\n  }\r\n\r\n  function noop$1() {}\r\n\r\n  /**\r\n   * A directive links a DOM element with a piece of data,\r\n   * which is the result of evaluating an expression.\r\n   * It registers a watcher with the expression and calls\r\n   * the DOM update function when a change is triggered.\r\n   *\r\n   * @param {Object} descriptor\r\n   *                 - {String} name\r\n   *                 - {Object} def\r\n   *                 - {String} expression\r\n   *                 - {Array<Object>} [filters]\r\n   *                 - {Object} [modifiers]\r\n   *                 - {Boolean} literal\r\n   *                 - {String} attr\r\n   *                 - {String} arg\r\n   *                 - {String} raw\r\n   *                 - {String} [ref]\r\n   *                 - {Array<Object>} [interp]\r\n   *                 - {Boolean} [hasOneTime]\r\n   * @param {Vue} vm\r\n   * @param {Node} el\r\n   * @param {Vue} [host] - transclusion host component\r\n   * @param {Object} [scope] - v-for scope\r\n   * @param {Fragment} [frag] - owner fragment\r\n   * @constructor\r\n   */\r\n  function Directive(descriptor, vm, el, host, scope, frag) {\r\n    this.vm = vm;\r\n    this.el = el;\r\n    // copy descriptor properties\r\n    this.descriptor = descriptor;\r\n    this.name = descriptor.name;\r\n    this.expression = descriptor.expression;\r\n    this.arg = descriptor.arg;\r\n    this.modifiers = descriptor.modifiers;\r\n    this.filters = descriptor.filters;\r\n    this.literal = this.modifiers && this.modifiers.literal;\r\n    // private\r\n    this._locked = false;\r\n    this._bound = false;\r\n    this._listeners = null;\r\n    // link context\r\n    this._host = host;\r\n    this._scope = scope;\r\n    this._frag = frag;\r\n    // store directives on node in dev mode\r\n    if ('development' !== 'production' && this.el) {\r\n      this.el._vue_directives = this.el._vue_directives || [];\r\n      this.el._vue_directives.push(this);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize the directive, mixin definition properties,\r\n   * setup the watcher, call definition bind() and update()\r\n   * if present.\r\n   */\r\n\r\n  Directive.prototype._bind = function () {\r\n    var name = this.name;\r\n    var descriptor = this.descriptor;\r\n\r\n    // remove attribute\r\n    if ((name !== 'cloak' || this.vm._isCompiled) && this.el && this.el.removeAttribute) {\r\n      var attr = descriptor.attr || 'v-' + name;\r\n      this.el.removeAttribute(attr);\r\n    }\r\n\r\n    // copy def properties\r\n    var def = descriptor.def;\r\n    if (typeof def === 'function') {\r\n      this.update = def;\r\n    } else {\r\n      extend(this, def);\r\n    }\r\n\r\n    // setup directive params\r\n    this._setupParams();\r\n\r\n    // initial bind\r\n    if (this.bind) {\r\n      this.bind();\r\n    }\r\n    this._bound = true;\r\n\r\n    if (this.literal) {\r\n      this.update && this.update(descriptor.raw);\r\n    } else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {\r\n      // wrapped updater for context\r\n      var dir = this;\r\n      if (this.update) {\r\n        this._update = function (val, oldVal) {\r\n          if (!dir._locked) {\r\n            dir.update(val, oldVal);\r\n          }\r\n        };\r\n      } else {\r\n        this._update = noop$1;\r\n      }\r\n      var preProcess = this._preProcess ? bind(this._preProcess, this) : null;\r\n      var postProcess = this._postProcess ? bind(this._postProcess, this) : null;\r\n      var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, // callback\r\n      {\r\n        filters: this.filters,\r\n        twoWay: this.twoWay,\r\n        deep: this.deep,\r\n        preProcess: preProcess,\r\n        postProcess: postProcess,\r\n        scope: this._scope\r\n      });\r\n      // v-model with inital inline value need to sync back to\r\n      // model instead of update to DOM on init. They would\r\n      // set the afterBind hook to indicate that.\r\n      if (this.afterBind) {\r\n        this.afterBind();\r\n      } else if (this.update) {\r\n        this.update(watcher.value);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Setup all param attributes, e.g. track-by,\r\n   * transition-mode, etc...\r\n   */\r\n\r\n  Directive.prototype._setupParams = function () {\r\n    if (!this.params) {\r\n      return;\r\n    }\r\n    var params = this.params;\r\n    // swap the params array with a fresh object.\r\n    this.params = Object.create(null);\r\n    var i = params.length;\r\n    var key, val, mappedKey;\r\n    while (i--) {\r\n      key = hyphenate(params[i]);\r\n      mappedKey = camelize(key);\r\n      val = getBindAttr(this.el, key);\r\n      if (val != null) {\r\n        // dynamic\r\n        this._setupParamWatcher(mappedKey, val);\r\n      } else {\r\n        // static\r\n        val = getAttr(this.el, key);\r\n        if (val != null) {\r\n          this.params[mappedKey] = val === '' ? true : val;\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Setup a watcher for a dynamic param.\r\n   *\r\n   * @param {String} key\r\n   * @param {String} expression\r\n   */\r\n\r\n  Directive.prototype._setupParamWatcher = function (key, expression) {\r\n    var self = this;\r\n    var called = false;\r\n    var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {\r\n      self.params[key] = val;\r\n      // since we are in immediate mode,\r\n      // only call the param change callbacks if this is not the first update.\r\n      if (called) {\r\n        var cb = self.paramWatchers && self.paramWatchers[key];\r\n        if (cb) {\r\n          cb.call(self, val, oldVal);\r\n        }\r\n      } else {\r\n        called = true;\r\n      }\r\n    }, {\r\n      immediate: true,\r\n      user: false\r\n    });(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch);\r\n  };\r\n\r\n  /**\r\n   * Check if the directive is a function caller\r\n   * and if the expression is a callable one. If both true,\r\n   * we wrap up the expression and use it as the event\r\n   * handler.\r\n   *\r\n   * e.g. on-click=\"a++\"\r\n   *\r\n   * @return {Boolean}\r\n   */\r\n\r\n  Directive.prototype._checkStatement = function () {\r\n    var expression = this.expression;\r\n    if (expression && this.acceptStatement && !isSimplePath(expression)) {\r\n      var fn = parseExpression(expression).get;\r\n      var scope = this._scope || this.vm;\r\n      var handler = function handler(e) {\r\n        scope.$event = e;\r\n        fn.call(scope, scope);\r\n        scope.$event = null;\r\n      };\r\n      if (this.filters) {\r\n        handler = scope._applyFilters(handler, null, this.filters);\r\n      }\r\n      this.update(handler);\r\n      return true;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Set the corresponding value with the setter.\r\n   * This should only be used in two-way directives\r\n   * e.g. v-model.\r\n   *\r\n   * @param {*} value\r\n   * @public\r\n   */\r\n\r\n  Directive.prototype.set = function (value) {\r\n    /* istanbul ignore else */\r\n    if (this.twoWay) {\r\n      this._withLock(function () {\r\n        this._watcher.set(value);\r\n      });\r\n    } else if ('development' !== 'production') {\r\n      warn('Directive.set() can only be used inside twoWay' + 'directives.');\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Execute a function while preventing that function from\r\n   * triggering updates on this directive instance.\r\n   *\r\n   * @param {Function} fn\r\n   */\r\n\r\n  Directive.prototype._withLock = function (fn) {\r\n    var self = this;\r\n    self._locked = true;\r\n    fn.call(self);\r\n    nextTick(function () {\r\n      self._locked = false;\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Convenience method that attaches a DOM event listener\r\n   * to the directive element and autometically tears it down\r\n   * during unbind.\r\n   *\r\n   * @param {String} event\r\n   * @param {Function} handler\r\n   * @param {Boolean} [useCapture]\r\n   */\r\n\r\n  Directive.prototype.on = function (event, handler, useCapture) {\r\n    on(this.el, event, handler, useCapture);(this._listeners || (this._listeners = [])).push([event, handler]);\r\n  };\r\n\r\n  /**\r\n   * Teardown the watcher and call unbind.\r\n   */\r\n\r\n  Directive.prototype._teardown = function () {\r\n    if (this._bound) {\r\n      this._bound = false;\r\n      if (this.unbind) {\r\n        this.unbind();\r\n      }\r\n      if (this._watcher) {\r\n        this._watcher.teardown();\r\n      }\r\n      var listeners = this._listeners;\r\n      var i;\r\n      if (listeners) {\r\n        i = listeners.length;\r\n        while (i--) {\r\n          off(this.el, listeners[i][0], listeners[i][1]);\r\n        }\r\n      }\r\n      var unwatchFns = this._paramUnwatchFns;\r\n      if (unwatchFns) {\r\n        i = unwatchFns.length;\r\n        while (i--) {\r\n          unwatchFns[i]();\r\n        }\r\n      }\r\n      if ('development' !== 'production' && this.el) {\r\n        this.el._vue_directives.$remove(this);\r\n      }\r\n      this.vm = this.el = this._watcher = this._listeners = null;\r\n    }\r\n  };\r\n\r\n  function lifecycleMixin (Vue) {\r\n    /**\r\n     * Update v-ref for component.\r\n     *\r\n     * @param {Boolean} remove\r\n     */\r\n\r\n    Vue.prototype._updateRef = function (remove) {\r\n      var ref = this.$options._ref;\r\n      if (ref) {\r\n        var refs = (this._scope || this._context).$refs;\r\n        if (remove) {\r\n          if (refs[ref] === this) {\r\n            refs[ref] = null;\r\n          }\r\n        } else {\r\n          refs[ref] = this;\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Transclude, compile and link element.\r\n     *\r\n     * If a pre-compiled linker is available, that means the\r\n     * passed in element will be pre-transcluded and compiled\r\n     * as well - all we need to do is to call the linker.\r\n     *\r\n     * Otherwise we need to call transclude/compile/link here.\r\n     *\r\n     * @param {Element} el\r\n     */\r\n\r\n    Vue.prototype._compile = function (el) {\r\n      var options = this.$options;\r\n\r\n      // transclude and init element\r\n      // transclude can potentially replace original\r\n      // so we need to keep reference; this step also injects\r\n      // the template and caches the original attributes\r\n      // on the container node and replacer node.\r\n      var original = el;\r\n      el = transclude(el, options);\r\n      this._initElement(el);\r\n\r\n      // handle v-pre on root node (#2026)\r\n      if (el.nodeType === 1 && getAttr(el, 'v-pre') !== null) {\r\n        return;\r\n      }\r\n\r\n      // root is always compiled per-instance, because\r\n      // container attrs and props can be different every time.\r\n      var contextOptions = this._context && this._context.$options;\r\n      var rootLinker = compileRoot(el, options, contextOptions);\r\n\r\n      // resolve slot distribution\r\n      resolveSlots(this, options._content);\r\n\r\n      // compile and link the rest\r\n      var contentLinkFn;\r\n      var ctor = this.constructor;\r\n      // component compilation can be cached\r\n      // as long as it's not using inline-template\r\n      if (options._linkerCachable) {\r\n        contentLinkFn = ctor.linker;\r\n        if (!contentLinkFn) {\r\n          contentLinkFn = ctor.linker = compile(el, options);\r\n        }\r\n      }\r\n\r\n      // link phase\r\n      // make sure to link root with prop scope!\r\n      var rootUnlinkFn = rootLinker(this, el, this._scope);\r\n      var contentUnlinkFn = contentLinkFn ? contentLinkFn(this, el) : compile(el, options)(this, el);\r\n\r\n      // register composite unlink function\r\n      // to be called during instance destruction\r\n      this._unlinkFn = function () {\r\n        rootUnlinkFn();\r\n        // passing destroying: true to avoid searching and\r\n        // splicing the directives\r\n        contentUnlinkFn(true);\r\n      };\r\n\r\n      // finally replace original\r\n      if (options.replace) {\r\n        replace(original, el);\r\n      }\r\n\r\n      this._isCompiled = true;\r\n      this._callHook('compiled');\r\n    };\r\n\r\n    /**\r\n     * Initialize instance element. Called in the public\r\n     * $mount() method.\r\n     *\r\n     * @param {Element} el\r\n     */\r\n\r\n    Vue.prototype._initElement = function (el) {\r\n      if (isFragment(el)) {\r\n        this._isFragment = true;\r\n        this.$el = this._fragmentStart = el.firstChild;\r\n        this._fragmentEnd = el.lastChild;\r\n        // set persisted text anchors to empty\r\n        if (this._fragmentStart.nodeType === 3) {\r\n          this._fragmentStart.data = this._fragmentEnd.data = '';\r\n        }\r\n        this._fragment = el;\r\n      } else {\r\n        this.$el = el;\r\n      }\r\n      this.$el.__vue__ = this;\r\n      this._callHook('beforeCompile');\r\n    };\r\n\r\n    /**\r\n     * Create and bind a directive to an element.\r\n     *\r\n     * @param {Object} descriptor - parsed directive descriptor\r\n     * @param {Node} node   - target node\r\n     * @param {Vue} [host] - transclusion host component\r\n     * @param {Object} [scope] - v-for scope\r\n     * @param {Fragment} [frag] - owner fragment\r\n     */\r\n\r\n    Vue.prototype._bindDir = function (descriptor, node, host, scope, frag) {\r\n      this._directives.push(new Directive(descriptor, this, node, host, scope, frag));\r\n    };\r\n\r\n    /**\r\n     * Teardown an instance, unobserves the data, unbind all the\r\n     * directives, turn off all the event listeners, etc.\r\n     *\r\n     * @param {Boolean} remove - whether to remove the DOM node.\r\n     * @param {Boolean} deferCleanup - if true, defer cleanup to\r\n     *                                 be called later\r\n     */\r\n\r\n    Vue.prototype._destroy = function (remove, deferCleanup) {\r\n      if (this._isBeingDestroyed) {\r\n        if (!deferCleanup) {\r\n          this._cleanup();\r\n        }\r\n        return;\r\n      }\r\n\r\n      var destroyReady;\r\n      var pendingRemoval;\r\n\r\n      var self = this;\r\n      // Cleanup should be called either synchronously or asynchronoysly as\r\n      // callback of this.$remove(), or if remove and deferCleanup are false.\r\n      // In any case it should be called after all other removing, unbinding and\r\n      // turning of is done\r\n      var cleanupIfPossible = function cleanupIfPossible() {\r\n        if (destroyReady && !pendingRemoval && !deferCleanup) {\r\n          self._cleanup();\r\n        }\r\n      };\r\n\r\n      // remove DOM element\r\n      if (remove && this.$el) {\r\n        pendingRemoval = true;\r\n        this.$remove(function () {\r\n          pendingRemoval = false;\r\n          cleanupIfPossible();\r\n        });\r\n      }\r\n\r\n      this._callHook('beforeDestroy');\r\n      this._isBeingDestroyed = true;\r\n      var i;\r\n      // remove self from parent. only necessary\r\n      // if parent is not being destroyed as well.\r\n      var parent = this.$parent;\r\n      if (parent && !parent._isBeingDestroyed) {\r\n        parent.$children.$remove(this);\r\n        // unregister ref (remove: true)\r\n        this._updateRef(true);\r\n      }\r\n      // destroy all children.\r\n      i = this.$children.length;\r\n      while (i--) {\r\n        this.$children[i].$destroy();\r\n      }\r\n      // teardown props\r\n      if (this._propsUnlinkFn) {\r\n        this._propsUnlinkFn();\r\n      }\r\n      // teardown all directives. this also tearsdown all\r\n      // directive-owned watchers.\r\n      if (this._unlinkFn) {\r\n        this._unlinkFn();\r\n      }\r\n      i = this._watchers.length;\r\n      while (i--) {\r\n        this._watchers[i].teardown();\r\n      }\r\n      // remove reference to self on $el\r\n      if (this.$el) {\r\n        this.$el.__vue__ = null;\r\n      }\r\n\r\n      destroyReady = true;\r\n      cleanupIfPossible();\r\n    };\r\n\r\n    /**\r\n     * Clean up to ensure garbage collection.\r\n     * This is called after the leave transition if there\r\n     * is any.\r\n     */\r\n\r\n    Vue.prototype._cleanup = function () {\r\n      if (this._isDestroyed) {\r\n        return;\r\n      }\r\n      // remove self from owner fragment\r\n      // do it in cleanup so that we can call $destroy with\r\n      // defer right when a fragment is about to be removed.\r\n      if (this._frag) {\r\n        this._frag.children.$remove(this);\r\n      }\r\n      // remove reference from data ob\r\n      // frozen object may not have observer.\r\n      if (this._data && this._data.__ob__) {\r\n        this._data.__ob__.removeVm(this);\r\n      }\r\n      // Clean up references to private properties and other\r\n      // instances. preserve reference to _data so that proxy\r\n      // accessors still work. The only potential side effect\r\n      // here is that mutating the instance after it's destroyed\r\n      // may affect the state of other components that are still\r\n      // observing the same object, but that seems to be a\r\n      // reasonable responsibility for the user rather than\r\n      // always throwing an error on them.\r\n      this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null;\r\n      // call the last hook...\r\n      this._isDestroyed = true;\r\n      this._callHook('destroyed');\r\n      // turn off all instance listeners.\r\n      this.$off();\r\n    };\r\n  }\r\n\r\n  function miscMixin (Vue) {\r\n    /**\r\n     * Apply a list of filter (descriptors) to a value.\r\n     * Using plain for loops here because this will be called in\r\n     * the getter of any watcher with filters so it is very\r\n     * performance sensitive.\r\n     *\r\n     * @param {*} value\r\n     * @param {*} [oldValue]\r\n     * @param {Array} filters\r\n     * @param {Boolean} write\r\n     * @return {*}\r\n     */\r\n\r\n    Vue.prototype._applyFilters = function (value, oldValue, filters, write) {\r\n      var filter, fn, args, arg, offset, i, l, j, k;\r\n      for (i = 0, l = filters.length; i < l; i++) {\r\n        filter = filters[write ? l - i - 1 : i];\r\n        fn = resolveAsset(this.$options, 'filters', filter.name, true);\r\n        if (!fn) continue;\r\n        fn = write ? fn.write : fn.read || fn;\r\n        if (typeof fn !== 'function') continue;\r\n        args = write ? [value, oldValue] : [value];\r\n        offset = write ? 2 : 1;\r\n        if (filter.args) {\r\n          for (j = 0, k = filter.args.length; j < k; j++) {\r\n            arg = filter.args[j];\r\n            args[j + offset] = arg.dynamic ? this.$get(arg.value) : arg.value;\r\n          }\r\n        }\r\n        value = fn.apply(this, args);\r\n      }\r\n      return value;\r\n    };\r\n\r\n    /**\r\n     * Resolve a component, depending on whether the component\r\n     * is defined normally or using an async factory function.\r\n     * Resolves synchronously if already resolved, otherwise\r\n     * resolves asynchronously and caches the resolved\r\n     * constructor on the factory.\r\n     *\r\n     * @param {String|Function} value\r\n     * @param {Function} cb\r\n     */\r\n\r\n    Vue.prototype._resolveComponent = function (value, cb) {\r\n      var factory;\r\n      if (typeof value === 'function') {\r\n        factory = value;\r\n      } else {\r\n        factory = resolveAsset(this.$options, 'components', value, true);\r\n      }\r\n      /* istanbul ignore if */\r\n      if (!factory) {\r\n        return;\r\n      }\r\n      // async component factory\r\n      if (!factory.options) {\r\n        if (factory.resolved) {\r\n          // cached\r\n          cb(factory.resolved);\r\n        } else if (factory.requested) {\r\n          // pool callbacks\r\n          factory.pendingCallbacks.push(cb);\r\n        } else {\r\n          factory.requested = true;\r\n          var cbs = factory.pendingCallbacks = [cb];\r\n          factory.call(this, function resolve(res) {\r\n            if (isPlainObject(res)) {\r\n              res = Vue.extend(res);\r\n            }\r\n            // cache resolved\r\n            factory.resolved = res;\r\n            // invoke callbacks\r\n            for (var i = 0, l = cbs.length; i < l; i++) {\r\n              cbs[i](res);\r\n            }\r\n          }, function reject(reason) {\r\n            'development' !== 'production' && warn('Failed to resolve async component' + (typeof value === 'string' ? ': ' + value : '') + '. ' + (reason ? '\\nReason: ' + reason : ''));\r\n          });\r\n        }\r\n      } else {\r\n        // normal component\r\n        cb(factory);\r\n      }\r\n    };\r\n  }\r\n\r\n  var filterRE$1 = /[^|]\\|[^|]/;\r\n\r\n  function dataAPI (Vue) {\r\n    /**\r\n     * Get the value from an expression on this vm.\r\n     *\r\n     * @param {String} exp\r\n     * @param {Boolean} [asStatement]\r\n     * @return {*}\r\n     */\r\n\r\n    Vue.prototype.$get = function (exp, asStatement) {\r\n      var res = parseExpression(exp);\r\n      if (res) {\r\n        if (asStatement) {\r\n          var self = this;\r\n          return function statementHandler() {\r\n            self.$arguments = toArray(arguments);\r\n            var result = res.get.call(self, self);\r\n            self.$arguments = null;\r\n            return result;\r\n          };\r\n        } else {\r\n          try {\r\n            return res.get.call(this, this);\r\n          } catch (e) {}\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Set the value from an expression on this vm.\r\n     * The expression must be a valid left-hand\r\n     * expression in an assignment.\r\n     *\r\n     * @param {String} exp\r\n     * @param {*} val\r\n     */\r\n\r\n    Vue.prototype.$set = function (exp, val) {\r\n      var res = parseExpression(exp, true);\r\n      if (res && res.set) {\r\n        res.set.call(this, this, val);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Delete a property on the VM\r\n     *\r\n     * @param {String} key\r\n     */\r\n\r\n    Vue.prototype.$delete = function (key) {\r\n      del(this._data, key);\r\n    };\r\n\r\n    /**\r\n     * Watch an expression, trigger callback when its\r\n     * value changes.\r\n     *\r\n     * @param {String|Function} expOrFn\r\n     * @param {Function} cb\r\n     * @param {Object} [options]\r\n     *                 - {Boolean} deep\r\n     *                 - {Boolean} immediate\r\n     * @return {Function} - unwatchFn\r\n     */\r\n\r\n    Vue.prototype.$watch = function (expOrFn, cb, options) {\r\n      var vm = this;\r\n      var parsed;\r\n      if (typeof expOrFn === 'string') {\r\n        parsed = parseDirective(expOrFn);\r\n        expOrFn = parsed.expression;\r\n      }\r\n      var watcher = new Watcher(vm, expOrFn, cb, {\r\n        deep: options && options.deep,\r\n        sync: options && options.sync,\r\n        filters: parsed && parsed.filters,\r\n        user: !options || options.user !== false\r\n      });\r\n      if (options && options.immediate) {\r\n        cb.call(vm, watcher.value);\r\n      }\r\n      return function unwatchFn() {\r\n        watcher.teardown();\r\n      };\r\n    };\r\n\r\n    /**\r\n     * Evaluate a text directive, including filters.\r\n     *\r\n     * @param {String} text\r\n     * @param {Boolean} [asStatement]\r\n     * @return {String}\r\n     */\r\n\r\n    Vue.prototype.$eval = function (text, asStatement) {\r\n      // check for filters.\r\n      if (filterRE$1.test(text)) {\r\n        var dir = parseDirective(text);\r\n        // the filter regex check might give false positive\r\n        // for pipes inside strings, so it's possible that\r\n        // we don't get any filters here\r\n        var val = this.$get(dir.expression, asStatement);\r\n        return dir.filters ? this._applyFilters(val, null, dir.filters) : val;\r\n      } else {\r\n        // no filter\r\n        return this.$get(text, asStatement);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Interpolate a piece of template text.\r\n     *\r\n     * @param {String} text\r\n     * @return {String}\r\n     */\r\n\r\n    Vue.prototype.$interpolate = function (text) {\r\n      var tokens = parseText(text);\r\n      var vm = this;\r\n      if (tokens) {\r\n        if (tokens.length === 1) {\r\n          return vm.$eval(tokens[0].value) + '';\r\n        } else {\r\n          return tokens.map(function (token) {\r\n            return token.tag ? vm.$eval(token.value) : token.value;\r\n          }).join('');\r\n        }\r\n      } else {\r\n        return text;\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Log instance data as a plain JS object\r\n     * so that it is easier to inspect in console.\r\n     * This method assumes console is available.\r\n     *\r\n     * @param {String} [path]\r\n     */\r\n\r\n    Vue.prototype.$log = function (path) {\r\n      var data = path ? getPath(this._data, path) : this._data;\r\n      if (data) {\r\n        data = clean(data);\r\n      }\r\n      // include computed fields\r\n      if (!path) {\r\n        var key;\r\n        for (key in this.$options.computed) {\r\n          data[key] = clean(this[key]);\r\n        }\r\n        if (this._props) {\r\n          for (key in this._props) {\r\n            data[key] = clean(this[key]);\r\n          }\r\n        }\r\n      }\r\n      console.log(data);\r\n    };\r\n\r\n    /**\r\n     * \"clean\" a getter/setter converted object into a plain\r\n     * object copy.\r\n     *\r\n     * @param {Object} - obj\r\n     * @return {Object}\r\n     */\r\n\r\n    function clean(obj) {\r\n      return JSON.parse(JSON.stringify(obj));\r\n    }\r\n  }\r\n\r\n  function domAPI (Vue) {\r\n    /**\r\n     * Convenience on-instance nextTick. The callback is\r\n     * auto-bound to the instance, and this avoids component\r\n     * modules having to rely on the global Vue.\r\n     *\r\n     * @param {Function} fn\r\n     */\r\n\r\n    Vue.prototype.$nextTick = function (fn) {\r\n      nextTick(fn, this);\r\n    };\r\n\r\n    /**\r\n     * Append instance to target\r\n     *\r\n     * @param {Node} target\r\n     * @param {Function} [cb]\r\n     * @param {Boolean} [withTransition] - defaults to true\r\n     */\r\n\r\n    Vue.prototype.$appendTo = function (target, cb, withTransition) {\r\n      return insert(this, target, cb, withTransition, append, appendWithTransition);\r\n    };\r\n\r\n    /**\r\n     * Prepend instance to target\r\n     *\r\n     * @param {Node} target\r\n     * @param {Function} [cb]\r\n     * @param {Boolean} [withTransition] - defaults to true\r\n     */\r\n\r\n    Vue.prototype.$prependTo = function (target, cb, withTransition) {\r\n      target = query(target);\r\n      if (target.hasChildNodes()) {\r\n        this.$before(target.firstChild, cb, withTransition);\r\n      } else {\r\n        this.$appendTo(target, cb, withTransition);\r\n      }\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * Insert instance before target\r\n     *\r\n     * @param {Node} target\r\n     * @param {Function} [cb]\r\n     * @param {Boolean} [withTransition] - defaults to true\r\n     */\r\n\r\n    Vue.prototype.$before = function (target, cb, withTransition) {\r\n      return insert(this, target, cb, withTransition, beforeWithCb, beforeWithTransition);\r\n    };\r\n\r\n    /**\r\n     * Insert instance after target\r\n     *\r\n     * @param {Node} target\r\n     * @param {Function} [cb]\r\n     * @param {Boolean} [withTransition] - defaults to true\r\n     */\r\n\r\n    Vue.prototype.$after = function (target, cb, withTransition) {\r\n      target = query(target);\r\n      if (target.nextSibling) {\r\n        this.$before(target.nextSibling, cb, withTransition);\r\n      } else {\r\n        this.$appendTo(target.parentNode, cb, withTransition);\r\n      }\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * Remove instance from DOM\r\n     *\r\n     * @param {Function} [cb]\r\n     * @param {Boolean} [withTransition] - defaults to true\r\n     */\r\n\r\n    Vue.prototype.$remove = function (cb, withTransition) {\r\n      if (!this.$el.parentNode) {\r\n        return cb && cb();\r\n      }\r\n      var inDocument = this._isAttached && inDoc(this.$el);\r\n      // if we are not in document, no need to check\r\n      // for transitions\r\n      if (!inDocument) withTransition = false;\r\n      var self = this;\r\n      var realCb = function realCb() {\r\n        if (inDocument) self._callHook('detached');\r\n        if (cb) cb();\r\n      };\r\n      if (this._isFragment) {\r\n        removeNodeRange(this._fragmentStart, this._fragmentEnd, this, this._fragment, realCb);\r\n      } else {\r\n        var op = withTransition === false ? removeWithCb : removeWithTransition;\r\n        op(this.$el, this, realCb);\r\n      }\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * Shared DOM insertion function.\r\n     *\r\n     * @param {Vue} vm\r\n     * @param {Element} target\r\n     * @param {Function} [cb]\r\n     * @param {Boolean} [withTransition]\r\n     * @param {Function} op1 - op for non-transition insert\r\n     * @param {Function} op2 - op for transition insert\r\n     * @return vm\r\n     */\r\n\r\n    function insert(vm, target, cb, withTransition, op1, op2) {\r\n      target = query(target);\r\n      var targetIsDetached = !inDoc(target);\r\n      var op = withTransition === false || targetIsDetached ? op1 : op2;\r\n      var shouldCallHook = !targetIsDetached && !vm._isAttached && !inDoc(vm.$el);\r\n      if (vm._isFragment) {\r\n        mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {\r\n          op(node, target, vm);\r\n        });\r\n        cb && cb();\r\n      } else {\r\n        op(vm.$el, target, vm, cb);\r\n      }\r\n      if (shouldCallHook) {\r\n        vm._callHook('attached');\r\n      }\r\n      return vm;\r\n    }\r\n\r\n    /**\r\n     * Check for selectors\r\n     *\r\n     * @param {String|Element} el\r\n     */\r\n\r\n    function query(el) {\r\n      return typeof el === 'string' ? document.querySelector(el) : el;\r\n    }\r\n\r\n    /**\r\n     * Append operation that takes a callback.\r\n     *\r\n     * @param {Node} el\r\n     * @param {Node} target\r\n     * @param {Vue} vm - unused\r\n     * @param {Function} [cb]\r\n     */\r\n\r\n    function append(el, target, vm, cb) {\r\n      target.appendChild(el);\r\n      if (cb) cb();\r\n    }\r\n\r\n    /**\r\n     * InsertBefore operation that takes a callback.\r\n     *\r\n     * @param {Node} el\r\n     * @param {Node} target\r\n     * @param {Vue} vm - unused\r\n     * @param {Function} [cb]\r\n     */\r\n\r\n    function beforeWithCb(el, target, vm, cb) {\r\n      before(el, target);\r\n      if (cb) cb();\r\n    }\r\n\r\n    /**\r\n     * Remove operation that takes a callback.\r\n     *\r\n     * @param {Node} el\r\n     * @param {Vue} vm - unused\r\n     * @param {Function} [cb]\r\n     */\r\n\r\n    function removeWithCb(el, vm, cb) {\r\n      remove(el);\r\n      if (cb) cb();\r\n    }\r\n  }\r\n\r\n  function eventsAPI (Vue) {\r\n    /**\r\n     * Listen on the given `event` with `fn`.\r\n     *\r\n     * @param {String} event\r\n     * @param {Function} fn\r\n     */\r\n\r\n    Vue.prototype.$on = function (event, fn) {\r\n      (this._events[event] || (this._events[event] = [])).push(fn);\r\n      modifyListenerCount(this, event, 1);\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * Adds an `event` listener that will be invoked a single\r\n     * time then automatically removed.\r\n     *\r\n     * @param {String} event\r\n     * @param {Function} fn\r\n     */\r\n\r\n    Vue.prototype.$once = function (event, fn) {\r\n      var self = this;\r\n      function on() {\r\n        self.$off(event, on);\r\n        fn.apply(this, arguments);\r\n      }\r\n      on.fn = fn;\r\n      this.$on(event, on);\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * Remove the given callback for `event` or all\r\n     * registered callbacks.\r\n     *\r\n     * @param {String} event\r\n     * @param {Function} fn\r\n     */\r\n\r\n    Vue.prototype.$off = function (event, fn) {\r\n      var cbs;\r\n      // all\r\n      if (!arguments.length) {\r\n        if (this.$parent) {\r\n          for (event in this._events) {\r\n            cbs = this._events[event];\r\n            if (cbs) {\r\n              modifyListenerCount(this, event, -cbs.length);\r\n            }\r\n          }\r\n        }\r\n        this._events = {};\r\n        return this;\r\n      }\r\n      // specific event\r\n      cbs = this._events[event];\r\n      if (!cbs) {\r\n        return this;\r\n      }\r\n      if (arguments.length === 1) {\r\n        modifyListenerCount(this, event, -cbs.length);\r\n        this._events[event] = null;\r\n        return this;\r\n      }\r\n      // specific handler\r\n      var cb;\r\n      var i = cbs.length;\r\n      while (i--) {\r\n        cb = cbs[i];\r\n        if (cb === fn || cb.fn === fn) {\r\n          modifyListenerCount(this, event, -1);\r\n          cbs.splice(i, 1);\r\n          break;\r\n        }\r\n      }\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * Trigger an event on self.\r\n     *\r\n     * @param {String|Object} event\r\n     * @return {Boolean} shouldPropagate\r\n     */\r\n\r\n    Vue.prototype.$emit = function (event) {\r\n      var isSource = typeof event === 'string';\r\n      event = isSource ? event : event.name;\r\n      var cbs = this._events[event];\r\n      var shouldPropagate = isSource || !cbs;\r\n      if (cbs) {\r\n        cbs = cbs.length > 1 ? toArray(cbs) : cbs;\r\n        // this is a somewhat hacky solution to the question raised\r\n        // in #2102: for an inline component listener like <comp @test=\"doThis\">,\r\n        // the propagation handling is somewhat broken. Therefore we\r\n        // need to treat these inline callbacks differently.\r\n        var hasParentCbs = isSource && cbs.some(function (cb) {\r\n          return cb._fromParent;\r\n        });\r\n        if (hasParentCbs) {\r\n          shouldPropagate = false;\r\n        }\r\n        var args = toArray(arguments, 1);\r\n        for (var i = 0, l = cbs.length; i < l; i++) {\r\n          var cb = cbs[i];\r\n          var res = cb.apply(this, args);\r\n          if (res === true && (!hasParentCbs || cb._fromParent)) {\r\n            shouldPropagate = true;\r\n          }\r\n        }\r\n      }\r\n      return shouldPropagate;\r\n    };\r\n\r\n    /**\r\n     * Recursively broadcast an event to all children instances.\r\n     *\r\n     * @param {String|Object} event\r\n     * @param {...*} additional arguments\r\n     */\r\n\r\n    Vue.prototype.$broadcast = function (event) {\r\n      var isSource = typeof event === 'string';\r\n      event = isSource ? event : event.name;\r\n      // if no child has registered for this event,\r\n      // then there's no need to broadcast.\r\n      if (!this._eventsCount[event]) return;\r\n      var children = this.$children;\r\n      var args = toArray(arguments);\r\n      if (isSource) {\r\n        // use object event to indicate non-source emit\r\n        // on children\r\n        args[0] = { name: event, source: this };\r\n      }\r\n      for (var i = 0, l = children.length; i < l; i++) {\r\n        var child = children[i];\r\n        var shouldPropagate = child.$emit.apply(child, args);\r\n        if (shouldPropagate) {\r\n          child.$broadcast.apply(child, args);\r\n        }\r\n      }\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * Recursively propagate an event up the parent chain.\r\n     *\r\n     * @param {String} event\r\n     * @param {...*} additional arguments\r\n     */\r\n\r\n    Vue.prototype.$dispatch = function (event) {\r\n      var shouldPropagate = this.$emit.apply(this, arguments);\r\n      if (!shouldPropagate) return;\r\n      var parent = this.$parent;\r\n      var args = toArray(arguments);\r\n      // use object event to indicate non-source emit\r\n      // on parents\r\n      args[0] = { name: event, source: this };\r\n      while (parent) {\r\n        shouldPropagate = parent.$emit.apply(parent, args);\r\n        parent = shouldPropagate ? parent.$parent : null;\r\n      }\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * Modify the listener counts on all parents.\r\n     * This bookkeeping allows $broadcast to return early when\r\n     * no child has listened to a certain event.\r\n     *\r\n     * @param {Vue} vm\r\n     * @param {String} event\r\n     * @param {Number} count\r\n     */\r\n\r\n    var hookRE = /^hook:/;\r\n    function modifyListenerCount(vm, event, count) {\r\n      var parent = vm.$parent;\r\n      // hooks do not get broadcasted so no need\r\n      // to do bookkeeping for them\r\n      if (!parent || !count || hookRE.test(event)) return;\r\n      while (parent) {\r\n        parent._eventsCount[event] = (parent._eventsCount[event] || 0) + count;\r\n        parent = parent.$parent;\r\n      }\r\n    }\r\n  }\r\n\r\n  function lifecycleAPI (Vue) {\r\n    /**\r\n     * Set instance target element and kick off the compilation\r\n     * process. The passed in `el` can be a selector string, an\r\n     * existing Element, or a DocumentFragment (for block\r\n     * instances).\r\n     *\r\n     * @param {Element|DocumentFragment|string} el\r\n     * @public\r\n     */\r\n\r\n    Vue.prototype.$mount = function (el) {\r\n      if (this._isCompiled) {\r\n        'development' !== 'production' && warn('$mount() should be called only once.', this);\r\n        return;\r\n      }\r\n      el = query(el);\r\n      if (!el) {\r\n        el = document.createElement('div');\r\n      }\r\n      this._compile(el);\r\n      this._initDOMHooks();\r\n      if (inDoc(this.$el)) {\r\n        this._callHook('attached');\r\n        ready.call(this);\r\n      } else {\r\n        this.$once('hook:attached', ready);\r\n      }\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * Mark an instance as ready.\r\n     */\r\n\r\n    function ready() {\r\n      this._isAttached = true;\r\n      this._isReady = true;\r\n      this._callHook('ready');\r\n    }\r\n\r\n    /**\r\n     * Teardown the instance, simply delegate to the internal\r\n     * _destroy.\r\n     *\r\n     * @param {Boolean} remove\r\n     * @param {Boolean} deferCleanup\r\n     */\r\n\r\n    Vue.prototype.$destroy = function (remove, deferCleanup) {\r\n      this._destroy(remove, deferCleanup);\r\n    };\r\n\r\n    /**\r\n     * Partially compile a piece of DOM and return a\r\n     * decompile function.\r\n     *\r\n     * @param {Element|DocumentFragment} el\r\n     * @param {Vue} [host]\r\n     * @param {Object} [scope]\r\n     * @param {Fragment} [frag]\r\n     * @return {Function}\r\n     */\r\n\r\n    Vue.prototype.$compile = function (el, host, scope, frag) {\r\n      return compile(el, this.$options, true)(this, el, host, scope, frag);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * The exposed Vue constructor.\r\n   *\r\n   * API conventions:\r\n   * - public API methods/properties are prefixed with `$`\r\n   * - internal methods/properties are prefixed with `_`\r\n   * - non-prefixed properties are assumed to be proxied user\r\n   *   data.\r\n   *\r\n   * @constructor\r\n   * @param {Object} [options]\r\n   * @public\r\n   */\r\n\r\n  function Vue(options) {\r\n    this._init(options);\r\n  }\r\n\r\n  // install internals\r\n  initMixin(Vue);\r\n  stateMixin(Vue);\r\n  eventsMixin(Vue);\r\n  lifecycleMixin(Vue);\r\n  miscMixin(Vue);\r\n\r\n  // install instance APIs\r\n  dataAPI(Vue);\r\n  domAPI(Vue);\r\n  eventsAPI(Vue);\r\n  lifecycleAPI(Vue);\r\n\r\n  var slot = {\r\n\r\n    priority: SLOT,\r\n    params: ['name'],\r\n\r\n    bind: function bind() {\r\n      // this was resolved during component transclusion\r\n      var name = this.params.name || 'default';\r\n      var content = this.vm._slotContents && this.vm._slotContents[name];\r\n      if (!content || !content.hasChildNodes()) {\r\n        this.fallback();\r\n      } else {\r\n        this.compile(content.cloneNode(true), this.vm._context, this.vm);\r\n      }\r\n    },\r\n\r\n    compile: function compile(content, context, host) {\r\n      if (content && context) {\r\n        if (this.el.hasChildNodes() && content.childNodes.length === 1 && content.childNodes[0].nodeType === 1 && content.childNodes[0].hasAttribute('v-if')) {\r\n          // if the inserted slot has v-if\r\n          // inject fallback content as the v-else\r\n          var elseBlock = document.createElement('template');\r\n          elseBlock.setAttribute('v-else', '');\r\n          elseBlock.innerHTML = this.el.innerHTML;\r\n          // the else block should be compiled in child scope\r\n          elseBlock._context = this.vm;\r\n          content.appendChild(elseBlock);\r\n        }\r\n        var scope = host ? host._scope : this._scope;\r\n        this.unlink = context.$compile(content, host, scope, this._frag);\r\n      }\r\n      if (content) {\r\n        replace(this.el, content);\r\n      } else {\r\n        remove(this.el);\r\n      }\r\n    },\r\n\r\n    fallback: function fallback() {\r\n      this.compile(extractContent(this.el, true), this.vm);\r\n    },\r\n\r\n    unbind: function unbind() {\r\n      if (this.unlink) {\r\n        this.unlink();\r\n      }\r\n    }\r\n  };\r\n\r\n  var partial = {\r\n\r\n    priority: PARTIAL,\r\n\r\n    params: ['name'],\r\n\r\n    // watch changes to name for dynamic partials\r\n    paramWatchers: {\r\n      name: function name(value) {\r\n        vIf.remove.call(this);\r\n        if (value) {\r\n          this.insert(value);\r\n        }\r\n      }\r\n    },\r\n\r\n    bind: function bind() {\r\n      this.anchor = createAnchor('v-partial');\r\n      replace(this.el, this.anchor);\r\n      this.insert(this.params.name);\r\n    },\r\n\r\n    insert: function insert(id) {\r\n      var partial = resolveAsset(this.vm.$options, 'partials', id, true);\r\n      if (partial) {\r\n        this.factory = new FragmentFactory(this.vm, partial);\r\n        vIf.insert.call(this);\r\n      }\r\n    },\r\n\r\n    unbind: function unbind() {\r\n      if (this.frag) {\r\n        this.frag.destroy();\r\n      }\r\n    }\r\n  };\r\n\r\n  var elementDirectives = {\r\n    slot: slot,\r\n    partial: partial\r\n  };\r\n\r\n  var convertArray = vFor._postProcess;\r\n\r\n  /**\r\n   * Limit filter for arrays\r\n   *\r\n   * @param {Number} n\r\n   * @param {Number} offset (Decimal expected)\r\n   */\r\n\r\n  function limitBy(arr, n, offset) {\r\n    offset = offset ? parseInt(offset, 10) : 0;\r\n    n = toNumber(n);\r\n    return typeof n === 'number' ? arr.slice(offset, offset + n) : arr;\r\n  }\r\n\r\n  /**\r\n   * Filter filter for arrays\r\n   *\r\n   * @param {String} search\r\n   * @param {String} [delimiter]\r\n   * @param {String} ...dataKeys\r\n   */\r\n\r\n  function filterBy(arr, search, delimiter) {\r\n    arr = convertArray(arr);\r\n    if (search == null) {\r\n      return arr;\r\n    }\r\n    if (typeof search === 'function') {\r\n      return arr.filter(search);\r\n    }\r\n    // cast to lowercase string\r\n    search = ('' + search).toLowerCase();\r\n    // allow optional `in` delimiter\r\n    // because why not\r\n    var n = delimiter === 'in' ? 3 : 2;\r\n    // extract and flatten keys\r\n    var keys = Array.prototype.concat.apply([], toArray(arguments, n));\r\n    var res = [];\r\n    var item, key, val, j;\r\n    for (var i = 0, l = arr.length; i < l; i++) {\r\n      item = arr[i];\r\n      val = item && item.$value || item;\r\n      j = keys.length;\r\n      if (j) {\r\n        while (j--) {\r\n          key = keys[j];\r\n          if (key === '$key' && contains(item.$key, search) || contains(getPath(val, key), search)) {\r\n            res.push(item);\r\n            break;\r\n          }\r\n        }\r\n      } else if (contains(item, search)) {\r\n        res.push(item);\r\n      }\r\n    }\r\n    return res;\r\n  }\r\n\r\n  /**\r\n   * Filter filter for arrays\r\n   *\r\n   * @param {String|Array<String>|Function} ...sortKeys\r\n   * @param {Number} [order]\r\n   */\r\n\r\n  function orderBy(arr) {\r\n    var comparator = null;\r\n    var sortKeys = undefined;\r\n    arr = convertArray(arr);\r\n\r\n    // determine order (last argument)\r\n    var args = toArray(arguments, 1);\r\n    var order = args[args.length - 1];\r\n    if (typeof order === 'number') {\r\n      order = order < 0 ? -1 : 1;\r\n      args = args.length > 1 ? args.slice(0, -1) : args;\r\n    } else {\r\n      order = 1;\r\n    }\r\n\r\n    // determine sortKeys & comparator\r\n    var firstArg = args[0];\r\n    if (!firstArg) {\r\n      return arr;\r\n    } else if (typeof firstArg === 'function') {\r\n      // custom comparator\r\n      comparator = function (a, b) {\r\n        return firstArg(a, b) * order;\r\n      };\r\n    } else {\r\n      // string keys. flatten first\r\n      sortKeys = Array.prototype.concat.apply([], args);\r\n      comparator = function (a, b, i) {\r\n        i = i || 0;\r\n        return i >= sortKeys.length - 1 ? baseCompare(a, b, i) : baseCompare(a, b, i) || comparator(a, b, i + 1);\r\n      };\r\n    }\r\n\r\n    function baseCompare(a, b, sortKeyIndex) {\r\n      var sortKey = sortKeys[sortKeyIndex];\r\n      if (sortKey) {\r\n        if (sortKey !== '$key') {\r\n          if (isObject(a) && '$value' in a) a = a.$value;\r\n          if (isObject(b) && '$value' in b) b = b.$value;\r\n        }\r\n        a = isObject(a) ? getPath(a, sortKey) : a;\r\n        b = isObject(b) ? getPath(b, sortKey) : b;\r\n      }\r\n      return a === b ? 0 : a > b ? order : -order;\r\n    }\r\n\r\n    // sort on a copy to avoid mutating original array\r\n    return arr.slice().sort(comparator);\r\n  }\r\n\r\n  /**\r\n   * String contain helper\r\n   *\r\n   * @param {*} val\r\n   * @param {String} search\r\n   */\r\n\r\n  function contains(val, search) {\r\n    var i;\r\n    if (isPlainObject(val)) {\r\n      var keys = Object.keys(val);\r\n      i = keys.length;\r\n      while (i--) {\r\n        if (contains(val[keys[i]], search)) {\r\n          return true;\r\n        }\r\n      }\r\n    } else if (isArray(val)) {\r\n      i = val.length;\r\n      while (i--) {\r\n        if (contains(val[i], search)) {\r\n          return true;\r\n        }\r\n      }\r\n    } else if (val != null) {\r\n      return val.toString().toLowerCase().indexOf(search) > -1;\r\n    }\r\n  }\r\n\r\n  var digitsRE = /(\\d{3})(?=\\d)/g;\r\n\r\n  // asset collections must be a plain object.\r\n  var filters = {\r\n\r\n    orderBy: orderBy,\r\n    filterBy: filterBy,\r\n    limitBy: limitBy,\r\n\r\n    /**\r\n     * Stringify value.\r\n     *\r\n     * @param {Number} indent\r\n     */\r\n\r\n    json: {\r\n      read: function read(value, indent) {\r\n        return typeof value === 'string' ? value : JSON.stringify(value, null, arguments.length > 1 ? indent : 2);\r\n      },\r\n      write: function write(value) {\r\n        try {\r\n          return JSON.parse(value);\r\n        } catch (e) {\r\n          return value;\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * 'abc' => 'Abc'\r\n     */\r\n\r\n    capitalize: function capitalize(value) {\r\n      if (!value && value !== 0) return '';\r\n      value = value.toString();\r\n      return value.charAt(0).toUpperCase() + value.slice(1);\r\n    },\r\n\r\n    /**\r\n     * 'abc' => 'ABC'\r\n     */\r\n\r\n    uppercase: function uppercase(value) {\r\n      return value || value === 0 ? value.toString().toUpperCase() : '';\r\n    },\r\n\r\n    /**\r\n     * 'AbC' => 'abc'\r\n     */\r\n\r\n    lowercase: function lowercase(value) {\r\n      return value || value === 0 ? value.toString().toLowerCase() : '';\r\n    },\r\n\r\n    /**\r\n     * 12345 => $12,345.00\r\n     *\r\n     * @param {String} sign\r\n     * @param {Number} decimals Decimal places\r\n     */\r\n\r\n    currency: function currency(value, _currency, decimals) {\r\n      value = parseFloat(value);\r\n      if (!isFinite(value) || !value && value !== 0) return '';\r\n      _currency = _currency != null ? _currency : '$';\r\n      decimals = decimals != null ? decimals : 2;\r\n      var stringified = Math.abs(value).toFixed(decimals);\r\n      var _int = decimals ? stringified.slice(0, -1 - decimals) : stringified;\r\n      var i = _int.length % 3;\r\n      var head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? ',' : '') : '';\r\n      var _float = decimals ? stringified.slice(-1 - decimals) : '';\r\n      var sign = value < 0 ? '-' : '';\r\n      return sign + _currency + head + _int.slice(i).replace(digitsRE, '$1,') + _float;\r\n    },\r\n\r\n    /**\r\n     * 'item' => 'items'\r\n     *\r\n     * @params\r\n     *  an array of strings corresponding to\r\n     *  the single, double, triple ... forms of the word to\r\n     *  be pluralized. When the number to be pluralized\r\n     *  exceeds the length of the args, it will use the last\r\n     *  entry in the array.\r\n     *\r\n     *  e.g. ['single', 'double', 'triple', 'multiple']\r\n     */\r\n\r\n    pluralize: function pluralize(value) {\r\n      var args = toArray(arguments, 1);\r\n      var length = args.length;\r\n      if (length > 1) {\r\n        var index = value % 10 - 1;\r\n        return index in args ? args[index] : args[length - 1];\r\n      } else {\r\n        return args[0] + (value === 1 ? '' : 's');\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Debounce a handler function.\r\n     *\r\n     * @param {Function} handler\r\n     * @param {Number} delay = 300\r\n     * @return {Function}\r\n     */\r\n\r\n    debounce: function debounce(handler, delay) {\r\n      if (!handler) return;\r\n      if (!delay) {\r\n        delay = 300;\r\n      }\r\n      return _debounce(handler, delay);\r\n    }\r\n  };\r\n\r\n  function installGlobalAPI (Vue) {\r\n    /**\r\n     * Vue and every constructor that extends Vue has an\r\n     * associated options object, which can be accessed during\r\n     * compilation steps as `this.constructor.options`.\r\n     *\r\n     * These can be seen as the default options of every\r\n     * Vue instance.\r\n     */\r\n\r\n    Vue.options = {\r\n      directives: directives,\r\n      elementDirectives: elementDirectives,\r\n      filters: filters,\r\n      transitions: {},\r\n      components: {},\r\n      partials: {},\r\n      replace: true\r\n    };\r\n\r\n    /**\r\n     * Expose useful internals\r\n     */\r\n\r\n    Vue.util = util;\r\n    Vue.config = config;\r\n    Vue.set = set;\r\n    Vue['delete'] = del;\r\n    Vue.nextTick = nextTick;\r\n\r\n    /**\r\n     * The following are exposed for advanced usage / plugins\r\n     */\r\n\r\n    Vue.compiler = compiler;\r\n    Vue.FragmentFactory = FragmentFactory;\r\n    Vue.internalDirectives = internalDirectives;\r\n    Vue.parsers = {\r\n      path: path,\r\n      text: text,\r\n      template: template,\r\n      directive: directive,\r\n      expression: expression\r\n    };\r\n\r\n    /**\r\n     * Each instance constructor, including Vue, has a unique\r\n     * cid. This enables us to create wrapped \"child\r\n     * constructors\" for prototypal inheritance and cache them.\r\n     */\r\n\r\n    Vue.cid = 0;\r\n    var cid = 1;\r\n\r\n    /**\r\n     * Class inheritance\r\n     *\r\n     * @param {Object} extendOptions\r\n     */\r\n\r\n    Vue.extend = function (extendOptions) {\r\n      extendOptions = extendOptions || {};\r\n      var Super = this;\r\n      var isFirstExtend = Super.cid === 0;\r\n      if (isFirstExtend && extendOptions._Ctor) {\r\n        return extendOptions._Ctor;\r\n      }\r\n      var name = extendOptions.name || Super.options.name;\r\n      if ('development' !== 'production') {\r\n        if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\r\n          warn('Invalid component name: \"' + name + '\". Component names ' + 'can only contain alphanumeric characaters and the hyphen.');\r\n          name = null;\r\n        }\r\n      }\r\n      var Sub = createClass(name || 'VueComponent');\r\n      Sub.prototype = Object.create(Super.prototype);\r\n      Sub.prototype.constructor = Sub;\r\n      Sub.cid = cid++;\r\n      Sub.options = mergeOptions(Super.options, extendOptions);\r\n      Sub['super'] = Super;\r\n      // allow further extension\r\n      Sub.extend = Super.extend;\r\n      // create asset registers, so extended classes\r\n      // can have their private assets too.\r\n      config._assetTypes.forEach(function (type) {\r\n        Sub[type] = Super[type];\r\n      });\r\n      // enable recursive self-lookup\r\n      if (name) {\r\n        Sub.options.components[name] = Sub;\r\n      }\r\n      // cache constructor\r\n      if (isFirstExtend) {\r\n        extendOptions._Ctor = Sub;\r\n      }\r\n      return Sub;\r\n    };\r\n\r\n    /**\r\n     * A function that returns a sub-class constructor with the\r\n     * given name. This gives us much nicer output when\r\n     * logging instances in the console.\r\n     *\r\n     * @param {String} name\r\n     * @return {Function}\r\n     */\r\n\r\n    function createClass(name) {\r\n      /* eslint-disable no-new-func */\r\n      return new Function('return function ' + classify(name) + ' (options) { this._init(options) }')();\r\n      /* eslint-enable no-new-func */\r\n    }\r\n\r\n    /**\r\n     * Plugin system\r\n     *\r\n     * @param {Object} plugin\r\n     */\r\n\r\n    Vue.use = function (plugin) {\r\n      /* istanbul ignore if */\r\n      if (plugin.installed) {\r\n        return;\r\n      }\r\n      // additional parameters\r\n      var args = toArray(arguments, 1);\r\n      args.unshift(this);\r\n      if (typeof plugin.install === 'function') {\r\n        plugin.install.apply(plugin, args);\r\n      } else {\r\n        plugin.apply(null, args);\r\n      }\r\n      plugin.installed = true;\r\n      return this;\r\n    };\r\n\r\n    /**\r\n     * Apply a global mixin by merging it into the default\r\n     * options.\r\n     */\r\n\r\n    Vue.mixin = function (mixin) {\r\n      Vue.options = mergeOptions(Vue.options, mixin);\r\n    };\r\n\r\n    /**\r\n     * Create asset registration methods with the following\r\n     * signature:\r\n     *\r\n     * @param {String} id\r\n     * @param {*} definition\r\n     */\r\n\r\n    config._assetTypes.forEach(function (type) {\r\n      Vue[type] = function (id, definition) {\r\n        if (!definition) {\r\n          return this.options[type + 's'][id];\r\n        } else {\r\n          /* istanbul ignore if */\r\n          if ('development' !== 'production') {\r\n            if (type === 'component' && (commonTagRE.test(id) || reservedTagRE.test(id))) {\r\n              warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);\r\n            }\r\n          }\r\n          if (type === 'component' && isPlainObject(definition)) {\r\n            if (!definition.name) {\r\n              definition.name = id;\r\n            }\r\n            definition = Vue.extend(definition);\r\n          }\r\n          this.options[type + 's'][id] = definition;\r\n          return definition;\r\n        }\r\n      };\r\n    });\r\n\r\n    // expose internal transition API\r\n    extend(Vue.transition, transition);\r\n  }\r\n\r\n  installGlobalAPI(Vue);\r\n\r\n  Vue.version = '1.0.26';\r\n\r\n  // devtools global hook\r\n  /* istanbul ignore next */\r\n  setTimeout(function () {\r\n    if (config.devtools) {\r\n      if (devtools) {\r\n        devtools.emit('init', Vue);\r\n      } else if ('development' !== 'production' && inBrowser && /Chrome\\/\\d+/.test(window.navigator.userAgent)) {\r\n        console.log('Download the Vue Devtools for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\r\n      }\r\n    }\r\n  }, 0);\r\n\r\n  return Vue;\r\n\r\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/vue/dist/vue.js\n ** module id = 8\n ** module chunks = 9\n **/","/*!\r\n * vue-resource v0.9.3\r\n * https://github.com/vuejs/vue-resource\r\n * Released under the MIT License.\r\n */\r\n\r\n'use strict';\r\n\r\n/**\r\n * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)\r\n */\r\n\r\nvar RESOLVED = 0;\r\nvar REJECTED = 1;\r\nvar PENDING = 2;\r\n\r\nfunction Promise$2(executor) {\r\n\r\n    this.state = PENDING;\r\n    this.value = undefined;\r\n    this.deferred = [];\r\n\r\n    var promise = this;\r\n\r\n    try {\r\n        executor(function (x) {\r\n            promise.resolve(x);\r\n        }, function (r) {\r\n            promise.reject(r);\r\n        });\r\n    } catch (e) {\r\n        promise.reject(e);\r\n    }\r\n}\r\n\r\nPromise$2.reject = function (r) {\r\n    return new Promise$2(function (resolve, reject) {\r\n        reject(r);\r\n    });\r\n};\r\n\r\nPromise$2.resolve = function (x) {\r\n    return new Promise$2(function (resolve, reject) {\r\n        resolve(x);\r\n    });\r\n};\r\n\r\nPromise$2.all = function all(iterable) {\r\n    return new Promise$2(function (resolve, reject) {\r\n        var count = 0,\r\n            result = [];\r\n\r\n        if (iterable.length === 0) {\r\n            resolve(result);\r\n        }\r\n\r\n        function resolver(i) {\r\n            return function (x) {\r\n                result[i] = x;\r\n                count += 1;\r\n\r\n                if (count === iterable.length) {\r\n                    resolve(result);\r\n                }\r\n            };\r\n        }\r\n\r\n        for (var i = 0; i < iterable.length; i += 1) {\r\n            Promise$2.resolve(iterable[i]).then(resolver(i), reject);\r\n        }\r\n    });\r\n};\r\n\r\nPromise$2.race = function race(iterable) {\r\n    return new Promise$2(function (resolve, reject) {\r\n        for (var i = 0; i < iterable.length; i += 1) {\r\n            Promise$2.resolve(iterable[i]).then(resolve, reject);\r\n        }\r\n    });\r\n};\r\n\r\nvar p$1 = Promise$2.prototype;\r\n\r\np$1.resolve = function resolve(x) {\r\n    var promise = this;\r\n\r\n    if (promise.state === PENDING) {\r\n        if (x === promise) {\r\n            throw new TypeError('Promise settled with itself.');\r\n        }\r\n\r\n        var called = false;\r\n\r\n        try {\r\n            var then = x && x['then'];\r\n\r\n            if (x !== null && typeof x === 'object' && typeof then === 'function') {\r\n                then.call(x, function (x) {\r\n                    if (!called) {\r\n                        promise.resolve(x);\r\n                    }\r\n                    called = true;\r\n                }, function (r) {\r\n                    if (!called) {\r\n                        promise.reject(r);\r\n                    }\r\n                    called = true;\r\n                });\r\n                return;\r\n            }\r\n        } catch (e) {\r\n            if (!called) {\r\n                promise.reject(e);\r\n            }\r\n            return;\r\n        }\r\n\r\n        promise.state = RESOLVED;\r\n        promise.value = x;\r\n        promise.notify();\r\n    }\r\n};\r\n\r\np$1.reject = function reject(reason) {\r\n    var promise = this;\r\n\r\n    if (promise.state === PENDING) {\r\n        if (reason === promise) {\r\n            throw new TypeError('Promise settled with itself.');\r\n        }\r\n\r\n        promise.state = REJECTED;\r\n        promise.value = reason;\r\n        promise.notify();\r\n    }\r\n};\r\n\r\np$1.notify = function notify() {\r\n    var promise = this;\r\n\r\n    nextTick(function () {\r\n        if (promise.state !== PENDING) {\r\n            while (promise.deferred.length) {\r\n                var deferred = promise.deferred.shift(),\r\n                    onResolved = deferred[0],\r\n                    onRejected = deferred[1],\r\n                    resolve = deferred[2],\r\n                    reject = deferred[3];\r\n\r\n                try {\r\n                    if (promise.state === RESOLVED) {\r\n                        if (typeof onResolved === 'function') {\r\n                            resolve(onResolved.call(undefined, promise.value));\r\n                        } else {\r\n                            resolve(promise.value);\r\n                        }\r\n                    } else if (promise.state === REJECTED) {\r\n                        if (typeof onRejected === 'function') {\r\n                            resolve(onRejected.call(undefined, promise.value));\r\n                        } else {\r\n                            reject(promise.value);\r\n                        }\r\n                    }\r\n                } catch (e) {\r\n                    reject(e);\r\n                }\r\n            }\r\n        }\r\n    });\r\n};\r\n\r\np$1.then = function then(onResolved, onRejected) {\r\n    var promise = this;\r\n\r\n    return new Promise$2(function (resolve, reject) {\r\n        promise.deferred.push([onResolved, onRejected, resolve, reject]);\r\n        promise.notify();\r\n    });\r\n};\r\n\r\np$1.catch = function (onRejected) {\r\n    return this.then(undefined, onRejected);\r\n};\r\n\r\nvar PromiseObj = window.Promise || Promise$2;\r\n\r\nfunction Promise$1(executor, context) {\r\n\r\n    if (executor instanceof PromiseObj) {\r\n        this.promise = executor;\r\n    } else {\r\n        this.promise = new PromiseObj(executor.bind(context));\r\n    }\r\n\r\n    this.context = context;\r\n}\r\n\r\nPromise$1.all = function (iterable, context) {\r\n    return new Promise$1(PromiseObj.all(iterable), context);\r\n};\r\n\r\nPromise$1.resolve = function (value, context) {\r\n    return new Promise$1(PromiseObj.resolve(value), context);\r\n};\r\n\r\nPromise$1.reject = function (reason, context) {\r\n    return new Promise$1(PromiseObj.reject(reason), context);\r\n};\r\n\r\nPromise$1.race = function (iterable, context) {\r\n    return new Promise$1(PromiseObj.race(iterable), context);\r\n};\r\n\r\nvar p = Promise$1.prototype;\r\n\r\np.bind = function (context) {\r\n    this.context = context;\r\n    return this;\r\n};\r\n\r\np.then = function (fulfilled, rejected) {\r\n\r\n    if (fulfilled && fulfilled.bind && this.context) {\r\n        fulfilled = fulfilled.bind(this.context);\r\n    }\r\n\r\n    if (rejected && rejected.bind && this.context) {\r\n        rejected = rejected.bind(this.context);\r\n    }\r\n\r\n    return new Promise$1(this.promise.then(fulfilled, rejected), this.context);\r\n};\r\n\r\np.catch = function (rejected) {\r\n\r\n    if (rejected && rejected.bind && this.context) {\r\n        rejected = rejected.bind(this.context);\r\n    }\r\n\r\n    return new Promise$1(this.promise.catch(rejected), this.context);\r\n};\r\n\r\np.finally = function (callback) {\r\n\r\n    return this.then(function (value) {\r\n        callback.call(this);\r\n        return value;\r\n    }, function (reason) {\r\n        callback.call(this);\r\n        return PromiseObj.reject(reason);\r\n    });\r\n};\r\n\r\nvar debug = false;\r\nvar util = {};\r\nvar array = [];\r\nfunction Util (Vue) {\r\n    util = Vue.util;\r\n    debug = Vue.config.debug || !Vue.config.silent;\r\n}\r\n\r\nfunction warn(msg) {\r\n    if (typeof console !== 'undefined' && debug) {\r\n        console.warn('[VueResource warn]: ' + msg);\r\n    }\r\n}\r\n\r\nfunction error(msg) {\r\n    if (typeof console !== 'undefined') {\r\n        console.error(msg);\r\n    }\r\n}\r\n\r\nfunction nextTick(cb, ctx) {\r\n    return util.nextTick(cb, ctx);\r\n}\r\n\r\nfunction trim(str) {\r\n    return str.replace(/^\\s*|\\s*$/g, '');\r\n}\r\n\r\nvar isArray = Array.isArray;\r\n\r\nfunction isString(val) {\r\n    return typeof val === 'string';\r\n}\r\n\r\nfunction isBoolean(val) {\r\n    return val === true || val === false;\r\n}\r\n\r\nfunction isFunction(val) {\r\n    return typeof val === 'function';\r\n}\r\n\r\nfunction isObject(obj) {\r\n    return obj !== null && typeof obj === 'object';\r\n}\r\n\r\nfunction isPlainObject(obj) {\r\n    return isObject(obj) && Object.getPrototypeOf(obj) == Object.prototype;\r\n}\r\n\r\nfunction isFormData(obj) {\r\n    return typeof FormData !== 'undefined' && obj instanceof FormData;\r\n}\r\n\r\nfunction when(value, fulfilled, rejected) {\r\n\r\n    var promise = Promise$1.resolve(value);\r\n\r\n    if (arguments.length < 2) {\r\n        return promise;\r\n    }\r\n\r\n    return promise.then(fulfilled, rejected);\r\n}\r\n\r\nfunction options(fn, obj, opts) {\r\n\r\n    opts = opts || {};\r\n\r\n    if (isFunction(opts)) {\r\n        opts = opts.call(obj);\r\n    }\r\n\r\n    return merge(fn.bind({ $vm: obj, $options: opts }), fn, { $options: opts });\r\n}\r\n\r\nfunction each(obj, iterator) {\r\n\r\n    var i, key;\r\n\r\n    if (typeof obj.length == 'number') {\r\n        for (i = 0; i < obj.length; i++) {\r\n            iterator.call(obj[i], obj[i], i);\r\n        }\r\n    } else if (isObject(obj)) {\r\n        for (key in obj) {\r\n            if (obj.hasOwnProperty(key)) {\r\n                iterator.call(obj[key], obj[key], key);\r\n            }\r\n        }\r\n    }\r\n\r\n    return obj;\r\n}\r\n\r\nvar assign = Object.assign || _assign;\r\n\r\nfunction merge(target) {\r\n\r\n    var args = array.slice.call(arguments, 1);\r\n\r\n    args.forEach(function (source) {\r\n        _merge(target, source, true);\r\n    });\r\n\r\n    return target;\r\n}\r\n\r\nfunction defaults(target) {\r\n\r\n    var args = array.slice.call(arguments, 1);\r\n\r\n    args.forEach(function (source) {\r\n\r\n        for (var key in source) {\r\n            if (target[key] === undefined) {\r\n                target[key] = source[key];\r\n            }\r\n        }\r\n    });\r\n\r\n    return target;\r\n}\r\n\r\nfunction _assign(target) {\r\n\r\n    var args = array.slice.call(arguments, 1);\r\n\r\n    args.forEach(function (source) {\r\n        _merge(target, source);\r\n    });\r\n\r\n    return target;\r\n}\r\n\r\nfunction _merge(target, source, deep) {\r\n    for (var key in source) {\r\n        if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\r\n            if (isPlainObject(source[key]) && !isPlainObject(target[key])) {\r\n                target[key] = {};\r\n            }\r\n            if (isArray(source[key]) && !isArray(target[key])) {\r\n                target[key] = [];\r\n            }\r\n            _merge(target[key], source[key], deep);\r\n        } else if (source[key] !== undefined) {\r\n            target[key] = source[key];\r\n        }\r\n    }\r\n}\r\n\r\nfunction root (options, next) {\r\n\r\n    var url = next(options);\r\n\r\n    if (isString(options.root) && !url.match(/^(https?:)?\\//)) {\r\n        url = options.root + '/' + url;\r\n    }\r\n\r\n    return url;\r\n}\r\n\r\nfunction query (options, next) {\r\n\r\n    var urlParams = Object.keys(Url.options.params),\r\n        query = {},\r\n        url = next(options);\r\n\r\n    each(options.params, function (value, key) {\r\n        if (urlParams.indexOf(key) === -1) {\r\n            query[key] = value;\r\n        }\r\n    });\r\n\r\n    query = Url.params(query);\r\n\r\n    if (query) {\r\n        url += (url.indexOf('?') == -1 ? '?' : '&') + query;\r\n    }\r\n\r\n    return url;\r\n}\r\n\r\n/**\r\n * URL Template v2.0.6 (https://github.com/bramstein/url-template)\r\n */\r\n\r\nfunction expand(url, params, variables) {\r\n\r\n    var tmpl = parse(url),\r\n        expanded = tmpl.expand(params);\r\n\r\n    if (variables) {\r\n        variables.push.apply(variables, tmpl.vars);\r\n    }\r\n\r\n    return expanded;\r\n}\r\n\r\nfunction parse(template) {\r\n\r\n    var operators = ['+', '#', '.', '/', ';', '?', '&'],\r\n        variables = [];\r\n\r\n    return {\r\n        vars: variables,\r\n        expand: function (context) {\r\n            return template.replace(/\\{([^\\{\\}]+)\\}|([^\\{\\}]+)/g, function (_, expression, literal) {\r\n                if (expression) {\r\n\r\n                    var operator = null,\r\n                        values = [];\r\n\r\n                    if (operators.indexOf(expression.charAt(0)) !== -1) {\r\n                        operator = expression.charAt(0);\r\n                        expression = expression.substr(1);\r\n                    }\r\n\r\n                    expression.split(/,/g).forEach(function (variable) {\r\n                        var tmp = /([^:\\*]*)(?::(\\d+)|(\\*))?/.exec(variable);\r\n                        values.push.apply(values, getValues(context, operator, tmp[1], tmp[2] || tmp[3]));\r\n                        variables.push(tmp[1]);\r\n                    });\r\n\r\n                    if (operator && operator !== '+') {\r\n\r\n                        var separator = ',';\r\n\r\n                        if (operator === '?') {\r\n                            separator = '&';\r\n                        } else if (operator !== '#') {\r\n                            separator = operator;\r\n                        }\r\n\r\n                        return (values.length !== 0 ? operator : '') + values.join(separator);\r\n                    } else {\r\n                        return values.join(',');\r\n                    }\r\n                } else {\r\n                    return encodeReserved(literal);\r\n                }\r\n            });\r\n        }\r\n    };\r\n}\r\n\r\nfunction getValues(context, operator, key, modifier) {\r\n\r\n    var value = context[key],\r\n        result = [];\r\n\r\n    if (isDefined(value) && value !== '') {\r\n        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\r\n            value = value.toString();\r\n\r\n            if (modifier && modifier !== '*') {\r\n                value = value.substring(0, parseInt(modifier, 10));\r\n            }\r\n\r\n            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));\r\n        } else {\r\n            if (modifier === '*') {\r\n                if (Array.isArray(value)) {\r\n                    value.filter(isDefined).forEach(function (value) {\r\n                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));\r\n                    });\r\n                } else {\r\n                    Object.keys(value).forEach(function (k) {\r\n                        if (isDefined(value[k])) {\r\n                            result.push(encodeValue(operator, value[k], k));\r\n                        }\r\n                    });\r\n                }\r\n            } else {\r\n                var tmp = [];\r\n\r\n                if (Array.isArray(value)) {\r\n                    value.filter(isDefined).forEach(function (value) {\r\n                        tmp.push(encodeValue(operator, value));\r\n                    });\r\n                } else {\r\n                    Object.keys(value).forEach(function (k) {\r\n                        if (isDefined(value[k])) {\r\n                            tmp.push(encodeURIComponent(k));\r\n                            tmp.push(encodeValue(operator, value[k].toString()));\r\n                        }\r\n                    });\r\n                }\r\n\r\n                if (isKeyOperator(operator)) {\r\n                    result.push(encodeURIComponent(key) + '=' + tmp.join(','));\r\n                } else if (tmp.length !== 0) {\r\n                    result.push(tmp.join(','));\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        if (operator === ';') {\r\n            result.push(encodeURIComponent(key));\r\n        } else if (value === '' && (operator === '&' || operator === '?')) {\r\n            result.push(encodeURIComponent(key) + '=');\r\n        } else if (value === '') {\r\n            result.push('');\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nfunction isDefined(value) {\r\n    return value !== undefined && value !== null;\r\n}\r\n\r\nfunction isKeyOperator(operator) {\r\n    return operator === ';' || operator === '&' || operator === '?';\r\n}\r\n\r\nfunction encodeValue(operator, value, key) {\r\n\r\n    value = operator === '+' || operator === '#' ? encodeReserved(value) : encodeURIComponent(value);\r\n\r\n    if (key) {\r\n        return encodeURIComponent(key) + '=' + value;\r\n    } else {\r\n        return value;\r\n    }\r\n}\r\n\r\nfunction encodeReserved(str) {\r\n    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {\r\n        if (!/%[0-9A-Fa-f]/.test(part)) {\r\n            part = encodeURI(part);\r\n        }\r\n        return part;\r\n    }).join('');\r\n}\r\n\r\nfunction template (options) {\r\n\r\n    var variables = [],\r\n        url = expand(options.url, options.params, variables);\r\n\r\n    variables.forEach(function (key) {\r\n        delete options.params[key];\r\n    });\r\n\r\n    return url;\r\n}\r\n\r\n/**\r\n * Service for URL templating.\r\n */\r\n\r\nvar ie = document.documentMode;\r\nvar el = document.createElement('a');\r\n\r\nfunction Url(url, params) {\r\n\r\n    var self = this || {},\r\n        options = url,\r\n        transform;\r\n\r\n    if (isString(url)) {\r\n        options = { url: url, params: params };\r\n    }\r\n\r\n    options = merge({}, Url.options, self.$options, options);\r\n\r\n    Url.transforms.forEach(function (handler) {\r\n        transform = factory(handler, transform, self.$vm);\r\n    });\r\n\r\n    return transform(options);\r\n}\r\n\r\n/**\r\n * Url options.\r\n */\r\n\r\nUrl.options = {\r\n    url: '',\r\n    root: null,\r\n    params: {}\r\n};\r\n\r\n/**\r\n * Url transforms.\r\n */\r\n\r\nUrl.transforms = [template, query, root];\r\n\r\n/**\r\n * Encodes a Url parameter string.\r\n *\r\n * @param {Object} obj\r\n */\r\n\r\nUrl.params = function (obj) {\r\n\r\n    var params = [],\r\n        escape = encodeURIComponent;\r\n\r\n    params.add = function (key, value) {\r\n\r\n        if (isFunction(value)) {\r\n            value = value();\r\n        }\r\n\r\n        if (value === null) {\r\n            value = '';\r\n        }\r\n\r\n        this.push(escape(key) + '=' + escape(value));\r\n    };\r\n\r\n    serialize(params, obj);\r\n\r\n    return params.join('&').replace(/%20/g, '+');\r\n};\r\n\r\n/**\r\n * Parse a URL and return its components.\r\n *\r\n * @param {String} url\r\n */\r\n\r\nUrl.parse = function (url) {\r\n\r\n    if (ie) {\r\n        el.href = url;\r\n        url = el.href;\r\n    }\r\n\r\n    el.href = url;\r\n\r\n    return {\r\n        href: el.href,\r\n        protocol: el.protocol ? el.protocol.replace(/:$/, '') : '',\r\n        port: el.port,\r\n        host: el.host,\r\n        hostname: el.hostname,\r\n        pathname: el.pathname.charAt(0) === '/' ? el.pathname : '/' + el.pathname,\r\n        search: el.search ? el.search.replace(/^\\?/, '') : '',\r\n        hash: el.hash ? el.hash.replace(/^#/, '') : ''\r\n    };\r\n};\r\n\r\nfunction factory(handler, next, vm) {\r\n    return function (options) {\r\n        return handler.call(vm, options, next);\r\n    };\r\n}\r\n\r\nfunction serialize(params, obj, scope) {\r\n\r\n    var array = isArray(obj),\r\n        plain = isPlainObject(obj),\r\n        hash;\r\n\r\n    each(obj, function (value, key) {\r\n\r\n        hash = isObject(value) || isArray(value);\r\n\r\n        if (scope) {\r\n            key = scope + '[' + (plain || hash ? key : '') + ']';\r\n        }\r\n\r\n        if (!scope && array) {\r\n            params.add(value.name, value.value);\r\n        } else if (hash) {\r\n            serialize(params, value, key);\r\n        } else {\r\n            params.add(key, value);\r\n        }\r\n    });\r\n}\r\n\r\nfunction xdrClient (request) {\r\n    return new Promise$1(function (resolve) {\r\n\r\n        var xdr = new XDomainRequest(),\r\n            handler = function (event) {\r\n\r\n            var response = request.respondWith(xdr.responseText, {\r\n                status: xdr.status,\r\n                statusText: xdr.statusText\r\n            });\r\n\r\n            resolve(response);\r\n        };\r\n\r\n        request.abort = function () {\r\n            return xdr.abort();\r\n        };\r\n\r\n        xdr.open(request.method, request.getUrl(), true);\r\n        xdr.timeout = 0;\r\n        xdr.onload = handler;\r\n        xdr.onerror = handler;\r\n        xdr.ontimeout = function () {};\r\n        xdr.onprogress = function () {};\r\n        xdr.send(request.getBody());\r\n    });\r\n}\r\n\r\nvar ORIGIN_URL = Url.parse(location.href);\r\nvar SUPPORTS_CORS = 'withCredentials' in new XMLHttpRequest();\r\n\r\nfunction cors (request, next) {\r\n\r\n    if (!isBoolean(request.crossOrigin) && crossOrigin(request)) {\r\n        request.crossOrigin = true;\r\n    }\r\n\r\n    if (request.crossOrigin) {\r\n\r\n        if (!SUPPORTS_CORS) {\r\n            request.client = xdrClient;\r\n        }\r\n\r\n        delete request.emulateHTTP;\r\n    }\r\n\r\n    next();\r\n}\r\n\r\nfunction crossOrigin(request) {\r\n\r\n    var requestUrl = Url.parse(Url(request));\r\n\r\n    return requestUrl.protocol !== ORIGIN_URL.protocol || requestUrl.host !== ORIGIN_URL.host;\r\n}\r\n\r\nfunction body (request, next) {\r\n\r\n    if (request.emulateJSON && isPlainObject(request.body)) {\r\n        request.body = Url.params(request.body);\r\n        request.headers['Content-Type'] = 'application/x-www-form-urlencoded';\r\n    }\r\n\r\n    if (isFormData(request.body)) {\r\n        delete request.headers['Content-Type'];\r\n    }\r\n\r\n    if (isPlainObject(request.body)) {\r\n        request.body = JSON.stringify(request.body);\r\n    }\r\n\r\n    next(function (response) {\r\n\r\n        var contentType = response.headers['Content-Type'];\r\n\r\n        if (isString(contentType) && contentType.indexOf('application/json') === 0) {\r\n\r\n            try {\r\n                response.data = response.json();\r\n            } catch (e) {\r\n                response.data = null;\r\n            }\r\n        } else {\r\n            response.data = response.text();\r\n        }\r\n    });\r\n}\r\n\r\nfunction jsonpClient (request) {\r\n    return new Promise$1(function (resolve) {\r\n\r\n        var name = request.jsonp || 'callback',\r\n            callback = '_jsonp' + Math.random().toString(36).substr(2),\r\n            body = null,\r\n            handler,\r\n            script;\r\n\r\n        handler = function (event) {\r\n\r\n            var status = 0;\r\n\r\n            if (event.type === 'load' && body !== null) {\r\n                status = 200;\r\n            } else if (event.type === 'error') {\r\n                status = 404;\r\n            }\r\n\r\n            resolve(request.respondWith(body, { status: status }));\r\n\r\n            delete window[callback];\r\n            document.body.removeChild(script);\r\n        };\r\n\r\n        request.params[name] = callback;\r\n\r\n        window[callback] = function (result) {\r\n            body = JSON.stringify(result);\r\n        };\r\n\r\n        script = document.createElement('script');\r\n        script.src = request.getUrl();\r\n        script.type = 'text/javascript';\r\n        script.async = true;\r\n        script.onload = handler;\r\n        script.onerror = handler;\r\n\r\n        document.body.appendChild(script);\r\n    });\r\n}\r\n\r\nfunction jsonp (request, next) {\r\n\r\n    if (request.method == 'JSONP') {\r\n        request.client = jsonpClient;\r\n    }\r\n\r\n    next(function (response) {\r\n\r\n        if (request.method == 'JSONP') {\r\n            response.data = response.json();\r\n        }\r\n    });\r\n}\r\n\r\nfunction before (request, next) {\r\n\r\n    if (isFunction(request.before)) {\r\n        request.before.call(this, request);\r\n    }\r\n\r\n    next();\r\n}\r\n\r\n/**\r\n * HTTP method override Interceptor.\r\n */\r\n\r\nfunction method (request, next) {\r\n\r\n    if (request.emulateHTTP && /^(PUT|PATCH|DELETE)$/i.test(request.method)) {\r\n        request.headers['X-HTTP-Method-Override'] = request.method;\r\n        request.method = 'POST';\r\n    }\r\n\r\n    next();\r\n}\r\n\r\nfunction header (request, next) {\r\n\r\n    request.method = request.method.toUpperCase();\r\n    request.headers = assign({}, Http.headers.common, !request.crossOrigin ? Http.headers.custom : {}, Http.headers[request.method.toLowerCase()], request.headers);\r\n\r\n    next();\r\n}\r\n\r\n/**\r\n * Timeout Interceptor.\r\n */\r\n\r\nfunction timeout (request, next) {\r\n\r\n    var timeout;\r\n\r\n    if (request.timeout) {\r\n        timeout = setTimeout(function () {\r\n            request.abort();\r\n        }, request.timeout);\r\n    }\r\n\r\n    next(function (response) {\r\n\r\n        clearTimeout(timeout);\r\n    });\r\n}\r\n\r\nfunction xhrClient (request) {\r\n    return new Promise$1(function (resolve) {\r\n\r\n        var xhr = new XMLHttpRequest(),\r\n            handler = function (event) {\r\n\r\n            var response = request.respondWith('response' in xhr ? xhr.response : xhr.responseText, {\r\n                status: xhr.status === 1223 ? 204 : xhr.status, // IE9 status bug\r\n                statusText: xhr.status === 1223 ? 'No Content' : trim(xhr.statusText),\r\n                headers: parseHeaders(xhr.getAllResponseHeaders())\r\n            });\r\n\r\n            resolve(response);\r\n        };\r\n\r\n        request.abort = function () {\r\n            return xhr.abort();\r\n        };\r\n\r\n        xhr.open(request.method, request.getUrl(), true);\r\n        xhr.timeout = 0;\r\n        xhr.onload = handler;\r\n        xhr.onerror = handler;\r\n\r\n        if (request.progress) {\r\n            if (request.method === 'GET') {\r\n                xhr.addEventListener('progress', request.progress);\r\n            } else if (/^(POST|PUT)$/i.test(request.method)) {\r\n                xhr.upload.addEventListener('progress', request.progress);\r\n            }\r\n        }\r\n\r\n        if (request.credentials === true) {\r\n            xhr.withCredentials = true;\r\n        }\r\n\r\n        each(request.headers || {}, function (value, header) {\r\n            xhr.setRequestHeader(header, value);\r\n        });\r\n\r\n        xhr.send(request.getBody());\r\n    });\r\n}\r\n\r\nfunction parseHeaders(str) {\r\n\r\n    var headers = {},\r\n        value,\r\n        name,\r\n        i;\r\n\r\n    each(trim(str).split('\\n'), function (row) {\r\n\r\n        i = row.indexOf(':');\r\n        name = trim(row.slice(0, i));\r\n        value = trim(row.slice(i + 1));\r\n\r\n        if (headers[name]) {\r\n\r\n            if (isArray(headers[name])) {\r\n                headers[name].push(value);\r\n            } else {\r\n                headers[name] = [headers[name], value];\r\n            }\r\n        } else {\r\n\r\n            headers[name] = value;\r\n        }\r\n    });\r\n\r\n    return headers;\r\n}\r\n\r\nfunction Client (context) {\r\n\r\n    var reqHandlers = [sendRequest],\r\n        resHandlers = [],\r\n        handler;\r\n\r\n    if (!isObject(context)) {\r\n        context = null;\r\n    }\r\n\r\n    function Client(request) {\r\n        return new Promise$1(function (resolve) {\r\n\r\n            function exec() {\r\n\r\n                handler = reqHandlers.pop();\r\n\r\n                if (isFunction(handler)) {\r\n                    handler.call(context, request, next);\r\n                } else {\r\n                    warn('Invalid interceptor of type ' + typeof handler + ', must be a function');\r\n                    next();\r\n                }\r\n            }\r\n\r\n            function next(response) {\r\n\r\n                if (isFunction(response)) {\r\n\r\n                    resHandlers.unshift(response);\r\n                } else if (isObject(response)) {\r\n\r\n                    resHandlers.forEach(function (handler) {\r\n                        response = when(response, function (response) {\r\n                            return handler.call(context, response) || response;\r\n                        });\r\n                    });\r\n\r\n                    when(response, resolve);\r\n\r\n                    return;\r\n                }\r\n\r\n                exec();\r\n            }\r\n\r\n            exec();\r\n        }, context);\r\n    }\r\n\r\n    Client.use = function (handler) {\r\n        reqHandlers.push(handler);\r\n    };\r\n\r\n    return Client;\r\n}\r\n\r\nfunction sendRequest(request, resolve) {\r\n\r\n    var client = request.client || xhrClient;\r\n\r\n    resolve(client(request));\r\n}\r\n\r\nvar classCallCheck = function (instance, Constructor) {\r\n  if (!(instance instanceof Constructor)) {\r\n    throw new TypeError(\"Cannot call a class as a function\");\r\n  }\r\n};\r\n\r\n/**\r\n * HTTP Response.\r\n */\r\n\r\nvar Response = function () {\r\n    function Response(body, _ref) {\r\n        var url = _ref.url;\r\n        var headers = _ref.headers;\r\n        var status = _ref.status;\r\n        var statusText = _ref.statusText;\r\n        classCallCheck(this, Response);\r\n\r\n\r\n        this.url = url;\r\n        this.body = body;\r\n        this.headers = headers || {};\r\n        this.status = status || 0;\r\n        this.statusText = statusText || '';\r\n        this.ok = status >= 200 && status < 300;\r\n    }\r\n\r\n    Response.prototype.text = function text() {\r\n        return this.body;\r\n    };\r\n\r\n    Response.prototype.blob = function blob() {\r\n        return new Blob([this.body]);\r\n    };\r\n\r\n    Response.prototype.json = function json() {\r\n        return JSON.parse(this.body);\r\n    };\r\n\r\n    return Response;\r\n}();\r\n\r\nvar Request = function () {\r\n    function Request(options) {\r\n        classCallCheck(this, Request);\r\n\r\n\r\n        this.method = 'GET';\r\n        this.body = null;\r\n        this.params = {};\r\n        this.headers = {};\r\n\r\n        assign(this, options);\r\n    }\r\n\r\n    Request.prototype.getUrl = function getUrl() {\r\n        return Url(this);\r\n    };\r\n\r\n    Request.prototype.getBody = function getBody() {\r\n        return this.body;\r\n    };\r\n\r\n    Request.prototype.respondWith = function respondWith(body, options) {\r\n        return new Response(body, assign(options || {}, { url: this.getUrl() }));\r\n    };\r\n\r\n    return Request;\r\n}();\r\n\r\n/**\r\n * Service for sending network requests.\r\n */\r\n\r\nvar CUSTOM_HEADERS = { 'X-Requested-With': 'XMLHttpRequest' };\r\nvar COMMON_HEADERS = { 'Accept': 'application/json, text/plain, */*' };\r\nvar JSON_CONTENT_TYPE = { 'Content-Type': 'application/json;charset=utf-8' };\r\n\r\nfunction Http(options) {\r\n\r\n    var self = this || {},\r\n        client = Client(self.$vm);\r\n\r\n    defaults(options || {}, self.$options, Http.options);\r\n\r\n    Http.interceptors.forEach(function (handler) {\r\n        client.use(handler);\r\n    });\r\n\r\n    return client(new Request(options)).then(function (response) {\r\n\r\n        return response.ok ? response : Promise$1.reject(response);\r\n    }, function (response) {\r\n\r\n        if (response instanceof Error) {\r\n            error(response);\r\n        }\r\n\r\n        return Promise$1.reject(response);\r\n    });\r\n}\r\n\r\nHttp.options = {};\r\n\r\nHttp.headers = {\r\n    put: JSON_CONTENT_TYPE,\r\n    post: JSON_CONTENT_TYPE,\r\n    patch: JSON_CONTENT_TYPE,\r\n    delete: JSON_CONTENT_TYPE,\r\n    custom: CUSTOM_HEADERS,\r\n    common: COMMON_HEADERS\r\n};\r\n\r\nHttp.interceptors = [before, timeout, method, body, jsonp, header, cors];\r\n\r\n['get', 'delete', 'head', 'jsonp'].forEach(function (method) {\r\n\r\n    Http[method] = function (url, options) {\r\n        return this(assign(options || {}, { url: url, method: method }));\r\n    };\r\n});\r\n\r\n['post', 'put', 'patch'].forEach(function (method) {\r\n\r\n    Http[method] = function (url, body, options) {\r\n        return this(assign(options || {}, { url: url, method: method, body: body }));\r\n    };\r\n});\r\n\r\nfunction Resource(url, params, actions, options) {\r\n\r\n    var self = this || {},\r\n        resource = {};\r\n\r\n    actions = assign({}, Resource.actions, actions);\r\n\r\n    each(actions, function (action, name) {\r\n\r\n        action = merge({ url: url, params: params || {} }, options, action);\r\n\r\n        resource[name] = function () {\r\n            return (self.$http || Http)(opts(action, arguments));\r\n        };\r\n    });\r\n\r\n    return resource;\r\n}\r\n\r\nfunction opts(action, args) {\r\n\r\n    var options = assign({}, action),\r\n        params = {},\r\n        body;\r\n\r\n    switch (args.length) {\r\n\r\n        case 2:\r\n\r\n            params = args[0];\r\n            body = args[1];\r\n\r\n            break;\r\n\r\n        case 1:\r\n\r\n            if (/^(POST|PUT|PATCH)$/i.test(options.method)) {\r\n                body = args[0];\r\n            } else {\r\n                params = args[0];\r\n            }\r\n\r\n            break;\r\n\r\n        case 0:\r\n\r\n            break;\r\n\r\n        default:\r\n\r\n            throw 'Expected up to 4 arguments [params, body], got ' + args.length + ' arguments';\r\n    }\r\n\r\n    options.body = body;\r\n    options.params = assign({}, options.params, params);\r\n\r\n    return options;\r\n}\r\n\r\nResource.actions = {\r\n\r\n    get: { method: 'GET' },\r\n    save: { method: 'POST' },\r\n    query: { method: 'GET' },\r\n    update: { method: 'PUT' },\r\n    remove: { method: 'DELETE' },\r\n    delete: { method: 'DELETE' }\r\n\r\n};\r\n\r\nfunction plugin(Vue) {\r\n\r\n    if (plugin.installed) {\r\n        return;\r\n    }\r\n\r\n    Util(Vue);\r\n\r\n    Vue.url = Url;\r\n    Vue.http = Http;\r\n    Vue.resource = Resource;\r\n    Vue.Promise = Promise$1;\r\n\r\n    Object.defineProperties(Vue.prototype, {\r\n\r\n        $url: {\r\n            get: function () {\r\n                return options(Vue.url, this, this.$options.url);\r\n            }\r\n        },\r\n\r\n        $http: {\r\n            get: function () {\r\n                return options(Vue.http, this, this.$options.http);\r\n            }\r\n        },\r\n\r\n        $resource: {\r\n            get: function () {\r\n                return Vue.resource.bind(this);\r\n            }\r\n        },\r\n\r\n        $promise: {\r\n            get: function () {\r\n                var _this = this;\r\n\r\n                return function (executor) {\r\n                    return new Vue.Promise(executor, _this);\r\n                };\r\n            }\r\n        }\r\n\r\n    });\r\n}\r\n\r\nif (typeof window !== 'undefined' && window.Vue) {\r\n    window.Vue.use(plugin);\r\n}\r\n\r\nmodule.exports = plugin;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/vue-resource/dist/vue-resource.common.js\n ** module id = 12\n ** module chunks = 9\n **/","/*!\r\n * vue-router v0.7.13\r\n * (c) 2016 Evan You\r\n * Released under the MIT License.\r\n */\r\n!function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(e):t.VueRouter=e()}(this,function(){\"use strict\";function t(t,e,n){this.path=t,this.matcher=e,this.delegate=n}function e(t){this.routes={},this.children={},this.target=t}function n(e,r,i){return function(o,a){var s=e+o;return a?void a(n(s,r,i)):new t(e+o,r,i)}}function r(t,e,n){for(var r=0,i=0,o=t.length;o>i;i++)r+=t[i].path.length;e=e.substr(r);var a={path:e,handler:n};t.push(a)}function i(t,e,n,o){var a=e.routes;for(var s in a)if(a.hasOwnProperty(s)){var h=t.slice();r(h,s,a[s]),e.children[s]?i(h,e.children[s],n,o):n.call(o,h)}}function o(t,r){var o=new e;t(n(\"\",o,this.delegate)),i([],o,function(t){r?r(this,t):this.add(t)},this)}function a(t){B||\"undefined\"==typeof console||console.error(\"[vue-router] \"+t)}function s(t,e){try{return e?decodeURIComponent(t):decodeURI(t)}catch(n){a(\"malformed URI\"+(e?\" component: \":\": \")+t)}}function h(t){return\"[object Array]\"===Object.prototype.toString.call(t)}function c(t){this.string=t}function u(t){this.name=t}function l(t){this.name=t}function p(){}function f(t,e,n){\"/\"===t.charAt(0)&&(t=t.substr(1));var r=t.split(\"/\"),i=[];n.val=\"\";for(var o=0,a=r.length;a>o;o++){var s,h=r[o];(s=h.match(/^:([^\\/]+)$/))?(i.push(new u(s[1])),e.push(s[1]),n.val+=\"3\"):(s=h.match(/^\\*([^\\/]+)$/))?(i.push(new l(s[1])),n.val+=\"2\",e.push(s[1])):\"\"===h?(i.push(new p),n.val+=\"1\"):(i.push(new c(h)),n.val+=\"4\")}return n.val=+n.val,i}function d(t){this.charSpec=t,this.nextStates=[]}function v(t){return t.sort(function(t,e){return e.specificity.val-t.specificity.val})}function g(t,e){for(var n=[],r=0,i=t.length;i>r;r++){var o=t[r];n=n.concat(o.match(e))}return n}function y(t){this.queryParams=t||{}}function m(t,e,n){for(var r=t.handlers,i=t.regex,o=e.match(i),a=1,s=new y(n),h=0,c=r.length;c>h;h++){for(var u=r[h],l=u.names,p={},f=0,d=l.length;d>f;f++)p[l[f]]=o[a++];s.push({handler:u.handler,params:p,isDynamic:!!l.length})}return s}function _(t,e){return e.eachChar(function(e){t=t.put(e)}),t}function w(t){return t=t.replace(/\\+/gm,\"%20\"),s(t,!0)}function b(t){\"undefined\"!=typeof console&&console.error(\"[vue-router] \"+t)}function C(t,e,n){var r=t.match(/(\\?.*)$/);if(r&&(r=r[1],t=t.slice(0,-r.length)),\"?\"===e.charAt(0))return t+e;var i=t.split(\"/\");n&&i[i.length-1]||i.pop();for(var o=e.replace(/^\\//,\"\").split(\"/\"),a=0;a<o.length;a++){var s=o[a];\".\"!==s&&(\"..\"===s?i.pop():i.push(s))}return\"\"!==i[0]&&i.unshift(\"\"),i.join(\"/\")}function R(t){return t&&\"function\"==typeof t.then}function A(t,e){var n=t&&(t.$options||t.options);return n&&n.route&&n.route[e]}function k(t,e){Y?Y.$options.components._=t.component:Y={resolve:X.Vue.prototype._resolveComponent,$options:{components:{_:t.component}}},Y.resolve(\"_\",function(n){t.component=n,e(n)})}function $(t,e,n){return void 0===e&&(e={}),t=t.replace(/:([^\\/]+)/g,function(n,r){var i=e[r];return i||b('param \"'+r+'\" not found when generating path for \"'+t+'\" with params '+JSON.stringify(e)),i||\"\"}),n&&(t+=K(n)),t}function x(t,e,n){var r=t.childVM;if(!r||!e)return!1;if(t.Component!==e.component)return!1;var i=A(r,\"canReuse\");return\"boolean\"==typeof i?i:i?i.call(r,{to:n.to,from:n.from}):!0}function E(t,e,n){var r=t.childVM,i=A(r,\"canDeactivate\");i?e.callHook(i,r,n,{expectBoolean:!0}):n()}function V(t,e,n){k(t,function(t){if(!e.aborted){var r=A(t,\"canActivate\");r?e.callHook(r,null,n,{expectBoolean:!0}):n()}})}function S(t,e,n){var r=t.childVM,i=A(r,\"deactivate\");i?e.callHooks(i,r,n):n()}function P(t,e,n,r,i){var o=e.activateQueue[n];if(!o)return H(t),t._bound&&t.setComponent(null),void(r&&r());var a=t.Component=o.component,s=A(a,\"activate\"),h=A(a,\"data\"),c=A(a,\"waitForData\");t.depth=n,t.activated=!1;var u=void 0,l=!(!h||c);if(i=i&&t.childVM&&t.childVM.constructor===a)u=t.childVM,u.$loadingRouteData=l;else if(H(t),t.unbuild(!0),u=t.build({_meta:{$loadingRouteData:l},created:function(){this._routerView=t}}),t.keepAlive){u.$loadingRouteData=l;var p=u._keepAliveRouterView;p&&(t.childView=p,u._keepAliveRouterView=null)}var f=function(){u.$destroy()},d=function(){if(i)return void(r&&r());var n=e.router;n._rendered||n._transitionOnLoad?t.transition(u):(t.setCurrent?t.setCurrent(u):t.childVM=u,u.$before(t.anchor,null,!1)),r&&r()},v=function(){t.childView&&P(t.childView,e,n+1,null,i||t.keepAlive),d()},g=function(){t.activated=!0,h&&c?T(u,e,h,v,f):(h&&T(u,e,h),v())};s?e.callHooks(s,u,g,{cleanup:f,postActivate:!0}):g()}function O(t,e){var n=t.childVM,r=A(n,\"data\");r&&T(n,e,r)}function T(t,e,n,r,i){t.$loadingRouteData=!0,e.callHooks(n,t,function(){t.$loadingRouteData=!1,t.$emit(\"route-data-loaded\",t),r&&r()},{cleanup:i,postActivate:!0,processData:function(e){var n=[];return j(e)&&Object.keys(e).forEach(function(r){var i=e[r];R(i)?n.push(i.then(function(e){t.$set(r,e)})):t.$set(r,i)}),n.length?n[0].constructor.all(n):void 0}})}function H(t){t.keepAlive&&t.childVM&&t.childView&&(t.childVM._keepAliveRouterView=t.childView),t.childView=null}function j(t){return\"[object Object]\"===Object.prototype.toString.call(t)}function M(t){return\"[object Object]\"===Object.prototype.toString.call(t)}function D(t){return t?Array.prototype.slice.call(t):[]}function q(t){var e=t.util,n=e.extend,r=e.isArray,i=e.defineReactive,o=t.prototype._init;t.prototype._init=function(t){t=t||{};var e=t._parent||t.parent||this,n=e.$router,r=e.$route;n&&(this.$router=n,n._children.push(this),this._defineMeta?this._defineMeta(\"$route\",r):i(this,\"$route\",r)),o.call(this,t)};var a=t.prototype._destroy;t.prototype._destroy=function(){!this._isBeingDestroyed&&this.$router&&this.$router._children.$remove(this),a.apply(this,arguments)};var s=t.config.optionMergeStrategies,h=/^(data|activate|deactivate)$/;s&&(s.route=function(t,e){if(!e)return t;if(!t)return e;var i={};n(i,t);for(var o in e){var a=i[o],s=e[o];a&&h.test(o)?i[o]=(r(a)?a:[a]).concat(s):i[o]=s}return i})}function z(t){var e=t.util,n=t.directive(\"_component\")||t.internalDirectives.component,r=e.extend({},n);e.extend(r,{_isRouterView:!0,bind:function(){var t=this.vm.$route;if(!t)return void b(\"<router-view> can only be used inside a router-enabled app.\");this._isDynamicLiteral=!0,n.bind.call(this);for(var e=void 0,r=this.vm;r;){if(r._routerView){e=r._routerView;break}r=r.$parent}if(e)this.parentView=e,e.childView=this;else{var i=t.router;i._rootView=this}var o=t.router._currentTransition;if(!e&&o.done||e&&e.activated){var a=e?e.depth+1:0;P(this,o,a)}},unbind:function(){this.parentView&&(this.parentView.childView=null),n.unbind.call(this)}}),t.elementDirective(\"router-view\",r)}function Q(t){function e(t){return t.protocol===location.protocol&&t.hostname===location.hostname&&t.port===location.port}function n(t,e,n){if(e=e.trim(),-1===e.indexOf(\" \"))return void n(t,e);for(var r=e.split(/\\s+/),i=0,o=r.length;o>i;i++)n(t,r[i])}var r=t.util,i=r.bind,o=r.isObject,a=r.addClass,s=r.removeClass,h=t.directive(\"on\").priority,c=\"__vue-router-link-update__\",u=0;t.directive(\"link-active\",{priority:9999,bind:function(){for(var t=this,e=String(u++),n=this.el.querySelectorAll(\"[v-link]\"),r=0,i=n.length;i>r;r++){var o=n[r],a=o.getAttribute(c),s=a?a+\",\"+e:e;o.setAttribute(c,s)}this.vm.$on(c,this.cb=function(n,r){n.activeIds.indexOf(e)>-1&&n.updateClasses(r,t.el)})},unbind:function(){this.vm.$off(c,this.cb)}}),t.directive(\"link\",{priority:h-2,bind:function(){var t=this.vm;if(!t.$route)return void b(\"v-link can only be used inside a router-enabled app.\");this.router=t.$route.router,this.unwatch=t.$watch(\"$route\",i(this.onRouteUpdate,this));var e=this.el.getAttribute(c);e&&(this.el.removeAttribute(c),this.activeIds=e.split(\",\")),\"A\"===this.el.tagName&&\"_blank\"===this.el.getAttribute(\"target\")||(this.handler=i(this.onClick,this),this.el.addEventListener(\"click\",this.handler))},update:function(t){this.target=t,o(t)&&(this.append=t.append,this.exact=t.exact,this.prevActiveClass=this.activeClass,this.activeClass=t.activeClass),this.onRouteUpdate(this.vm.$route)},onClick:function(t){if(!(t.metaKey||t.ctrlKey||t.shiftKey||t.defaultPrevented||0!==t.button)){var n=this.target;if(n)t.preventDefault(),this.router.go(n);else{for(var r=t.target;\"A\"!==r.tagName&&r!==this.el;)r=r.parentNode;if(\"A\"===r.tagName&&e(r)){t.preventDefault();var i=r.pathname;this.router.history.root&&(i=i.replace(this.router.history.rootRE,\"\")),this.router.go({path:i,replace:n&&n.replace,append:n&&n.append})}}}},onRouteUpdate:function(t){var e=this.router.stringifyPath(this.target);this.path!==e&&(this.path=e,this.updateActiveMatch(),this.updateHref()),this.activeIds?this.vm.$emit(c,this,t.path):this.updateClasses(t.path,this.el)},updateActiveMatch:function(){this.activeRE=this.path&&!this.exact?new RegExp(\"^\"+this.path.replace(/\\/$/,\"\").replace(at,\"\").replace(ot,\"\\\\$&\")+\"(\\\\/|$)\"):null},updateHref:function(){if(\"A\"===this.el.tagName){var t=this.path,e=this.router,n=\"/\"===t.charAt(0),r=t&&(\"hash\"===e.mode||n)?e.history.formatPath(t,this.append):t;r?this.el.href=r:this.el.removeAttribute(\"href\")}},updateClasses:function(t,e){var r=this.activeClass||this.router._linkActiveClass;this.prevActiveClass&&this.prevActiveClass!==r&&n(e,this.prevActiveClass,s);var i=this.path.replace(at,\"\");t=t.replace(at,\"\"),this.exact?i===t||\"/\"!==i.charAt(i.length-1)&&i===t.replace(it,\"\")?n(e,r,a):n(e,r,s):this.activeRE&&this.activeRE.test(t)?n(e,r,a):n(e,r,s)},unbind:function(){this.el.removeEventListener(\"click\",this.handler),this.unwatch&&this.unwatch()}})}function F(t,e){var n=e.component;ht.util.isPlainObject(n)&&(n=e.component=ht.extend(n)),\"function\"!=typeof n&&(e.component=null,b('invalid component for route \"'+t+'\".'))}var I={};I.classCallCheck=function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")},t.prototype={to:function(t,e){var n=this.delegate;if(n&&n.willAddRoute&&(t=n.willAddRoute(this.matcher.target,t)),this.matcher.add(this.path,t),e){if(0===e.length)throw new Error(\"You must have an argument in the function passed to `to`\");this.matcher.addChild(this.path,t,e,this.delegate)}return this}},e.prototype={add:function(t,e){this.routes[t]=e},addChild:function(t,r,i,o){var a=new e(r);this.children[t]=a;var s=n(t,a,o);o&&o.contextEntered&&o.contextEntered(r,s),i(s)}};var U=[\"/\",\".\",\"*\",\"+\",\"?\",\"|\",\"(\",\")\",\"[\",\"]\",\"{\",\"}\",\"\\\\\"],L=new RegExp(\"(\\\\\"+U.join(\"|\\\\\")+\")\",\"g\"),B=!1;c.prototype={eachChar:function(t){for(var e,n=this.string,r=0,i=n.length;i>r;r++)e=n.charAt(r),t({validChars:e})},regex:function(){return this.string.replace(L,\"\\\\$1\")},generate:function(){return this.string}},u.prototype={eachChar:function(t){t({invalidChars:\"/\",repeat:!0})},regex:function(){return\"([^/]+)\"},generate:function(t){var e=t[this.name];return null==e?\":\"+this.name:e}},l.prototype={eachChar:function(t){t({invalidChars:\"\",repeat:!0})},regex:function(){return\"(.+)\"},generate:function(t){var e=t[this.name];return null==e?\":\"+this.name:e}},p.prototype={eachChar:function(){},regex:function(){return\"\"},generate:function(){return\"\"}},d.prototype={get:function(t){for(var e=this.nextStates,n=0,r=e.length;r>n;n++){var i=e[n],o=i.charSpec.validChars===t.validChars;if(o=o&&i.charSpec.invalidChars===t.invalidChars)return i}},put:function(t){var e;return(e=this.get(t))?e:(e=new d(t),this.nextStates.push(e),t.repeat&&e.nextStates.push(e),e)},match:function(t){for(var e,n,r,i=this.nextStates,o=[],a=0,s=i.length;s>a;a++)e=i[a],n=e.charSpec,\"undefined\"!=typeof(r=n.validChars)?-1!==r.indexOf(t)&&o.push(e):\"undefined\"!=typeof(r=n.invalidChars)&&-1===r.indexOf(t)&&o.push(e);return o}};var N=Object.create||function(t){function e(){}return e.prototype=t,new e};y.prototype=N({splice:Array.prototype.splice,slice:Array.prototype.slice,push:Array.prototype.push,length:0,queryParams:null});var G=function(){this.rootState=new d,this.names={}};G.prototype={add:function(t,e){for(var n,r=this.rootState,i=\"^\",o={},a=[],s=[],h=!0,c=0,u=t.length;u>c;c++){var l=t[c],d=[],v=f(l.path,d,o);s=s.concat(v);for(var g=0,y=v.length;y>g;g++){var m=v[g];m instanceof p||(h=!1,r=r.put({validChars:\"/\"}),i+=\"/\",r=_(r,m),i+=m.regex())}var w={handler:l.handler,names:d};a.push(w)}h&&(r=r.put({validChars:\"/\"}),i+=\"/\"),r.handlers=a,r.regex=new RegExp(i+\"$\"),r.specificity=o,(n=e&&e.as)&&(this.names[n]={segments:s,handlers:a})},handlersFor:function(t){var e=this.names[t],n=[];if(!e)throw new Error(\"There is no route named \"+t);for(var r=0,i=e.handlers.length;i>r;r++)n.push(e.handlers[r]);return n},hasRoute:function(t){return!!this.names[t]},generate:function(t,e){var n=this.names[t],r=\"\";if(!n)throw new Error(\"There is no route named \"+t);for(var i=n.segments,o=0,a=i.length;a>o;o++){var s=i[o];s instanceof p||(r+=\"/\",r+=s.generate(e))}return\"/\"!==r.charAt(0)&&(r=\"/\"+r),e&&e.queryParams&&(r+=this.generateQueryString(e.queryParams)),r},generateQueryString:function(t){var e=[],n=[];for(var r in t)t.hasOwnProperty(r)&&n.push(r);n.sort();for(var i=0,o=n.length;o>i;i++){r=n[i];var a=t[r];if(null!=a){var s=encodeURIComponent(r);if(h(a))for(var c=0,u=a.length;u>c;c++){var l=r+\"[]=\"+encodeURIComponent(a[c]);e.push(l)}else s+=\"=\"+encodeURIComponent(a),e.push(s)}}return 0===e.length?\"\":\"?\"+e.join(\"&\")},parseQueryString:function(t){for(var e=t.split(\"&\"),n={},r=0;r<e.length;r++){var i,o=e[r].split(\"=\"),a=w(o[0]),s=a.length,h=!1;1===o.length?i=\"true\":(s>2&&\"[]\"===a.slice(s-2)&&(h=!0,a=a.slice(0,s-2),n[a]||(n[a]=[])),i=o[1]?w(o[1]):\"\"),h?n[a].push(i):n[a]=i}return n},recognize:function(t,e){B=e;var n,r,i,o,a=[this.rootState],h={},c=!1;if(o=t.indexOf(\"?\"),-1!==o){var u=t.substr(o+1,t.length);t=t.substr(0,o),u&&(h=this.parseQueryString(u))}if(t=s(t)){for(\"/\"!==t.charAt(0)&&(t=\"/\"+t),n=t.length,n>1&&\"/\"===t.charAt(n-1)&&(t=t.substr(0,n-1),c=!0),r=0,i=t.length;i>r&&(a=g(a,t.charAt(r)),a.length);r++);var l=[];for(r=0,i=a.length;i>r;r++)a[r].handlers&&l.push(a[r]);a=v(l);var p=l[0];return p&&p.handlers?(c&&\"(.+)$\"===p.regex.source.slice(-5)&&(t+=\"/\"),m(p,t,h)):void 0}}},G.prototype.map=o;var K=G.prototype.generateQueryString,X={},Y=void 0,J=/#.*$/,W=function(){function t(e){var n=e.root,r=e.onChange;I.classCallCheck(this,t),n&&\"/\"!==n?(\"/\"!==n.charAt(0)&&(n=\"/\"+n),this.root=n.replace(/\\/$/,\"\"),this.rootRE=new RegExp(\"^\\\\\"+this.root)):this.root=null,this.onChange=r;var i=document.querySelector(\"base\");this.base=i&&i.getAttribute(\"href\")}return t.prototype.start=function(){var t=this;this.listener=function(e){var n=location.pathname+location.search;t.root&&(n=n.replace(t.rootRE,\"\")),t.onChange(n,e&&e.state,location.hash)},window.addEventListener(\"popstate\",this.listener),this.listener()},t.prototype.stop=function(){window.removeEventListener(\"popstate\",this.listener)},t.prototype.go=function(t,e,n){var r=this.formatPath(t,n);e?history.replaceState({},\"\",r):(history.replaceState({pos:{x:window.pageXOffset,y:window.pageYOffset}},\"\",location.href),history.pushState({},\"\",r));var i=t.match(J),o=i&&i[0];t=r.replace(J,\"\").replace(this.rootRE,\"\"),this.onChange(t,null,o)},t.prototype.formatPath=function(t,e){return\"/\"===t.charAt(0)?this.root?this.root+\"/\"+t.replace(/^\\//,\"\"):t:C(this.base||location.pathname,t,e)},t}(),Z=function(){function t(e){var n=e.hashbang,r=e.onChange;I.classCallCheck(this,t),this.hashbang=n,this.onChange=r}return t.prototype.start=function(){var t=this;this.listener=function(){var e=location.hash,n=e.replace(/^#!?/,\"\");\"/\"!==n.charAt(0)&&(n=\"/\"+n);var r=t.formatPath(n);if(r!==e)return void location.replace(r);var i=location.search&&e.indexOf(\"?\")>-1?\"&\"+location.search.slice(1):location.search;t.onChange(e.replace(/^#!?/,\"\")+i)},window.addEventListener(\"hashchange\",this.listener),this.listener()},t.prototype.stop=function(){window.removeEventListener(\"hashchange\",this.listener)},t.prototype.go=function(t,e,n){t=this.formatPath(t,n),e?location.replace(t):location.hash=t},t.prototype.formatPath=function(t,e){var n=\"/\"===t.charAt(0),r=\"#\"+(this.hashbang?\"!\":\"\");return n?r+t:r+C(location.hash.replace(/^#!?/,\"\"),t,e)},t}(),tt=function(){function t(e){var n=e.onChange;I.classCallCheck(this,t),this.onChange=n,this.currentPath=\"/\"}return t.prototype.start=function(){this.onChange(\"/\")},t.prototype.stop=function(){},t.prototype.go=function(t,e,n){t=this.currentPath=this.formatPath(t,n),this.onChange(t)},t.prototype.formatPath=function(t,e){return\"/\"===t.charAt(0)?t:C(this.currentPath,t,e)},t}(),et=function(){function t(e,n,r){I.classCallCheck(this,t),this.router=e,this.to=n,this.from=r,this.next=null,this.aborted=!1,this.done=!1}return t.prototype.abort=function(){if(!this.aborted){this.aborted=!0;var t=!this.from.path&&\"/\"===this.to.path;t||this.router.replace(this.from.path||\"/\")}},t.prototype.redirect=function(t){this.aborted||(this.aborted=!0,\"string\"==typeof t?t=$(t,this.to.params,this.to.query):(t.params=t.params||this.to.params,t.query=t.query||this.to.query),this.router.replace(t))},t.prototype.start=function(t){for(var e=this,n=[],r=this.router._rootView;r;)n.unshift(r),r=r.childView;var i=n.slice().reverse(),o=this.activateQueue=D(this.to.matched).map(function(t){return t.handler}),a=void 0,s=void 0;for(a=0;a<i.length&&x(i[a],o[a],e);a++);a>0&&(s=i.slice(0,a),n=i.slice(a).reverse(),o=o.slice(a)),e.runQueue(n,E,function(){e.runQueue(o,V,function(){e.runQueue(n,S,function(){if(e.router._onTransitionValidated(e),s&&s.forEach(function(t){return O(t,e)}),n.length){var r=n[n.length-1],i=s?s.length:0;P(r,e,i,t)}else t()})})})},t.prototype.runQueue=function(t,e,n){function r(o){o>=t.length?n():e(t[o],i,function(){r(o+1)})}var i=this;r(0)},t.prototype.callHook=function(t,e,n){var r=arguments.length<=3||void 0===arguments[3]?{}:arguments[3],i=r.expectBoolean,o=void 0===i?!1:i,a=r.postActivate,s=void 0===a?!1:a,h=r.processData,c=r.cleanup,u=this,l=!1,p=function(){c&&c(),u.abort()},f=function(t){if(s?v():p(),t&&!u.router._suppress)throw b(\"Uncaught error during transition: \"),t instanceof Error?t:new Error(t)},d=function(t){try{f(t)}catch(e){setTimeout(function(){throw e},0)}},v=function(){return l?void b(\"transition.next() should be called only once.\"):(l=!0,u.aborted?void(c&&c()):void(n&&n()))},g=function(e){\"boolean\"==typeof e?e?v():p():R(e)?e.then(function(t){t?v():p()},d):t.length||v()},y=function(t){var e=void 0;try{e=h(t)}catch(n){return f(n)}R(e)?e.then(v,d):v()},m={to:u.to,from:u.from,abort:p,next:h?y:v,redirect:function(){u.redirect.apply(u,arguments)}},_=void 0;try{_=t.call(e,m)}catch(w){return f(w)}o?g(_):R(_)?h?_.then(y,d):_.then(v,d):h&&M(_)?y(_):t.length||v()},t.prototype.callHooks=function(t,e,n,r){var i=this;Array.isArray(t)?this.runQueue(t,function(t,n,o){i.aborted||i.callHook(t,e,o,r)},n):this.callHook(t,e,n,r)},t}(),nt=/^(component|subRoutes|fullPath)$/,rt=function ut(t,e){var n=this;I.classCallCheck(this,ut);var r=e._recognizer.recognize(t);r&&([].forEach.call(r,function(t){for(var e in t.handler)nt.test(e)||(n[e]=t.handler[e])}),this.query=r.queryParams,this.params=[].reduce.call(r,function(t,e){if(e.params)for(var n in e.params)t[n]=e.params[n];return t},{})),this.path=t,this.matched=r||e._notFoundHandler,Object.defineProperty(this,\"router\",{enumerable:!1,value:e}),Object.freeze(this)},it=/\\/$/,ot=/[-.*+?^${}()|[\\]\\/\\\\]/g,at=/\\?.*$/,st={\"abstract\":tt,hash:Z,html5:W},ht=void 0,ct=function(){function t(){var e=this,n=arguments.length<=0||void 0===arguments[0]?{}:arguments[0],r=n.hashbang,i=void 0===r?!0:r,o=n[\"abstract\"],a=void 0===o?!1:o,s=n.history,h=void 0===s?!1:s,c=n.saveScrollPosition,u=void 0===c?!1:c,l=n.transitionOnLoad,p=void 0===l?!1:l,f=n.suppressTransitionError,d=void 0===f?!1:f,v=n.root,g=void 0===v?null:v,y=n.linkActiveClass,m=void 0===y?\"v-link-active\":y;if(I.classCallCheck(this,t),!t.installed)throw new Error(\"Please install the Router with Vue.use() before creating an instance.\");this.app=null,this._children=[],this._recognizer=new G,this._guardRecognizer=new G,this._started=!1,this._startCb=null,this._currentRoute={},this._currentTransition=null,this._previousTransition=null,this._notFoundHandler=null,this._notFoundRedirect=null,this._beforeEachHooks=[],this._afterEachHooks=[],this._rendered=!1,this._transitionOnLoad=p,this._root=g,this._abstract=a,this._hashbang=i;var _=\"undefined\"!=typeof window&&window.history&&window.history.pushState;this._history=h&&_,this._historyFallback=h&&!_;var w=ht.util.inBrowser;this.mode=!w||this._abstract?\"abstract\":this._history?\"html5\":\"hash\";var b=st[this.mode];this.history=new b({root:g,hashbang:this._hashbang,onChange:function(t,n,r){e._match(t,n,r)}}),this._saveScrollPosition=u,this._linkActiveClass=m,this._suppress=d}return t.prototype.map=function(t){for(var e in t)this.on(e,t[e]);return this},t.prototype.on=function(t,e){return\"*\"===t?this._notFound(e):this._addRoute(t,e,[]),this},t.prototype.redirect=function(t){for(var e in t)this._addRedirect(e,t[e]);return this},t.prototype.alias=function(t){for(var e in t)this._addAlias(e,t[e]);return this},t.prototype.beforeEach=function(t){return this._beforeEachHooks.push(t),this},t.prototype.afterEach=function(t){return this._afterEachHooks.push(t),this},t.prototype.go=function(t){var e=!1,n=!1;ht.util.isObject(t)&&(e=t.replace,n=t.append),t=this.stringifyPath(t),t&&this.history.go(t,e,n)},t.prototype.replace=function(t){\"string\"==typeof t&&(t={path:t}),t.replace=!0,this.go(t)},t.prototype.start=function(t,e,n){if(this._started)return void b(\"already started.\");if(this._started=!0,this._startCb=n,!this.app){if(!t||!e)throw new Error(\"Must start vue-router with a component and a root container.\");if(t instanceof ht)throw new Error(\"Must start vue-router with a component, not a Vue instance.\");this._appContainer=e;var r=this._appConstructor=\"function\"==typeof t?t:ht.extend(t);r.options.name=r.options.name||\"RouterApp\"}if(this._historyFallback){var i=window.location,o=new W({root:this._root}),a=o.root?i.pathname.replace(o.rootRE,\"\"):i.pathname;if(a&&\"/\"!==a)return void i.assign((o.root||\"\")+\"/\"+this.history.formatPath(a)+i.search)}this.history.start()},t.prototype.stop=function(){this.history.stop(),this._started=!1},t.prototype.stringifyPath=function(t){var e=\"\";if(t&&\"object\"==typeof t){if(t.name){var n=ht.util.extend,r=this._currentTransition&&this._currentTransition.to.params,i=t.params||{},o=r?n(n({},r),i):i;e=encodeURI(this._recognizer.generate(t.name,o))}else t.path&&(e=encodeURI(t.path));if(t.query){var a=this._recognizer.generateQueryString(t.query);e+=e.indexOf(\"?\")>-1?\"&\"+a.slice(1):a}}else e=encodeURI(t?t+\"\":\"\");return e},t.prototype._addRoute=function(t,e,n){if(F(t,e),e.path=t,e.fullPath=(n.reduce(function(t,e){return t+e.path},\"\")+t).replace(\"//\",\"/\"),n.push({path:t,handler:e}),this._recognizer.add(n,{as:e.name}),e.subRoutes)for(var r in e.subRoutes)this._addRoute(r,e.subRoutes[r],n.slice())},t.prototype._notFound=function(t){F(\"*\",t),this._notFoundHandler=[{handler:t}]},t.prototype._addRedirect=function(t,e){\"*\"===t?this._notFoundRedirect=e:this._addGuard(t,e,this.replace)},t.prototype._addAlias=function(t,e){this._addGuard(t,e,this._match)},t.prototype._addGuard=function(t,e,n){var r=this;this._guardRecognizer.add([{path:t,handler:function(t,i){var o=$(e,t.params,i);n.call(r,o)}}])},t.prototype._checkGuard=function(t){var e=this._guardRecognizer.recognize(t,!0);return e?(e[0].handler(e[0],e.queryParams),!0):this._notFoundRedirect&&(e=this._recognizer.recognize(t),!e)?(this.replace(this._notFoundRedirect),!0):void 0},t.prototype._match=function(t,e,n){var r=this;if(!this._checkGuard(t)){var i=this._currentRoute,o=this._currentTransition;if(o){if(o.to.path===t)return;if(i.path===t)return o.aborted=!0,void(this._currentTransition=this._prevTransition);o.aborted=!0}var a=new rt(t,this),s=new et(this,a,i);this._prevTransition=o,this._currentTransition=s,this.app||!function(){var t=r;r.app=new r._appConstructor({el:r._appContainer,created:function(){this.$router=t},_meta:{$route:a}})}();var h=this._beforeEachHooks,c=function(){s.start(function(){r._postTransition(a,e,n)})};h.length?s.runQueue(h,function(t,e,n){s===r._currentTransition&&s.callHook(t,null,n,{expectBoolean:!0})},c):c(),!this._rendered&&this._startCb&&this._startCb.call(null),this._rendered=!0}},t.prototype._onTransitionValidated=function(t){var e=this._currentRoute=t.to;this.app.$route!==e&&(this.app.$route=e,this._children.forEach(function(t){t.$route=e})),this._afterEachHooks.length&&this._afterEachHooks.forEach(function(e){return e.call(null,{to:t.to,from:t.from})}),this._currentTransition.done=!0},t.prototype._postTransition=function(t,e,n){var r=e&&e.pos;r&&this._saveScrollPosition?ht.nextTick(function(){window.scrollTo(r.x,r.y)}):n&&ht.nextTick(function(){var t=document.getElementById(n.slice(1));t&&window.scrollTo(window.scrollX,t.offsetTop)})},t}();return ct.installed=!1,ct.install=function(t){return ct.installed?void b(\"already installed.\"):(ht=t,q(ht),z(ht),Q(ht),X.Vue=ht,void(ct.installed=!0))},\"undefined\"!=typeof window&&window.Vue&&window.Vue.use(ct),ct});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/vue-router/dist/vue-router.min.js\n ** module id = 13\n ** module chunks = 9\n **/","!function(){function e(e){return e.charAt(0).toUpperCase()+e.slice(1)}function t(e){var t=e.direction;if(\"string\"==typeof t){var i=\"DIRECTION_\"+t.toUpperCase();o.indexOf(t)>-1&&r.hasOwnProperty(i)?e.direction=r[i]:console.warn(\"[vue-touch] invalid direction: \"+t)}}var i={},r=\"function\"==typeof require?require(\"hammerjs\"):window.Hammer,n=[\"tap\",\"pan\",\"pinch\",\"press\",\"rotate\",\"swipe\"],o=[\"up\",\"down\",\"left\",\"right\",\"horizontal\",\"vertical\",\"all\"],a={};if(!r)throw new Error(\"[vue-touch] cannot locate Hammer.js.\");i.config={},i.install=function(o){o.directive(\"touch\",{isFn:!0,acceptStatement:!0,priority:o.directive(\"on\").priority,bind:function(){this.el.hammer||(this.el.hammer=new r.Manager(this.el));var o=this.mc=this.el.hammer,s=this.arg;s||console.warn(\"[vue-touch] event type argument is required.\");var h,c;if(a[s]){var u=a[s];h=u.type,c=new(r[e(h)])(u),c.recognizeWith(o.recognizers),o.add(c)}else{for(var d=0;d<n.length;d++)if(0===s.indexOf(n[d])){h=n[d];break}if(!h)return void console.warn(\"[vue-touch] invalid event type: \"+s);c=o.get(h),c||(c=new(r[e(h)]),c.recognizeWith(o.recognizers),o.add(c));var f=i.config[h];f&&(t(f),c.set(f));var l=this.el.hammerOptions&&this.el.hammerOptions[h];l&&(t(l),c.set(l))}this.recognizer=c},update:function(e){var t=this.mc,i=this.arg;this.handler&&t.off(i,this.handler),\"function\"!=typeof e?console.warn(\"[vue-touch] invalid handler function for v-touch: \"+this.arg+'=\"'+this.descriptor.raw):t.on(i,this.handler=e)},unbind:function(){this.mc.off(this.arg,this.handler),Object.keys(this.mc.handlers).length||(this.mc.destroy(),this.el.hammer=null)}}),o.directive(\"touch-options\",{priority:o.directive(\"on\").priority+1,update:function(e){var t=this.el.hammerOptions||(this.el.hammerOptions={});this.arg?t[this.arg]=e:console.warn(\"[vue-touch] recognizer type argument for v-touch-options is required.\")}})},i.registerCustomEvent=function(e,t){t.event=e,a[e]=t},\"object\"==typeof exports?module.exports=i:\"function\"==typeof define&&define.amd?define([],function(){return i}):window.Vue&&(window.VueTouch=i,Vue.use(i))}();\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/vue-touch/vue-touch.min.js\n ** module id = 14\n ** module chunks = 9\n **/","/*!\r\n * Vuex v0.8.2\r\n * (c) 2016 Evan You\r\n * Released under the MIT License.\r\n */\r\n!function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(e):t.Vuex=e()}(this,function(){\"use strict\";function t(t){return t.reduce(function(t,e){return Object.keys(e).forEach(function(n){var o=t[n];o?Array.isArray(o)?o.push(e[n]):t[n]=[t[n],e[n]]:t[n]=e[n]}),t},{})}function e(t){if(Array.isArray(t))return t.map(e);if(t&&\"object\"===(\"undefined\"==typeof t?\"undefined\":a(t))){for(var n={},o=Object.keys(t),i=0,r=o.length;i<r;i++){var s=o[i];n[s]=e(t[s])}return n}return t}function n(t){if(!f){var e=function(){},n=t.$watch(e,e);f=t._watchers[0].constructor,n()}return f}function o(t){return d||(d=t._data.__ob__.dep.constructor),d}function i(t){function e(){var t=this.$options,e=t.store,n=t.vuex;if(e?this.$store=e:t.parent&&t.parent.$store&&(this.$store=t.parent.$store),n){this.$store||console.warn(\"[vuex] store not injected. make sure to provide the store option in your root component.\");var o=n.state,i=n.actions,a=n.getters;if(o&&!a&&(console.warn(\"[vuex] vuex.state option will been deprecated in 1.0. Use vuex.getters instead.\"),a=o),a){t.computed=t.computed||{};for(var u in a)r(this,u,a[u])}if(i){t.methods=t.methods||{};for(var c in i)t.methods[c]=s(this.$store,i[c],c)}}}function i(){throw new Error(\"vuex getter properties are read-only.\")}function r(t,e,n){\"function\"!=typeof n?console.warn(\"[vuex] Getter bound to key 'vuex.getters.\"+e+\"' is not a function.\"):Object.defineProperty(t,e,{enumerable:!0,configurable:!0,get:a(t.$store,n),set:i})}function a(t,e){var i=t._getterCacheId;if(e[i])return e[i];var r=t._vm,a=n(r),s=o(r),u=new a(r,function(t){return e(t.state)},null,{lazy:!0}),c=function(){return u.dirty&&u.evaluate(),s.target&&u.depend(),u.value};return e[i]=c,c}function s(t,e,n){return\"function\"!=typeof e&&console.warn(\"[vuex] Action bound to key 'vuex.actions.\"+n+\"' is not a function.\"),function(){for(var n=arguments.length,o=Array(n),i=0;i<n;i++)o[i]=arguments[i];return e.call.apply(e,[this,t].concat(o))}}var u=Number(t.version.split(\".\")[0]);if(u>=2){var c=t.config._lifecycleHooks.indexOf(\"init\")>-1;t.mixin(c?{init:e}:{beforeCreate:e})}else!function(){var n=t.prototype._init;t.prototype._init=function(){var t=arguments.length<=0||void 0===arguments[0]?{}:arguments[0];t.init=t.init?[e].concat(t.init):e,n.call(this,t)}}();var f=t.config.optionMergeStrategies.computed;t.config.optionMergeStrategies.vuex=function(t,e){return t?e?{getters:f(t.getters,e.getters),state:f(t.state,e.state),actions:f(t.actions,e.actions)}:t:e}}function r(t){return p?void console.warn(\"[vuex] already installed. Vue.use(Vuex) should be called only once.\"):(p=t,void i(p))}var a=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol?\"symbol\":typeof t},s=function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")},u=function(){function t(t,e){for(var n=0;n<e.length;n++){var o=e[n];o.enumerable=o.enumerable||!1,o.configurable=!0,\"value\"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o)}}return function(e,n,o){return n&&t(e.prototype,n),o&&t(e,o),e}}(),c=function(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++)n[e]=t[e];return n}return Array.from(t)},f=void 0,d=void 0,h=\"undefined\"!=typeof window&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__,l={onInit:function(t,e){h&&(h.emit(\"vuex:init\",e),h.on(\"vuex:travel-to-state\",function(t){e._dispatching=!0,e._vm.state=t,e._dispatching=!1}))},onMutation:function(t,e){h&&h.emit(\"vuex:mutation\",t,e)}},p=void 0,v=0,y=function(){function o(){var t=this,e=arguments.length<=0||void 0===arguments[0]?{}:arguments[0],n=e.state,i=void 0===n?{}:n,r=e.mutations,a=void 0===r?{}:r,u=e.modules,c=void 0===u?{}:u,f=e.middlewares,d=void 0===f?[]:f,h=e.strict,l=void 0!==h&&h;s(this,o),this._getterCacheId=\"vuex_store_\"+v++,this._dispatching=!1,this._rootMutations=this._mutations=a,this._modules=c;var y=this.dispatch;if(this.dispatch=function(){for(var e=arguments.length,n=Array(e),o=0;o<e;o++)n[o]=arguments[o];y.apply(t,n)},!p)throw new Error(\"[vuex] must call Vue.use(Vuex) before creating a store instance.\");var _=p.config.silent;p.config.silent=!0,this._vm=new p({data:{state:i}}),p.config.silent=_,this._setupModuleState(i,c),this._setupModuleMutations(c),this._setupMiddlewares(d,i),l&&this._setupMutationCheck()}return u(o,[{key:\"dispatch\",value:function(t){for(var e=arguments.length,n=Array(e>1?e-1:0),o=1;o<e;o++)n[o-1]=arguments[o];var i=!1;\"object\"===(\"undefined\"==typeof t?\"undefined\":a(t))&&t.type&&1===arguments.length&&(n=[t.payload],t.silent&&(i=!0),t=t.type);var r=this._mutations[t],s=this.state;r?(this._dispatching=!0,Array.isArray(r)?r.forEach(function(t){return t.apply(void 0,[s].concat(c(n)))}):r.apply(void 0,[s].concat(c(n))),this._dispatching=!1,i||this._applyMiddlewares(t,n)):console.warn(\"[vuex] Unknown mutation: \"+t)}},{key:\"watch\",value:function(t,e,n){var o=this;return\"function\"!=typeof t?void console.error(\"Vuex store.watch only accepts function.\"):this._vm.$watch(function(){return t(o.state)},e,n)}},{key:\"hotUpdate\",value:function(){var t=arguments.length<=0||void 0===arguments[0]?{}:arguments[0],e=t.mutations,n=t.modules;this._rootMutations=this._mutations=e||this._rootMutations,this._setupModuleMutations(n||this._modules)}},{key:\"_setupModuleState\",value:function(t,e){Object.keys(e).forEach(function(n){p.set(t,n,e[n].state||{})})}},{key:\"_setupModuleMutations\",value:function(e){var n=this._modules,o=[this._rootMutations];Object.keys(e).forEach(function(t){n[t]=e[t]}),Object.keys(n).forEach(function(t){var e=n[t];if(e&&e.mutations){var i={};Object.keys(e.mutations).forEach(function(n){var o=e.mutations[n];i[n]=function(e){for(var n=arguments.length,i=Array(n>1?n-1:0),r=1;r<n;r++)i[r-1]=arguments[r];o.apply(void 0,[e[t]].concat(i))}}),o.push(i)}}),this._mutations=t(o)}},{key:\"_setupMutationCheck\",value:function(){var t=this,e=n(this._vm);new e(this._vm,\"state\",function(){if(!t._dispatching)throw new Error(\"[vuex] Do not mutate vuex store state outside mutation handlers.\")},{deep:!0,sync:!0})}},{key:\"_setupMiddlewares\",value:function(t,n){var o=this;this._middlewares=[l].concat(t),this._needSnapshots=t.some(function(t){return t.snapshot}),this._needSnapshots&&console.log(\"[vuex] One or more of your middlewares are taking state snapshots for each mutation. Make sure to use them only during development.\");var i=this._prevSnapshot=this._needSnapshots?e(n):null;this._middlewares.forEach(function(t){t.onInit&&t.onInit(t.snapshot?i:n,o)})}},{key:\"_applyMiddlewares\",value:function(t,n){var o=this,i=this.state,r=this._prevSnapshot,a=void 0,s=void 0;this._needSnapshots&&(a=this._prevSnapshot=e(i),s=e(n)),this._middlewares.forEach(function(e){e.onMutation&&(e.snapshot?e.onMutation({type:t,payload:s},a,r,o):e.onMutation({type:t,payload:n},i,o))})}},{key:\"state\",get:function(){return this._vm.state},set:function(t){throw new Error(\"[vuex] Vuex root state is read only.\")}}]),o}();\"undefined\"!=typeof window&&window.Vue&&r(window.Vue);var _={Store:y,install:r};return _});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/vuex/dist/vuex.min.js\n ** module id = 15\n ** module chunks = 9\n **/","<template>\r\n\t<div id=\"main\">\r\n\t\t<router-view transition=\"change\" > </router-view>\r\n\t\t<div class=\"dialog\" transition=\"bounce\" v-show=\"showDialog\" >\r\n\t\t\t{{msg}}\r\n\t\t</div>\r\n\t</div>\r\n</template>\r\n\r\n\r\n<script>\r\n\timport store from './vuex/store.js';\r\n\timport webview from './js/webviewtestShare.js';\r\n\timport share from './js/shareInfo.js';\r\n\r\n\r\n\t// uid \r\n   \r\n\t//url\r\n\tvar GetQueryString = function (name) {\r\n\t\tvar reg = new RegExp(\"(^|&)\" + name + \"=([^&]*)(&|$)\", \"i\");\r\n\t\tvar r = window.location.search.substr(1).match(reg);\r\n\t\tif (r != null) return (r[2]);\r\n\t\treturn null;\r\n\t};\r\n\r\n\r\n\t\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\tmodule.exports = {\r\n\t\tstore,\r\n\t\tdata:function(){\r\n\t\t\treturn {\r\n\t\t\t\tshowDialog:false,\r\n\t\t\t\tmsg:''\r\n\t\t\t}\r\n\t\t},\r\n\t\tmethods:{\r\n\t\t\tSSS:function(){\r\n\t\t\t\tthis.showDialog=!this.showDialog\r\n\t\t\t},\r\n\t\t\thideDialog:()=>{\r\n\t\t\t\tthis.showDialog = false\r\n\t\t\t}\r\n\r\n\t\t\t\t\r\n\r\n\t\t},\r\n\t\tevents:{\r\n\t\t\t'showDialog':function(message){\r\n\t\t\t\tthis.showDialog = true;\r\n\t\t\t\tthis.msg = message;\r\n\t\t\t\tvar self=this;\r\n\t\t\t\tsetTimeout(function(){\r\n\t\t\t\t\tself.showDialog = false;\r\n\t\t\t\t},900)\r\n\t\t\t}\r\n\t\t},\r\n\t\tcreated:function(){\r\n\t\t\t//\r\n\t\t\tvar data = {\r\n\t\t\t\tuid:GetQueryString('uid'),\r\n\t\t\t\turl:window.location.href\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis.$http.post('../user-info.csp',data,{\r\n\t\t\t\temulateJSON:true\r\n\t\t\t}).then(function (response) {\r\n\t\t\t\t//\r\n\t\t\t\tvar obj=response.json()\r\n\t\t\t\tvar u = navigator.userAgent;\r\n        \t\tvar isAndroid = u.indexOf('Android') > -1 || u.indexOf('Linux') > -1;\r\n        \t\tvar isIOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/);\r\n        \t\tif (isAndroid) {\r\n        \t\t\tobj.ymMoney = obj.ymMoneyAdr\r\n        \t\t}else if (isIOS) {\r\n        \t\t\tobj.ymMoney = obj.ymMoneyAdr + obj.ymMoneyIph\r\n        \t\t}else {\r\n        \t\t\tobj.ymMoney = obj.ymMoneyAdr + obj.ymMoneyIph\r\n        \t\t}\r\n\r\n       \t\t \tstore.dispatch('GETINFO',obj)\r\n\t      }, function (response) {\r\n\t          console.log(\"error\")\r\n\t      });\r\n\r\n\t\t\tstore.dispatch('GETUID',GetQueryString('uid'))\r\n\t\t},\r\n\t\tready:function(){\r\n\t\t\t\t\t\t\t\r\n\r\n\t\t\r\n\t\t\t//01\r\n\t\t\twebview.test(1);\r\n\t\t\tshare.share();\r\n\t\t\t// closeBtn.close_()\r\n\t\t\t\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n</script>\r\n\r\n\r\n<style lang=\"sass\">\r\n\r\n\r\n\t.dialog{\r\n\t\tposition: fixed;\r\n\t\twidth: 60%;\r\n\t\theight: 4.2rem;\r\n\t\tfont-size: 1.8rem;\r\n\t\tbackground-color: #000;\r\n\t\tcolor: #fff;\r\n\t\tleft: 50%;\r\n\t\ttop: 45%;\r\n\t\tvertical-align: middle;\r\n\t\tborder-radius: 10px;\r\n\t\tmargin-left: -30%;\r\n\t\tmargin-top: -2.1rem;\r\n\t\ttext-align: center;\r\n\t\tpadding: 10px 2px;\r\n\t}\r\n\r\n\r\n.bounce-transition {\r\n\r\n}\r\n.bounce-enter {\r\n  animation: bounce-in .4s;\r\n}\r\n.bounce-leave {\r\n  animation: bounce-out .4s;\r\n}\r\n@keyframes bounce-in {\r\n  0% {\r\n    transform: scale(0);\r\n  }\r\n  50% {\r\n    transform: scale(1.2);\r\n  }\r\n  100% {\r\n    transform: scale(1);\r\n  }\r\n}\r\n@keyframes bounce-out {\r\n  0% {\r\n    transform: scale(1);\r\n  }\r\n  50% {\r\n    transform: scale(1.2);\r\n  }\r\n  100% {\r\n    transform: scale(0);\r\n  }\r\n}\r\n\r\n.change-transition{\r\n\ttransition: opacity .2s ease;\r\n}\r\n.change-enter, .change-leave{\r\n\topacity: 0;\r\n}\r\n</style>\n\n\n/** WEBPACK FOOTER **\n ** app.vue?6830a384\n **/","module.exports = \" <div id=main> <router-view transition=change> </router-view> <div class=dialog transition=bounce v-show=showDialog> {{msg}} </div> </div> \";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vue-html-loader!./~/vue-loader/lib/selector.js?type=template&index=0!./src/app.vue\n ** module id = 42\n ** module chunks = 9\n **/","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.infiniteScroll = global.infiniteScroll || {})));\n}(this, function (exports) { 'use strict';\n\n  var throttle = function throttle(fn, delay) {\n    var now, lastExec, timer, context, args; //eslint-disable-line\n\n    var execute = function execute() {\n      fn.apply(context, args);\n      lastExec = now;\n    };\n\n    return function () {\n      context = this;\n      args = arguments;\n\n      now = Date.now();\n\n      if (timer) {\n        clearTimeout(timer);\n        timer = null;\n      }\n\n      if (lastExec) {\n        var diff = delay - (now - lastExec);\n        if (diff < 0) {\n          execute();\n        } else {\n          timer = setTimeout(function () {\n            execute();\n          }, diff);\n        }\n      } else {\n        execute();\n      }\n    };\n  };\n\n  var getScrollTop = function getScrollTop(element) {\n    if (element === window) {\n      return Math.max(window.pageYOffset || 0, document.documentElement.scrollTop);\n    }\n\n    return element.scrollTop;\n  };\n\n  var getComputedStyle = document.defaultView.getComputedStyle;\n\n  var getScrollEventTarget = function getScrollEventTarget(element) {\n    var currentNode = element;\n    // bugfix, see http://w3help.org/zh-cn/causes/SD9013 and http://stackoverflow.com/questions/17016740/onscroll-function-is-not-working-for-chrome\n    while (currentNode && currentNode.tagName !== 'HTML' && currentNode.tagName !== 'BODY' && currentNode.nodeType === 1) {\n      var overflowY = getComputedStyle(currentNode).overflowY;\n      if (overflowY === 'scroll' || overflowY === 'auto') {\n        return currentNode;\n      }\n      currentNode = currentNode.parentNode;\n    }\n    return window;\n  };\n\n  var getVisibleHeight = function getVisibleHeight(element) {\n    if (element === window) {\n      return document.documentElement.clientHeight;\n    }\n\n    return element.clientHeight;\n  };\n\n  var getElementTop = function getElementTop(element) {\n    if (element === window) {\n      return getScrollTop(window);\n    }\n    return element.getBoundingClientRect().top + getScrollTop(window);\n  };\n\n  var isAttached = function isAttached(element) {\n    var currentNode = element.parentNode;\n    while (currentNode) {\n      if (currentNode.tagName === 'HTML') {\n        return true;\n      }\n      if (currentNode.nodeType === 11) {\n        return false;\n      }\n      currentNode = currentNode.parentNode;\n    }\n    return false;\n  };\n\n  var infiniteScroll = {\n    doBind: function doBind() {\n      if (this.binded) return; // eslint-disable-line\n      this.binded = true;\n\n      var directive = this;\n      var element = directive.el;\n\n      directive.scrollEventTarget = getScrollEventTarget(element);\n      directive.scrollListener = throttle(directive.doCheck.bind(directive), 200);\n      directive.scrollEventTarget.addEventListener('scroll', directive.scrollListener);\n\n      var disabledExpr = element.getAttribute('infinite-scroll-disabled');\n      var disabled = false;\n\n      if (disabledExpr) {\n        this.vm.$watch(disabledExpr, function (value) {\n          directive.disabled = value;\n          if (!value && directive.immediateCheck) {\n            directive.doCheck();\n          }\n        });\n        disabled = Boolean(directive.vm.$get(disabledExpr));\n      }\n      directive.disabled = disabled;\n\n      var distanceExpr = element.getAttribute('infinite-scroll-distance');\n      var distance = 0;\n      if (distanceExpr) {\n        distance = Number(directive.vm.$get(distanceExpr));\n        if (isNaN(distance)) {\n          distance = 0;\n        }\n      }\n      directive.distance = distance;\n\n      var immediateCheckExpr = element.getAttribute('infinite-scroll-immediate-check');\n      var immediateCheck = true;\n      if (immediateCheckExpr) {\n        immediateCheck = Boolean(directive.vm.$get(immediateCheckExpr));\n      }\n      directive.immediateCheck = immediateCheck;\n\n      if (immediateCheck) {\n        directive.doCheck();\n      }\n\n      var eventName = element.getAttribute('infinite-scroll-listen-for-event');\n      if (eventName) {\n        directive.vm.$on(eventName, function () {\n          directive.doCheck();\n        });\n      }\n    },\n\n    doCheck: function doCheck(force) {\n      var scrollEventTarget = this.scrollEventTarget;\n      var element = this.el;\n      var distance = this.distance;\n\n      if (force !== true && this.disabled) return; //eslint-disable-line\n      var viewportScrollTop = getScrollTop(scrollEventTarget);\n      var viewportBottom = viewportScrollTop + getVisibleHeight(scrollEventTarget);\n\n      var shouldTrigger = false;\n\n      if (scrollEventTarget === element) {\n        shouldTrigger = scrollEventTarget.scrollHeight - viewportBottom <= distance;\n      } else {\n        var elementBottom = getElementTop(element) - getElementTop(scrollEventTarget) + element.offsetHeight + viewportScrollTop;\n\n        shouldTrigger = viewportBottom + distance >= elementBottom;\n      }\n\n      if (shouldTrigger && this.expression) {\n        this.vm.$get(this.expression);\n      }\n    },\n\n    bind: function bind() {\n      var directive = this;\n      var element = this.el;\n\n      directive.vm.$on('hook:ready', function () {\n        if (isAttached(element)) {\n          directive.doBind();\n        }\n      });\n\n      this.bindTryCount = 0;\n\n      var tryBind = function tryBind() {\n        if (directive.bindTryCount > 10) return; //eslint-disable-line\n        directive.bindTryCount++;\n        if (isAttached(element)) {\n          directive.doBind();\n        } else {\n          setTimeout(tryBind, 50);\n        }\n      };\n\n      tryBind();\n    },\n\n    unbind: function unbind() {\n      this.scrollEventTarget.removeEventListener('scroll', this.scrollListener);\n    }\n  };\n\n  if (window.Vue) {\n    window.infiniteScroll = infiniteScroll;\n    Vue.use(install);\n  }\n\n  function install(Vue) {\n    Vue.directive('infiniteScroll', infiniteScroll);\n  }\n\n  exports.install = install;\n  exports.infiniteScroll = infiniteScroll;\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vue-infinite-scroll/vue-infinite-scroll.js\n ** module id = 53\n ** module chunks = 9\n **/","var __vue_script__, __vue_template__\nrequire(\"!!./../node_modules/extract-text-webpack-plugin/loader.js?{\\\"omit\\\":1,\\\"extract\\\":true,\\\"remove\\\":true}!vue-style-loader!css-loader!./../node_modules/vue-loader/lib/style-rewriter.js!sass-loader!./../node_modules/vue-loader/lib/selector.js?type=style&index=0!./app.vue\")\n__vue_script__ = require(\"!!babel-loader?presets[]=es2015&plugins[]=transform-runtime&comments=false!./../node_modules/vue-loader/lib/selector.js?type=script&index=0!./app.vue\")\n__vue_template__ = require(\"!!vue-html-loader!./../node_modules/vue-loader/lib/selector.js?type=template&index=0!./app.vue\")\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/app.vue\n ** module id = 54\n ** module chunks = 9\n **/","//vue\r\nvar Vue = require('vue')\r\n//\r\nvar VueRouter = require('vue-router');\r\n//ajax,\r\nvar VueResource = require('vue-resource');\r\n//\r\nvar VueTouch = require('vue-touch'); \r\nvar hammerjs = require('hammerjs')\r\n\r\nvar app = require('./app.vue');\r\n\r\nvar infiniteScroll =  require('vue-infinite-scroll');\r\n//\r\nVue.use(VueRouter);\r\nVue.use(VueResource);\r\nVue.use(VueTouch);\r\n\r\nVue.use(infiniteScroll);\r\n\r\n\r\n\r\n\r\n// router\r\nvar router = new VueRouter({\r\n    // hashbangtrue#!\r\n    hashbang: true,\r\n    history: false,\r\n    saveScrollPosition: false,\r\n    transitionOnLoad: true\r\n});\r\n\r\n\r\n\r\n\r\n\r\n\r\n//\r\nrouter.map({\r\n    //  '/':{                    //\r\n    //     component: function (resolve) {\r\n    //        require(['./vue/home.vue'],resolve)\r\n    //      }\r\n    // },\r\n    '/home':{\r\n        name : 'home',                    //\r\n        component: function (resolve) {\r\n           require(['./vue/home.vue'],resolve)\r\n         }\r\n    },\r\n    '/myshop':{\r\n        name: 'myshop',\r\n        component: function(resolve) {\r\n            require(['./vue/myshop.vue'],resolve)//\r\n        }\r\n    },\r\n    '/mysign':{\r\n        name: 'mysign',\r\n        component: function(resolve){\r\n            require(['./vue/mysign.vue'],resolve)//\r\n        }\r\n    },\r\n    '/goodDetail':{\r\n      name:'goodDetail',\r\n      component:function(resolve){\r\n            require(['./vue/goodDetail.vue'],resolve)\r\n      }\r\n    },\r\n    '/orderDetail':{\r\n      component:function(resolve){\r\n            require(['./vue/orderDetail.vue'],resolve)\r\n      }\r\n    },\r\n    '/infoSure':{\r\n      component:function(resolve){\r\n            require(['./vue/infoSure.vue'],resolve)\r\n      }\r\n    },\r\n    '/saveAddr':{\r\n      component:function(resolve){\r\n            require(['./vue/saveAddr.vue'],resolve)\r\n      }\r\n    },\r\n    '/playRule':{\r\n      component:function(resolve){\r\n            require(['./vue/playRule.vue'],resolve)\r\n      }\r\n    }\r\n});\r\n\r\nrouter.redirect({\r\n  '*':'/home'\r\n})\r\n\r\n\r\n// router.beforeEach(function(transition){\r\n  \r\n// })\r\n\r\n\r\n//\r\nrouter.afterEach(function (transition) {\r\n  console.log(': ' + transition.to.path)\r\n\r\n  var isGoodDetail = transition.to.path.indexOf('/goodDetail') \r\n  if (isGoodDetail>=0) {\r\n    document.body.scrollTop = 0;\r\n  }else{\r\n\r\n  }\r\n  \r\n});\r\n// \r\nrouter.start(app,\"#app\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/main.js\n ** module id = 69\n ** module chunks = 9\n **/","var Vue = require('vue');\r\nvar Vuex= require('vuex');\r\n\r\n\r\n\r\nVue.use(Vuex);\r\n\r\n\r\n\r\n\r\n\r\nmodule.exports =  new Vuex.Store({\r\n  state:{\r\n  \tuserInfo:{\r\n          // success:true,\r\n          // ymMoney:1000,\r\n          // points:1230,\r\n          // continus:3,\r\n          // canSign:1\r\n        },\r\n    goodsInfo:{\r\n\r\n    },\r\n    uid:{\r\n\r\n    },\r\n    address:{\r\n\r\n    }\r\n  },\r\n  mutations:{\r\n  \tGETINFO:function(state,obj){\r\n  \t\tstate.userInfo = obj\r\n  \t},\r\n    SETGOODINFO:function(state,obj){\r\n      state.goodsInfo = obj\r\n    },\r\n    GETUID:function(state,str){\r\n      state.uid = str\r\n    },\r\n    SETADDRESS:function(state,obj){\r\n      state.address = obj\r\n    }\r\n  }\r\n\r\n\r\n\r\n\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/vuex/store.js\n ** module id = 70\n ** module chunks = 9\n **/"],"sourceRoot":""}